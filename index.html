<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CBGames Offline Launcher</title>
<link rel="icon" type="image/png" href="./favicon.png">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.6.2/dist/cropper.min.css">
<style>
  :root {
    --error-color: #ff4d4f;
  }
  * { box-sizing: border-box; }
  body {
    background-color: #121212;
    margin: 0;
    color: #fff;
    font-family: "Poppins", sans-serif;
  }
  header {
    position: sticky;
    top: 0;
    background-color: #181818;
    display: flex;
    justify-content: space-between;
    padding: 15px 30px;
    z-index: 1000;
  }
  header .logo {
    color: #fff;
    font-size: 24px;
    font-weight: 600;
  }
  header nav {
    display: flex;
    gap: 20px;
    align-items: center;
  }
  header nav a {
    text-decoration: none;
    color: white;
    font-size: 18px;
    padding: 5px 10px;
    border-radius: 5px;
    background-color: #1a1a1a;
    transition: background 0.3s;
  }
  header nav a:hover {
    background-color: #2a2a2a;
  }
  .profile-pic-container {
    margin-left: auto;
    padding: 0 10px;
  }
  #profilePicture {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid #444;
    transition: none;
  }
  #profilePicture:hover {
    transform: none;
    cursor: pointer;
  }
  .search-bar {
    margin: 20px auto;
    width: min(980px, 90vw);
    display: flex;
    justify-content: center;
  }
  .search-bar input {
    width: 100%;
    padding: 10px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    background: #1a1a1a;
    color: #fff;
  }
  button {
    border: 1px solid #2d2d2d;
    background: #1a1a1a;
    color: #fff;
    border-radius: 8px;
    padding: 10px 12px;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
  }
  button:hover:not(:disabled):not(.square-button) { background: #2a2a2a; }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  #deleteGame { color: #ffbcbc; }
  .workspace {
    width: min(1480px, 96vw);
    margin: 0 auto 24px;
    display: grid;
    grid-template-columns: 280px minmax(0, 1fr) 320px;
    gap: 16px;
    align-items: start;
  }
  .games-column {
    display: grid;
    justify-items: center;
    gap: 10px;
  }
  .container {
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr));
    gap: 20px;
    padding: 20px;
    background: #141414;
    border-radius: 12px;
    min-height: 260px;
    width: min(980px, 100%);
  }
  .game-item {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    text-align: center;
    transition: background-color 0.3s, transform 0.3s;
    border-radius: 15px;
    overflow: hidden;
    background: transparent;
    transform-origin: center;
    min-width: 0;
  }
  .game-item:hover {
    background-color: #1e1e1e;
    transform: scale(1.03);
  }
  .game-item.is-selected {
    background-color: #222;
    outline: 1px solid #3b3b3b;
  }
  .square-button {
    width: 100%;
    height: auto;
    aspect-ratio: 1 / 1;
    border: none;
    padding: 0;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-color: #202938;
    position: relative;
    cursor: pointer;
    display: block;
    transform: none;
    min-width: 0;
  }
  @supports not (aspect-ratio: 1 / 1) {
    .square-button {
      height: 0;
      padding-bottom: 100%;
    }
  }
  .square-button:hover {
    transform: none;
  }
  .square-button.no-thumb::before {
    content: "No thumbnail";
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 13px;
    color: #d8deeb;
    background: rgba(0, 0, 0, 0.25);
    border-radius: 999px;
    padding: 3px 8px;
  }
  .thumb-edit {
    position: absolute;
    right: 8px;
    bottom: 8px;
    border: 1px solid #444;
    background: rgba(16, 16, 16, 0.85);
    color: #fff;
    border-radius: 999px;
    font-size: 11px;
    padding: 4px 8px;
  }
  .game-info {
    padding: 10px;
    width: 100%;
    background: #181818;
  }
  .game-title {
    color: #fff;
    font-size: 16px;
    margin: 0 0 8px;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    min-height: 40px;
  }
  .game-buttons {
    display: flex;
    justify-content: center;
    gap: 8px;
  }
  .game-buttons button {
    font-size: 12px;
    padding: 6px 8px;
    border-radius: 6px;
    background: #202020;
    border-color: #333;
    width: 100%;
  }
  .game-buttons .danger { color: #ffbcbc; }
  .side-panel {
    display: grid;
    gap: 12px;
  }
  .control-stack {
    display: grid;
    gap: 8px;
  }
  .work-progress {
    display: grid;
    justify-items: center;
    gap: 8px;
  }
  .work-progress-circle {
    --progress-pct: 0;
    width: 88px;
    height: 88px;
    border-radius: 50%;
    background: conic-gradient(#73c9ff calc(var(--progress-pct) * 1%), #2a2a2a 0);
    position: relative;
    display: grid;
    place-items: center;
    transition: background 0.2s ease;
  }
  .work-progress-circle::before {
    content: "";
    width: 70px;
    height: 70px;
    border-radius: 50%;
    background: #151515;
    border: 1px solid #333;
  }
  .work-progress-value {
    position: absolute;
    font-size: 13px;
    font-weight: 600;
    color: #dff0ff;
  }
  .work-progress-label {
    font-size: 12px;
    color: #d6d6d6;
    text-align: center;
  }
  .work-progress.indeterminate .work-progress-circle {
    --progress-pct: 25;
    animation: workProgressSpin 1s linear infinite;
  }
  @keyframes workProgressSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
  .selected-stats {
    display: grid;
    gap: 8px;
    margin-top: 8px;
  }
  .panel-block {
    background: #181818;
    border-radius: 10px;
    border: 1px solid #2a2a2a;
    padding: 12px;
  }
  .panel-block h3 {
    margin: 0 0 10px;
    font-size: 15px;
    font-weight: 600;
  }
  .metrics {
    display: grid;
    gap: 8px;
  }
  .metric {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #1d1d1d;
    border: 1px solid #2a2a2a;
    border-radius: 8px;
    padding: 8px 10px;
  }
  .metric-label { color: #bababa; font-size: 12px; text-transform: uppercase; }
  .metric-value { color: #fff; font-size: 13px; font-weight: 600; }
  .hint {
    font-size: 13px;
    color: #c9c9c9;
    background: #1d1d1d;
    border: 1px solid #2b2b2b;
    padding: 8px 10px;
    border-radius: 8px;
    margin: 0;
  }
  details.advanced {
    border: 1px dashed #3a3a3a;
    border-radius: 10px;
    padding: 8px;
    margin-top: 10px;
    background: #171717;
  }
  details.advanced summary {
    cursor: pointer;
    color: #fff;
    font-size: 13px;
    font-weight: 600;
  }
  .log-dropdown {
    margin-top: 0;
  }
  .log-dropdown #status {
    margin-top: 8px;
  }
  #entryFile {
    width: 100%;
    border: 1px solid #3a3a3a;
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 14px;
    background: #1a1a1a;
    color: #fff;
    margin-top: 8px;
  }
  #status {
    min-height: 120px;
    max-height: 240px;
    overflow: auto;
    white-space: pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 12px;
    line-height: 1.45;
    border: 1px solid #2f2f2f;
    border-radius: 8px;
    background: #111;
    padding: 10px;
  }
  #status > div { padding: 3px 0; border-bottom: 1px solid #232323; }
  #status > div:last-child { border-bottom: 0; }
  #status .error { color: var(--error-color); }
  .sr-only {
    position: absolute !important;
    width: 1px;
    height: 1px;
    margin: -1px;
    padding: 0;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
    white-space: nowrap;
  }
  .empty-library {
    display: none;
    text-align: center;
    padding: 14px;
    color: #d3d3d3;
  }
  .empty-library.visible { display: block; }
  .thumb-modal {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.85);
    display: none;
    align-items: center;
    justify-content: center;
    padding: 14px;
    z-index: 10000;
  }
  .thumb-modal.open { display: flex; }
  .thumb-dialog {
    width: min(780px, 96vw);
    border: 1px solid #353535;
    background: #181818;
    border-radius: 12px;
    padding: 12px;
    display: grid;
    gap: 10px;
  }
  .thumb-head {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }
  .thumb-head h3 { margin: 0; font-size: 16px; }
  .thumb-close { width: auto; }
  .thumb-layout {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    justify-items: center;
  }
  .thumb-canvas-wrap,
  .thumb-crop-wrap {
    border: 1px solid #343434;
    border-radius: 10px;
    background: #0f0f0f;
    padding: 8px;
    aspect-ratio: 1 / 1;
    display: grid;
    place-items: center;
    width: min(560px, 100%);
  }
  #thumbCropImage {
    width: 100%;
    height: 100%;
    object-fit: contain;
    border-radius: 8px;
    background: #0a0a0a;
    display: block;
  }
  .thumb-crop-wrap.is-empty #thumbCropImage {
    display: none;
  }
  .thumb-empty-note {
    display: none;
    color: #c8c8c8;
    font-size: 14px;
    text-align: center;
    padding: 10px;
    border: 1px dashed #404040;
    border-radius: 10px;
    width: 100%;
    height: 100%;
    align-content: center;
  }
  .thumb-crop-wrap.is-empty .thumb-empty-note {
    display: grid;
  }
  .thumb-buttons {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px;
  }
  #removeThumb { color: #ffd7bc; }
  @media (max-width: 980px) {
    .workspace {
      grid-template-columns: 1fr;
    }
    .container {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }
  }
  @media (max-width: 740px) {
    header {
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
      padding: 15px;
    }
    header nav {
      flex-wrap: wrap;
      gap: 10px;
    }
    .container {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }
  @media (max-width: 480px) {
    .container {
      grid-template-columns: 1fr;
    }
  }
</style>
</head>
<body>
<header>
  <div class="logo">CBGames</div>
</header>

<div class="search-bar">
  <input id="gameSearch" type="search" placeholder="Search for games...">
</div>

<div class="workspace">
  <aside class="side-panel">
    <section class="panel-block">
      <h3>Progress</h3>
      <div id="workProgress" class="work-progress" aria-live="polite">
        <div id="workProgressCircle" class="work-progress-circle">
          <div id="workProgressValue" class="work-progress-value">0%</div>
        </div>
        <div id="workProgressLabel" class="work-progress-label">Idle...</div>
      </div>
    </section>
    <section class="panel-block">
      <h3>Launcher Controls</h3>
      <div class="control-stack">
        <button id="importZip">Import ZIP Game</button>
        <button id="launch">Launch Selected</button>
        <button id="deleteGame">Delete Selected</button>
      </div>
    </section>
    <section class="panel-block">
      <h3>Other stuff</h3>
      <div class="control-stack">
        <select id="entryFile"></select>
        <button id="exportAllGames" type="button">Export All Games</button>
        <button id="importAllGames" type="button">Import All Games</button>
      </div>
    </section>
  </aside>
  <div class="games-column">
    <div id="gamesGrid" class="container"></div>
    <p id="emptyLibrary" class="empty-library visible">No saved games yet.</p>
  </div>
  <aside class="side-panel">
    <section class="panel-block">
      <h3>Storage Overview</h3>
      <div class="metrics">
        <div class="metric">
          <span class="metric-label">Games</span>
          <strong id="libraryCount" class="metric-value">0</strong>
        </div>
        <div class="metric">
          <span class="metric-label">Saved Size</span>
          <strong id="libraryBytes" class="metric-value">0 B</strong>
        </div>
        <div class="metric">
          <span class="metric-label">Browser Usage</span>
          <strong id="quotaUsage" class="metric-value">Checking...</strong>
        </div>
      </div>
    </section>
    <section class="panel-block">
      <h3>Selected Game</h3>
      <p class="hint" id="gameMeta">No saved game selected.</p>
      <div class="selected-stats">
        <div class="metric"><span class="metric-label">Imported</span><strong id="selectedImported" class="metric-value">-</strong></div>
        <div class="metric"><span class="metric-label">Files</span><strong id="selectedFiles" class="metric-value">-</strong></div>
        <div class="metric"><span class="metric-label">Saved Size</span><strong id="selectedSize" class="metric-value">-</strong></div>
        <div class="metric"><span class="metric-label">Source ZIP</span><strong id="selectedSource" class="metric-value">-</strong></div>
        <div class="metric"><span class="metric-label">Startup</span><strong id="selectedEntry" class="metric-value">-</strong></div>
      </div>
    </section>
    <section class="panel-block">
      <details class="advanced log-dropdown">
        <summary>Activity Log</summary>
        <div id="status" aria-live="polite"></div>
      </details>
    </section>
  </aside>
</div>
<select id="gameSelect" class="sr-only" aria-hidden="true" tabindex="-1"></select>

<input id="zipInput" type="file" accept=".zip,application/zip,application/x-zip-compressed" hidden>
<input id="bundleInput" type="file" accept=".zip,application/zip,application/x-zip-compressed" hidden>
<input id="thumbInput" type="file" accept="image/*" hidden>
<div id="thumbModal" class="thumb-modal" aria-hidden="true">
  <div class="thumb-dialog">
    <div class="thumb-head">
      <h3>Thumbnail Editing</h3>
      <button id="closeThumbModal" class="thumb-close" type="button">Close</button>
    </div>
    <div class="thumb-layout">
      <div id="thumbCropWrap" class="thumb-crop-wrap is-empty">
        <img id="thumbCropImage" alt="Thumbnail crop preview">
        <div class="thumb-empty-note">No thumbnail yet</div>
      </div>
    </div>
    <div class="thumb-buttons">
      <button id="uploadThumb" type="button">Choose Image</button>
      <button id="saveThumb" type="button">Save Crop</button>
      <button id="removeThumb" type="button">Remove</button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/cropperjs@1.6.2/dist/cropper.min.js"></script>
<script>
(() => {
  "use strict";

  const DB_NAME = "cbgamesOfflineZipDB";
  const DB_VERSION = 1;
  const STORE_GAMES = "games";
  const STORE_FILES = "files";
  const STORE_SETTINGS = "settings";
  const SETTING_SELECTED_GAME = "selectedGameId";

  const VFS_ORIGIN = "https://loader.invalid/";
  const VFS_ORIGIN_URL = new URL(VFS_ORIGIN).origin;
  const UNITY_GPU_SAFE_MODE = true;
  const UNITY_FORCE_WEBGL1 = true;
  const UNITY_CLAMP_DEVICE_PIXEL_RATIO = 1;

  const importZipButton = document.getElementById("importZip");
  const launchButton = document.getElementById("launch");
  const deleteGameButton = document.getElementById("deleteGame");
  const gameSelect = document.getElementById("gameSelect");
  const gameSearch = document.getElementById("gameSearch");
  const gamesGrid = document.getElementById("gamesGrid");
  const emptyLibrary = document.getElementById("emptyLibrary");
  const entrySelect = document.getElementById("entryFile");
  const zipInput = document.getElementById("zipInput");
  const bundleInput = document.getElementById("bundleInput");
  const exportAllGamesButton = document.getElementById("exportAllGames");
  const importAllGamesButton = document.getElementById("importAllGames");
  const workProgress = document.getElementById("workProgress");
  const workProgressCircle = document.getElementById("workProgressCircle");
  const workProgressValue = document.getElementById("workProgressValue");
  const workProgressLabel = document.getElementById("workProgressLabel");
  const thumbInput = document.getElementById("thumbInput");
  const thumbModal = document.getElementById("thumbModal");
  const closeThumbModalButton = document.getElementById("closeThumbModal");
  const uploadThumbButton = document.getElementById("uploadThumb");
  const saveThumbButton = document.getElementById("saveThumb");
  const removeThumbButton = document.getElementById("removeThumb");
  const thumbCropWrap = document.getElementById("thumbCropWrap");
  const thumbCropImage = document.getElementById("thumbCropImage");

  const gameMeta = document.getElementById("gameMeta");
  const selectedImported = document.getElementById("selectedImported");
  const selectedFiles = document.getElementById("selectedFiles");
  const selectedSize = document.getElementById("selectedSize");
  const selectedSource = document.getElementById("selectedSource");
  const selectedEntry = document.getElementById("selectedEntry");
  const libraryCount = document.getElementById("libraryCount");
  const libraryBytes = document.getElementById("libraryBytes");
  const quotaUsage = document.getElementById("quotaUsage");

  const statusBox = document.getElementById("status");

  const state = {
    db: null,
    gamesById: new Map(),
    selectedGameId: null,
    objectUrls: new Map(),
    objectUrlHost: window,
    activeEntryPath: null,
    playerWindow: null,
    searchQuery: "",
    thumbEditor: {
      gameId: null,
      image: null,
      sourceUrl: null,
      cropper: null
    }
  };

  function log(message, type = "info") {
    const line = document.createElement("div");
    if (type === "error") {
      line.className = "error";
    }
    const timestamp = new Date().toLocaleTimeString();
    line.textContent = "[" + timestamp + "] " + message;
    statusBox.append(line);
    statusBox.scrollTop = statusBox.scrollHeight;
  }

  function normalizePath(path) {
    return String(path)
      .replace(/\\/g, "/")
      .replace(/^\/+/, "")
      .replace(/\/+/g, "/");
  }

  function dirnamePath(path) {
    const normalized = normalizePath(path);
    const idx = normalized.lastIndexOf("/");
    if (idx === -1) {
      return "";
    }
    return normalized.slice(0, idx);
  }

  function toVirtualUrl(path) {
    const normalized = normalizePath(path);
    const encoded = normalized.split("/").map(encodeURIComponent).join("/");
    return VFS_ORIGIN + encoded;
  }

  function formatBytes(value) {
    const bytes = Number(value) || 0;
    if (bytes === 0) {
      return "0 B";
    }
    const units = ["B", "KB", "MB", "GB", "TB"];
    const exponent = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
    const scaled = bytes / Math.pow(1024, exponent);
    return scaled.toFixed(scaled >= 100 || exponent === 0 ? 0 : 1) + " " + units[exponent];
  }

  function formatDate(ts) {
    if (!ts) {
      return "unknown";
    }
    return new Date(ts).toLocaleString();
  }

  function makeId() {
    if (window.crypto && typeof window.crypto.randomUUID === "function") {
      return window.crypto.randomUUID();
    }
    return "game-" + Date.now() + "-" + Math.random().toString(16).slice(2);
  }

  function deriveGameName(fileName) {
    const cleaned = String(fileName || "")
      .replace(/\.zip$/i, "")
      .replace(/[_-]+/g, " ")
      .trim();
    return cleaned || "Imported Game";
  }

  function mimeFromPath(path) {
    const lower = normalizePath(path).toLowerCase();
    const ext = lower.includes(".") ? lower.slice(lower.lastIndexOf(".")) : "";
    switch (ext) {
      case ".html":
      case ".htm":
        return "text/html";
      case ".js":
      case ".mjs":
      case ".cjs":
        return "application/javascript";
      case ".css":
        return "text/css";
      case ".json":
        return "application/json";
      case ".wasm":
        return "application/wasm";
      case ".png":
        return "image/png";
      case ".jpg":
      case ".jpeg":
        return "image/jpeg";
      case ".gif":
        return "image/gif";
      case ".svg":
        return "image/svg+xml";
      case ".ico":
        return "image/x-icon";
      case ".webp":
        return "image/webp";
      case ".mp3":
        return "audio/mpeg";
      case ".ogg":
        return "audio/ogg";
      case ".wav":
        return "audio/wav";
      case ".mp4":
        return "video/mp4";
      case ".webm":
        return "video/webm";
      case ".woff":
        return "font/woff";
      case ".woff2":
        return "font/woff2";
      case ".ttf":
        return "font/ttf";
      case ".otf":
        return "font/otf";
      case ".unityweb":
      case ".data":
      case ".mem":
      case ".bin":
        return "application/octet-stream";
      default:
        return "application/octet-stream";
    }
  }

  function escapeHtml(value) {
    return String(value)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;");
  }

  function sortedGames() {
    return Array.from(state.gamesById.values()).sort((a, b) => b.importedAt - a.importedAt);
  }

  function filteredGames() {
    const query = state.searchQuery.trim().toLowerCase();
    const games = sortedGames();
    if (!query) {
      return games;
    }
    return games.filter((game) => {
      const name = String(game.name || "").toLowerCase();
      const zipName = String(game.zipName || "").toLowerCase();
      return name.includes(query) || zipName.includes(query);
    });
  }

  function renderGameCards() {
    const games = filteredGames();
    gamesGrid.innerHTML = "";
    emptyLibrary.classList.toggle("visible", games.length === 0);

    for (const game of games) {
      const selectedClass = game.id === state.selectedGameId ? " is-selected" : "";
      const hasThumb = typeof game.thumbnailDataUrl === "string" && game.thumbnailDataUrl.length > 0;
      const thumbClass = hasThumb ? "square-button" : "square-button no-thumb";
      const thumbStyle = hasThumb
        ? " style=\"background-image:url('" + escapeHtml(game.thumbnailDataUrl) + "');\""
        : "";
      const thumbButtonLabel = hasThumb ? "Edit thumb" : "Add thumb";
      const card = document.createElement("div");
      card.className = "game-item" + selectedClass;
      card.dataset.gameId = game.id;
      card.innerHTML =
        "<button class=\"" + thumbClass + "\" data-action=\"select\" data-game-id=\"" + escapeHtml(game.id) + "\" type=\"button\"" + thumbStyle + ">" +
          "<span class=\"thumb-edit\" data-action=\"thumb\" data-game-id=\"" + escapeHtml(game.id) + "\">" + thumbButtonLabel + "</span>" +
        "</button>" +
        "<div class=\"game-info\">" +
          "<p class=\"game-title\">" + escapeHtml(game.name || "Untitled game") + "</p>" +
          "<div class=\"game-buttons\">" +
            "<button data-action=\"launch\" data-game-id=\"" + escapeHtml(game.id) + "\" type=\"button\">Play</button>" +
            "<button class=\"danger\" data-action=\"delete\" data-game-id=\"" + escapeHtml(game.id) + "\" type=\"button\">Delete</button>" +
          "</div>" +
        "</div>";
      gamesGrid.append(card);
    }
  }

  function closeThumbModal() {
    thumbModal.classList.remove("open");
    thumbModal.setAttribute("aria-hidden", "true");
    if (state.thumbEditor.cropper) {
      state.thumbEditor.cropper.destroy();
      state.thumbEditor.cropper = null;
    }
    if (state.thumbEditor.sourceUrl) {
      URL.revokeObjectURL(state.thumbEditor.sourceUrl);
    }
    state.thumbEditor.gameId = null;
    state.thumbEditor.image = null;
    state.thumbEditor.sourceUrl = null;
    thumbCropWrap.classList.add("is-empty");
    thumbCropImage.removeAttribute("src");
    thumbInput.value = "";
  }

  function initThumbnailCropper() {
    if (!window.Cropper) {
      log("Thumbnail cropper failed to load.", "error");
      return;
    }
    if (state.thumbEditor.cropper) {
      state.thumbEditor.cropper.destroy();
    }
    state.thumbEditor.cropper = new Cropper(thumbCropImage, {
      aspectRatio: 1,
      viewMode: 1,
      dragMode: "move",
      autoCropArea: 0.85,
      responsive: true,
      background: false,
      zoomable: true,
      movable: true,
      rotatable: false,
      scalable: false,
      guides: true,
      ready() {
        const cropper = state.thumbEditor.cropper;
        if (!cropper) {
          return;
        }
        const container = cropper.getContainerData();
        const base = Math.min(container.width, container.height) * 0.82;
        cropper.setCropBoxData({
          width: base,
          height: base,
          left: (container.width - base) / 2,
          top: (container.height - base) / 2
        });
      }
    });
  }

  function setThumbnailCropSource(sourceUrl) {
    if (!sourceUrl) {
      if (state.thumbEditor.cropper) {
        state.thumbEditor.cropper.destroy();
        state.thumbEditor.cropper = null;
      }
      thumbCropWrap.classList.add("is-empty");
      thumbCropImage.removeAttribute("src");
      return;
    }
    thumbCropWrap.classList.remove("is-empty");
    thumbCropImage.onload = () => initThumbnailCropper();
    thumbCropImage.src = sourceUrl;
  }

  async function saveThumbnailCrop() {
    const gameId = state.thumbEditor.gameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game) {
      log("Select a game before saving a thumbnail.", "error");
      return;
    }
    if (!state.thumbEditor.cropper) {
      log("Choose an image first.", "error");
      return;
    }

    const cropped = state.thumbEditor.cropper.getCroppedCanvas({
      width: 1024,
      height: 1024,
      imageSmoothingEnabled: true,
      imageSmoothingQuality: "high"
    });
    if (!cropped) {
      log("Could not crop this image.", "error");
      return;
    }

    game.thumbnailDataUrl = cropped.toDataURL("image/jpeg", 0.9);
    state.gamesById.set(game.id, game);
    await putGame(game);
    renderGameCards();
    closeThumbModal();
    log("Saved thumbnail for " + game.name + ".");
  }

  async function removeThumbnail() {
    const gameId = state.thumbEditor.gameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game) {
      return;
    }
    game.thumbnailDataUrl = "";
    state.gamesById.set(game.id, game);
    await putGame(game);
    renderGameCards();
    closeThumbModal();
    log("Removed thumbnail for " + game.name + ".");
  }

  function openThumbnailModal(gameId) {
    if (!gameId || !state.gamesById.has(gameId)) {
      return;
    }
    const game = state.gamesById.get(gameId);
    state.thumbEditor.gameId = gameId;
    if (state.thumbEditor.cropper) {
      state.thumbEditor.cropper.destroy();
      state.thumbEditor.cropper = null;
    }
    state.thumbEditor.image = null;
    if (state.thumbEditor.sourceUrl) {
      URL.revokeObjectURL(state.thumbEditor.sourceUrl);
    }
    state.thumbEditor.sourceUrl = null;
    if (game && typeof game.thumbnailDataUrl === "string" && game.thumbnailDataUrl) {
      setThumbnailCropSource(game.thumbnailDataUrl);
    } else {
      setThumbnailCropSource("");
    }
    thumbModal.classList.add("open");
    thumbModal.setAttribute("aria-hidden", "false");
  }

  function loadThumbnailSource(file) {
    if (!file || !file.type.startsWith("image/")) {
      log("Please choose an image file for thumbnails.", "error");
      return;
    }
    if (state.thumbEditor.sourceUrl) {
      URL.revokeObjectURL(state.thumbEditor.sourceUrl);
    }
    const objectUrl = URL.createObjectURL(file);
    state.thumbEditor.sourceUrl = objectUrl;
    setThumbnailCropSource(objectUrl);
  }

  async function selectGameById(nextId) {
    const selectedId = nextId && state.gamesById.has(nextId) ? nextId : null;
    state.selectedGameId = selectedId;
    gameSelect.value = selectedId || "";
    await putSetting(SETTING_SELECTED_GAME, selectedId || "");
    updateSelectedGameInfo(selectedId ? state.gamesById.get(selectedId) : null);
    renderGameCards();
  }

  function normalizeResolverBase(baseHref) {
    if (typeof baseHref === "string" && baseHref) {
      try {
        const parsed = new URL(baseHref);
        if (parsed.origin === VFS_ORIGIN_URL) {
          return parsed.href;
        }
      } catch {
        // fall through
      }
    }
    if (state.activeEntryPath) {
      return toVirtualUrl(state.activeEntryPath);
    }
    return VFS_ORIGIN;
  }

  function resolveToPath(rawValue, baseHref) {
    if (typeof rawValue !== "string") {
      return null;
    }
    const value = rawValue.trim();
    if (!value || value.startsWith("#")) {
      return null;
    }
    const lower = value.toLowerCase();
    if (
      lower.startsWith("data:") ||
      lower.startsWith("blob:") ||
      lower.startsWith("javascript:") ||
      lower.startsWith("mailto:") ||
      lower.startsWith("tel:")
    ) {
      return null;
    }
    let resolved;
    try {
      resolved = new URL(value, baseHref || VFS_ORIGIN);
    } catch {
      return null;
    }
    if (resolved.origin !== VFS_ORIGIN_URL) {
      return null;
    }
    const decoded = decodeURIComponent(resolved.pathname.slice(1));
    const normalized = normalizePath(decoded);
    return normalized || null;
  }

  function requestToObjectUrl(rawValue, baseHref) {
    const raw = String(rawValue);
    const resolvedBase = normalizeResolverBase(baseHref);
    const path = resolveToPath(raw, resolvedBase);
    if (!path) {
      return null;
    }
    const direct = state.objectUrls.get(path);
    if (direct) {
      return direct;
    }

    const trimmed = raw.trim();
    const isRootLike =
      trimmed.startsWith("/") ||
      trimmed.startsWith(VFS_ORIGIN) ||
      trimmed.startsWith(VFS_ORIGIN_URL + "/");
    if (!isRootLike) {
      return null;
    }

    let probeDir = "";
    const basePath = resolveToPath(resolvedBase, VFS_ORIGIN);
    if (basePath) {
      probeDir = dirnamePath(basePath);
    } else if (state.activeEntryPath) {
      probeDir = dirnamePath(state.activeEntryPath);
    }

    while (probeDir) {
      const candidate = normalizePath(probeDir + "/" + path);
      const mapped = state.objectUrls.get(candidate);
      if (mapped) {
        return mapped;
      }
      probeDir = dirnamePath(probeDir);
    }
    return null;
  }

  window.__loaderResolve = requestToObjectUrl;

  function txDone(tx) {
    return new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error || new Error("Transaction failed"));
      tx.onabort = () => reject(tx.error || new Error("Transaction aborted"));
    });
  }

  function openDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onupgradeneeded = (event) => {
        const db = event.target.result;

        if (!db.objectStoreNames.contains(STORE_GAMES)) {
          db.createObjectStore(STORE_GAMES, { keyPath: "id" });
        }
        if (!db.objectStoreNames.contains(STORE_FILES)) {
          const filesStore = db.createObjectStore(STORE_FILES, { keyPath: ["gameId", "path"] });
          filesStore.createIndex("gameId", "gameId", { unique: false });
        }
        if (!db.objectStoreNames.contains(STORE_SETTINGS)) {
          db.createObjectStore(STORE_SETTINGS);
        }
      };
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async function reopenDatabaseConnection() {
    if (state.db) {
      try {
        state.db.close();
      } catch {
        // ignore close errors
      }
    }
    state.db = await openDatabase();
  }

  function putSetting(key, value) {
    const tx = state.db.transaction(STORE_SETTINGS, "readwrite");
    tx.objectStore(STORE_SETTINGS).put(value, key);
    return txDone(tx);
  }

  function getSetting(key) {
    return new Promise((resolve, reject) => {
      const tx = state.db.transaction(STORE_SETTINGS, "readonly");
      const request = tx.objectStore(STORE_SETTINGS).get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  function putGame(gameRecord) {
    const tx = state.db.transaction(STORE_GAMES, "readwrite");
    tx.objectStore(STORE_GAMES).put(gameRecord);
    return txDone(tx);
  }

  function deleteGameRecord(gameId) {
    const tx = state.db.transaction(STORE_GAMES, "readwrite");
    tx.objectStore(STORE_GAMES).delete(gameId);
    return txDone(tx);
  }

  function getAllGames() {
    return new Promise((resolve, reject) => {
      const tx = state.db.transaction(STORE_GAMES, "readonly");
      const request = tx.objectStore(STORE_GAMES).getAll();
      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(request.error);
    });
  }

  function putFileRecord(record) {
    const tx = state.db.transaction(STORE_FILES, "readwrite");
    tx.objectStore(STORE_FILES).put(record);
    return txDone(tx);
  }

  function getAllFilesForGame(gameId) {
    return new Promise((resolve, reject) => {
      const out = [];
      const tx = state.db.transaction(STORE_FILES, "readonly");
      const index = tx.objectStore(STORE_FILES).index("gameId");
      const request = index.openCursor(IDBKeyRange.only(gameId));
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (!cursor) {
          return;
        }
        out.push(cursor.value);
        cursor.continue();
      };
      request.onerror = () => reject(request.error);
      tx.oncomplete = () => resolve(out);
      tx.onabort = () => reject(tx.error || new Error("Failed to read files"));
    });
  }

  function deleteFilesByGameId(gameId) {
    return new Promise((resolve, reject) => {
      const tx = state.db.transaction(STORE_FILES, "readwrite");
      const index = tx.objectStore(STORE_FILES).index("gameId");
      const request = index.openCursor(IDBKeyRange.only(gameId));
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (!cursor) {
          return;
        }
        cursor.delete();
        cursor.continue();
      };
      request.onerror = () => reject(request.error);
      tx.oncomplete = () => resolve();
      tx.onabort = () => reject(tx.error || new Error("Failed to delete files"));
    });
  }

  function findEocdOffset(bytes) {
    const minEocdLength = 22;
    const maxCommentLength = 65535;
    const start = Math.max(0, bytes.length - minEocdLength - maxCommentLength);
    for (let i = bytes.length - minEocdLength; i >= start; i -= 1) {
      if (
        bytes[i] === 0x50 &&
        bytes[i + 1] === 0x4b &&
        bytes[i + 2] === 0x05 &&
        bytes[i + 3] === 0x06
      ) {
        return i;
      }
    }
    return -1;
  }

  const CRC32_TABLE = (() => {
    const table = new Uint32Array(256);
    for (let i = 0; i < 256; i += 1) {
      let c = i;
      for (let j = 0; j < 8; j += 1) {
        c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[i] = c >>> 0;
    }
    return table;
  })();

  function crc32(bytes) {
    let c = 0xffffffff;
    for (let i = 0; i < bytes.length; i += 1) {
      c = CRC32_TABLE[(c ^ bytes[i]) & 0xff] ^ (c >>> 8);
    }
    return (c ^ 0xffffffff) >>> 0;
  }

  function createZipStoreArchive(entries) {
    const encoder = new TextEncoder();
    const localParts = [];
    const centralParts = [];
    let localOffset = 0;
    let centralSize = 0;

    for (const entry of entries) {
      const name = normalizePath(entry.path || "");
      const data = entry.bytes instanceof Uint8Array ? entry.bytes : new Uint8Array(entry.bytes || []);
      const nameBytes = encoder.encode(name);
      const checksum = crc32(data);

      const localHeader = new Uint8Array(30 + nameBytes.length);
      const localView = new DataView(localHeader.buffer);
      localView.setUint32(0, 0x04034b50, true);
      localView.setUint16(4, 20, true);
      localView.setUint16(6, 0, true);
      localView.setUint16(8, 0, true); // store
      localView.setUint16(10, 0, true);
      localView.setUint16(12, 0, true);
      localView.setUint32(14, checksum, true);
      localView.setUint32(18, data.length, true);
      localView.setUint32(22, data.length, true);
      localView.setUint16(26, nameBytes.length, true);
      localView.setUint16(28, 0, true);
      localHeader.set(nameBytes, 30);
      localParts.push(localHeader, data);

      const centralHeader = new Uint8Array(46 + nameBytes.length);
      const centralView = new DataView(centralHeader.buffer);
      centralView.setUint32(0, 0x02014b50, true);
      centralView.setUint16(4, 20, true);
      centralView.setUint16(6, 20, true);
      centralView.setUint16(8, 0, true);
      centralView.setUint16(10, 0, true);
      centralView.setUint16(12, 0, true);
      centralView.setUint16(14, 0, true);
      centralView.setUint32(16, checksum, true);
      centralView.setUint32(20, data.length, true);
      centralView.setUint32(24, data.length, true);
      centralView.setUint16(28, nameBytes.length, true);
      centralView.setUint16(30, 0, true);
      centralView.setUint16(32, 0, true);
      centralView.setUint16(34, 0, true);
      centralView.setUint16(36, 0, true);
      centralView.setUint32(38, 0, true);
      centralView.setUint32(42, localOffset, true);
      centralHeader.set(nameBytes, 46);
      centralParts.push(centralHeader);
      centralSize += centralHeader.length;

      localOffset += localHeader.length + data.length;
    }

    const centralOffset = localOffset;
    const eocd = new Uint8Array(22);
    const eocdView = new DataView(eocd.buffer);
    eocdView.setUint32(0, 0x06054b50, true);
    eocdView.setUint16(4, 0, true);
    eocdView.setUint16(6, 0, true);
    eocdView.setUint16(8, entries.length, true);
    eocdView.setUint16(10, entries.length, true);
    eocdView.setUint32(12, centralSize, true);
    eocdView.setUint32(16, centralOffset, true);
    eocdView.setUint16(20, 0, true);

    return new Blob([...localParts, ...centralParts, eocd], { type: "application/zip" });
  }

  function parseZipArchive(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    const view = new DataView(arrayBuffer);
    const eocdOffset = findEocdOffset(bytes);
    if (eocdOffset === -1) {
      throw new Error("Invalid ZIP: end-of-central-directory record not found.");
    }

    const totalEntries = view.getUint16(eocdOffset + 10, true);
    const centralDirectorySize = view.getUint32(eocdOffset + 12, true);
    const centralDirectoryOffset = view.getUint32(eocdOffset + 16, true);

    if (
      totalEntries === 0xffff ||
      centralDirectorySize === 0xffffffff ||
      centralDirectoryOffset === 0xffffffff
    ) {
      throw new Error("ZIP64 archives are not supported yet.");
    }

    const end = centralDirectoryOffset + centralDirectorySize;
    if (end > bytes.length) {
      throw new Error("Invalid ZIP: central directory outside file bounds.");
    }

    const decoder = new TextDecoder("utf-8");
    const entries = [];
    let offset = centralDirectoryOffset;

    for (let i = 0; i < totalEntries; i += 1) {
      if (view.getUint32(offset, true) !== 0x02014b50) {
        throw new Error("Invalid ZIP: bad central directory header.");
      }

      const flags = view.getUint16(offset + 8, true);
      const compressionMethod = view.getUint16(offset + 10, true);
      const compressedSize = view.getUint32(offset + 20, true);
      const uncompressedSize = view.getUint32(offset + 24, true);
      const fileNameLength = view.getUint16(offset + 28, true);
      const extraLength = view.getUint16(offset + 30, true);
      const commentLength = view.getUint16(offset + 32, true);
      const localHeaderOffset = view.getUint32(offset + 42, true);

      const nameStart = offset + 46;
      const nameEnd = nameStart + fileNameLength;
      const nameBytes = bytes.subarray(nameStart, nameEnd);
      const path = normalizePath(decoder.decode(nameBytes));

      offset = nameEnd + extraLength + commentLength;

      if (!path || path.endsWith("/")) {
        continue;
      }

      entries.push({
        path,
        flags,
        compressionMethod,
        compressedSize,
        uncompressedSize,
        localHeaderOffset
      });
    }

    return { bytes, view, entries };
  }

  function getCompressedEntrySlice(zip, entry) {
    const localOffset = entry.localHeaderOffset;
    if (zip.view.getUint32(localOffset, true) !== 0x04034b50) {
      throw new Error("Invalid ZIP: bad local header for " + entry.path);
    }

    const fileNameLength = zip.view.getUint16(localOffset + 26, true);
    const extraLength = zip.view.getUint16(localOffset + 28, true);
    const dataOffset = localOffset + 30 + fileNameLength + extraLength;
    const dataEnd = dataOffset + entry.compressedSize;

    if (dataEnd > zip.bytes.length) {
      throw new Error("Invalid ZIP: data overflow for " + entry.path);
    }

    return zip.bytes.subarray(dataOffset, dataEnd);
  }

  async function inflateDeflateRaw(data) {
    if (!("DecompressionStream" in window)) {
      throw new Error("This browser does not support ZIP extraction in file:// mode (missing DecompressionStream).");
    }
    const stream = new Blob([data]).stream().pipeThrough(new DecompressionStream("deflate-raw"));
    const buffer = await new Response(stream).arrayBuffer();
    return new Uint8Array(buffer);
  }

  async function extractEntryBytes(zip, entry) {
    if (entry.flags & 0x1) {
      throw new Error("Encrypted ZIP entries are not supported: " + entry.path);
    }

    const compressed = getCompressedEntrySlice(zip, entry);

    if (entry.compressionMethod === 0) {
      return compressed.slice();
    }
    if (entry.compressionMethod === 8) {
      const decompressed = await inflateDeflateRaw(compressed);
      return decompressed;
    }

    throw new Error(
      "Unsupported ZIP compression method " + entry.compressionMethod + " for " + entry.path
    );
  }

  function entryDepth(path) {
    return normalizePath(path).split("/").length - 1;
  }

  function scoreEntryPath(path) {
    const normalized = normalizePath(path).toLowerCase();
    const base = normalized.split("/").pop() || normalized;
    let score = 0;

    if (base === "play.html") {
      score += 340;
    } else if (base === "index.html") {
      score += 320;
    } else if (base === "game.html") {
      score += 260;
    } else if (base === "main.html") {
      score += 230;
    } else if (base === "start.html") {
      score += 220;
    } else if (base === "launch.html") {
      score += 200;
    } else {
      score += 120;
    }

    if (normalized === "play.html" || normalized === "index.html") {
      score += 70;
    }

    if (/\/(assets|scripts|js|vendor|lib|dist|build|docs|examples|tests)\//.test(normalized)) {
      score -= 95;
    }
    if (/(loader|preload|preloader|unityloader|template|embed|frame|privacy|terms)/.test(base)) {
      score -= 120;
    }

    score -= entryDepth(normalized) * 3;
    return score;
  }

  function chooseBestEntryPath(entries, preferredPath) {
    if (preferredPath && entries.includes(preferredPath)) {
      return preferredPath;
    }
    const sorted = entries.slice().sort((a, b) => {
      const scoreDiff = scoreEntryPath(b) - scoreEntryPath(a);
      if (scoreDiff !== 0) {
        return scoreDiff;
      }
      const depthDiff = entryDepth(a) - entryDepth(b);
      if (depthDiff !== 0) {
        return depthDiff;
      }
      return a.localeCompare(b);
    });
    return sorted[0] || "";
  }

  function setEmptyEntryState(message) {
    entrySelect.innerHTML = "";
    const option = document.createElement("option");
    option.value = "";
    option.textContent = message;
    entrySelect.append(option);
    entrySelect.disabled = true;
  }

  function populateEntryOptions(entryPaths, preferredPath) {
    const entries = (entryPaths || []).slice().sort((a, b) => a.localeCompare(b));
    if (!entries.length) {
      setEmptyEntryState("No .html startup file found");
      return "";
    }

    entrySelect.disabled = false;
    entrySelect.innerHTML = "";
    for (const path of entries) {
      const option = document.createElement("option");
      option.value = path;
      option.textContent = path;
      entrySelect.append(option);
    }

    const selected = chooseBestEntryPath(entries, preferredPath);
    entrySelect.value = selected;
    return selected;
  }

  function renderGameOptions(selectedId) {
    gameSelect.innerHTML = "";
    const games = sortedGames();

    if (!games.length) {
      const option = document.createElement("option");
      option.value = "";
      option.textContent = "No saved games yet";
      gameSelect.append(option);
      gameSelect.disabled = true;
      renderGameCards();
      return "";
    }

    gameSelect.disabled = false;
    for (const game of games) {
      const option = document.createElement("option");
      option.value = game.id;
      option.textContent = game.name;
      gameSelect.append(option);
    }

    const chosen = selectedId && state.gamesById.has(selectedId)
      ? selectedId
      : games[0].id;
    gameSelect.value = chosen;
    renderGameCards();
    return chosen;
  }

  async function refreshStorageSummary() {
    const games = Array.from(state.gamesById.values());
    const totalBytes = games.reduce((sum, game) => sum + (Number(game.totalBytes) || 0), 0);

    libraryCount.textContent = String(games.length);
    libraryBytes.textContent = formatBytes(totalBytes);

    if (navigator.storage && navigator.storage.estimate) {
      try {
        const estimate = await navigator.storage.estimate();
        const hasUsage = estimate && typeof estimate.usage === "number";
        const hasQuota = estimate && typeof estimate.quota === "number";
        if (hasUsage && hasQuota) {
          quotaUsage.textContent = formatBytes(estimate.usage) + " / " + formatBytes(estimate.quota);
        } else {
          quotaUsage.textContent = "Unavailable";
        }
      } catch {
        quotaUsage.textContent = "Unavailable";
      }
    } else {
      quotaUsage.textContent = "Unsupported";
    }
  }

  function updateSelectedGameInfo(game) {
    if (!game) {
      gameMeta.textContent = "No saved game selected.";
      selectedImported.textContent = "-";
      selectedFiles.textContent = "-";
      selectedSize.textContent = "-";
      selectedSource.textContent = "-";
      selectedEntry.textContent = "-";
      setEmptyEntryState("Select a saved game");
      return;
    }

    gameMeta.textContent = game.name || "Selected game";
    selectedImported.textContent = formatDate(game.importedAt);
    selectedFiles.textContent = String(game.fileCount || 0);
    selectedSize.textContent = formatBytes(game.totalBytes || 0);
    selectedSource.textContent = game.zipName || "unknown";

    const chosenEntry = populateEntryOptions(game.htmlEntries || [], game.entryPath || "");
    selectedEntry.textContent = chosenEntry || game.entryPath || "-";
    if (chosenEntry && chosenEntry !== game.entryPath) {
      game.entryPath = chosenEntry;
      state.gamesById.set(game.id, game);
      putGame(game).catch((error) => {
        console.error(error);
        log("Could not persist startup file for " + game.name + ".", "error");
      });
    }
  }

  async function loadLibrary(preferredGameId) {
    const games = await getAllGames();
    state.gamesById = new Map(games.map((game) => [game.id, game]));

    const selectedId = renderGameOptions(preferredGameId || state.selectedGameId);
    state.selectedGameId = selectedId || null;

    if (state.selectedGameId) {
      await putSetting(SETTING_SELECTED_GAME, state.selectedGameId);
    }

    updateSelectedGameInfo(state.selectedGameId ? state.gamesById.get(state.selectedGameId) : null);
    await refreshStorageSummary();
  }

  async function pickZipFile() {
    if (window.showOpenFilePicker) {
      try {
        const handles = await window.showOpenFilePicker({
          multiple: false,
          excludeAcceptAllOption: false,
          types: [
            {
              description: "ZIP archives",
              accept: {
                "application/zip": [".zip"],
                "application/x-zip-compressed": [".zip"]
              }
            }
          ]
        });
        if (!handles.length) {
          return;
        }
        const file = await handles[0].getFile();
        await importZipFile(file);
      } catch (error) {
        if (error && error.name === "AbortError") {
          log("ZIP import canceled.");
          return;
        }
        console.error(error);
        log("Import failed: " + (error.message || String(error)), "error");
      }
      return;
    }

    zipInput.value = "";
    zipInput.click();
  }

  async function importZipFile(file) {
    if (!file) {
      return;
    }
    if (!/\.zip$/i.test(file.name)) {
      log("Please choose a .zip file.", "error");
      return;
    }

    setActionButtonsDisabled(true);

    const gameId = makeId();

    try {
      setWorkProgress("Reading ZIP", 0, 0);
      log("Reading ZIP: " + file.name);
      const zipBuffer = await file.arrayBuffer();
      const zip = parseZipArchive(zipBuffer);

      if (!zip.entries.length) {
        throw new Error("ZIP contains no importable files.");
      }

      const htmlEntries = zip.entries
        .map((entry) => entry.path)
        .filter((path) => /\.html?$/i.test(path))
        .sort((a, b) => a.localeCompare(b));

      const gameRecord = {
        id: gameId,
        name: deriveGameName(file.name),
        zipName: file.name,
        importedAt: Date.now(),
        fileCount: zip.entries.length,
        totalBytes: 0,
        htmlEntries,
        entryPath: chooseBestEntryPath(htmlEntries, "")
      };

      let processed = 0;
      let totalBytes = 0;
      setWorkProgress("Importing game files", 0, zip.entries.length);

      for (const entry of zip.entries) {
        const entryBytes = await extractEntryBytes(zip, entry);
        const blob = new Blob([entryBytes], { type: mimeFromPath(entry.path) });
        totalBytes += blob.size;

        await putFileRecord({
          gameId,
          path: entry.path,
          size: blob.size,
          type: blob.type,
          blob
        });

        processed += 1;
        if (processed % 20 === 0 || processed === zip.entries.length) {
          setWorkProgress("Importing game files", processed, zip.entries.length);
        }
        if (processed % 40 === 0 || processed === zip.entries.length) {
          log("Imported " + processed + "/" + zip.entries.length + " files...");
        }
      }

      gameRecord.totalBytes = totalBytes;
      await putGame(gameRecord);
      state.selectedGameId = gameId;
      await putSetting(SETTING_SELECTED_GAME, gameId);

      await loadLibrary(gameId);
      log("Saved game \"" + gameRecord.name + "\" (" + formatBytes(totalBytes) + ")");
    } catch (error) {
      console.error(error);
      log("Import failed: " + (error.message || String(error)), "error");
      try {
        await deleteFilesByGameId(gameId);
        await deleteGameRecord(gameId);
      } catch {
        // best effort cleanup
      }
    } finally {
      setActionButtonsDisabled(false);
      clearWorkProgress();
    }
  }

  function clearObjectUrls() {
    let host = window;
    try {
      if (
        state.objectUrlHost &&
        state.objectUrlHost.URL &&
        typeof state.objectUrlHost.URL.createObjectURL === "function" &&
        typeof state.objectUrlHost.URL.revokeObjectURL === "function"
      ) {
        host = state.objectUrlHost;
      }
    } catch {
      host = window;
    }
    for (const url of state.objectUrls.values()) {
      try {
        host.URL.revokeObjectURL(url);
      } catch {
        URL.revokeObjectURL(url);
      }
    }
    state.objectUrls.clear();
    state.objectUrlHost = window;
  }

  function rewriteCssText(cssText, cssPath) {
    if (typeof cssText !== "string" || !cssText) {
      return cssText;
    }
    const baseHref = toVirtualUrl(cssPath);
    return cssText.replace(/url\(\s*(['"]?)([^"')]+)\1\s*\)/gi, (full, quote, urlPath) => {
      const raw = String(urlPath || "").trim();
      if (!raw) {
        return full;
      }
      const lower = raw.toLowerCase();
      if (
        lower.startsWith("data:") ||
        lower.startsWith("blob:") ||
        lower.startsWith("about:")
      ) {
        return full;
      }
      const mapped = requestToObjectUrl(raw, baseHref);
      if (!mapped) {
        return full;
      }
      const wrapped = quote || "\"";
      return "url(" + wrapped + mapped + wrapped + ")";
    });
  }

  function bytesToBase64(bytes) {
    if (!(bytes instanceof Uint8Array)) {
      return "";
    }
    const chunkSize = 0x8000;
    let out = "";
    for (let offset = 0; offset < bytes.length; offset += chunkSize) {
      const slice = bytes.subarray(offset, Math.min(offset + chunkSize, bytes.length));
      out += String.fromCharCode.apply(null, slice);
    }
    return btoa(out);
  }

  function textToBase64(text) {
    return btoa(unescape(encodeURIComponent(String(text || ""))));
  }

  function base64ToBytes(base64Text) {
    const base64 = String(base64Text || "");
    const binary = atob(base64);
    const out = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i += 1) {
      out[i] = binary.charCodeAt(i);
    }
    return out;
  }

  function encodeUtf8(text) {
    return new TextEncoder().encode(String(text || ""));
  }

  function decodeUtf8(bytes) {
    return new TextDecoder("utf-8").decode(bytes);
  }

  function concatUint8Arrays(chunks) {
    let totalLength = 0;
    for (const chunk of chunks) {
      totalLength += chunk.length;
    }
    const out = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      out.set(chunk, offset);
      offset += chunk.length;
    }
    return out;
  }

  function extensionFromMime(mime) {
    const type = String(mime || "").toLowerCase();
    if (type === "image/png") return ".png";
    if (type === "image/jpeg") return ".jpg";
    if (type === "image/webp") return ".webp";
    if (type === "image/gif") return ".gif";
    return "";
  }

  function parseDataUrlToBytes(dataUrl) {
    const text = String(dataUrl || "");
    const match = text.match(/^data:([^;,]+)?(?:;charset=[^;,]+)?(?:;(base64))?,([\s\S]*)$/i);
    if (!match) {
      return null;
    }
    const mime = (match[1] || "application/octet-stream").toLowerCase();
    const isBase64 = Boolean(match[2]);
    const payload = match[3] || "";
    if (isBase64) {
      return {
        mime,
        bytes: base64ToBytes(payload)
      };
    }
    const decoded = decodeURIComponent(payload);
    const out = new Uint8Array(decoded.length);
    for (let i = 0; i < decoded.length; i += 1) {
      out[i] = decoded.charCodeAt(i);
    }
    return { mime, bytes: out };
  }

  function setActionButtonsDisabled(disabled) {
    const value = Boolean(disabled);
    importZipButton.disabled = value;
    launchButton.disabled = value;
    deleteGameButton.disabled = value;
    exportAllGamesButton.disabled = value;
    importAllGamesButton.disabled = value;
  }

  function setWorkProgress(label, current, total) {
    if (!workProgress || !workProgressLabel || !workProgressCircle || !workProgressValue) {
      return;
    }
    const text = String(label || "Working...");
    const hasTotal = Number.isFinite(total) && total > 0;
    const safeCurrent = Number.isFinite(current) ? Math.max(0, current) : 0;
    const safeTotal = hasTotal ? Math.max(1, total) : 0;
    if (hasTotal) {
      const pct = Math.max(0, Math.min(100, (safeCurrent / safeTotal) * 100));
      workProgress.classList.remove("indeterminate");
      workProgressLabel.textContent = text + " (" + Math.min(safeCurrent, safeTotal) + "/" + safeTotal + ")";
      workProgressCircle.style.setProperty("--progress-pct", pct.toFixed(1));
      workProgressValue.textContent = Math.round(pct) + "%";
      return;
    }
    workProgress.classList.add("indeterminate");
    workProgressLabel.textContent = text;
    workProgressCircle.style.setProperty("--progress-pct", "25");
    workProgressValue.textContent = "...";
  }

  function clearWorkProgress() {
    if (!workProgress || !workProgressLabel || !workProgressCircle || !workProgressValue) {
      return;
    }
    workProgress.classList.remove("indeterminate");
    workProgressLabel.textContent = "Idle...";
    workProgressCircle.style.setProperty("--progress-pct", "0");
    workProgressValue.textContent = "0%";
  }
  function findReferencedWasmPath(scriptText, scriptPath, recordsByPath) {
    if (typeof scriptText !== "string" || !scriptText) {
      return null;
    }
    const baseHref = toVirtualUrl(scriptPath);
    const candidates = [];
    const refMatches = scriptText.matchAll(/(["'])([^"'\\]*?\.wasm(?:\.[^"'\\\/?#]+)?)\1/g);
    for (const match of refMatches) {
      const rawRef = match[2];
      if (rawRef) {
        candidates.push(rawRef);
      }
    }
    candidates.push(scriptPath.replace(/\.wasm\.js$/i, ".wasm.wasm"));
    candidates.push(scriptPath.replace(/\.js$/i, ".wasm"));
    candidates.push(scriptPath.replace(/\.js$/i, ".wasm.wasm"));

    for (const rawRef of candidates) {
      const resolvedFromBase = resolveToPath(rawRef, baseHref);
      if (resolvedFromBase && recordsByPath.has(resolvedFromBase)) {
        return { rawRef, path: resolvedFromBase };
      }
      const resolvedFromRoot = resolveToPath(rawRef, VFS_ORIGIN);
      if (resolvedFromRoot && recordsByPath.has(resolvedFromRoot)) {
        return { rawRef, path: resolvedFromRoot };
      }
      if (resolvedFromRoot) {
        const basePath = resolveToPath(baseHref, VFS_ORIGIN);
        let probeDir = basePath ? dirnamePath(basePath) : "";
        while (probeDir) {
          const candidate = normalizePath(probeDir + "/" + resolvedFromRoot);
          if (recordsByPath.has(candidate)) {
            return { rawRef, path: candidate };
          }
          probeDir = dirnamePath(probeDir);
        }
      }
    }
    return null;
  }

  function replaceFirstWasmRef(scriptText, rawRef, dataUrl) {
    if (typeof scriptText !== "string") {
      return scriptText;
    }
    const replacement = JSON.stringify(dataUrl);
    const doubleQuoted = JSON.stringify(rawRef);
    if (scriptText.includes(doubleQuoted)) {
      return scriptText.replace(doubleQuoted, replacement);
    }
    const singleQuoted = "'" + String(rawRef).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
    if (scriptText.includes(singleQuoted)) {
      return scriptText.replace(singleQuoted, replacement);
    }
    return scriptText;
  }

  function shouldInlineWasmForScript(scriptPath, scriptText) {
    const path = String(scriptPath || "");
    const text = String(scriptText || "");
    return /(?:^|\/)ammo\.wasm\.js$/i.test(path) || /ammo\.wasm\.wasm/i.test(text);
  }

  async function patchEmscriptenWasmScriptText(scriptText, scriptPath, recordsByPath, dataUrlCache) {
    if (typeof scriptText !== "string" || !scriptText || !scriptPath) {
      return scriptText;
    }
    if (!shouldInlineWasmForScript(scriptPath, scriptText)) {
      return scriptText;
    }
    const wasmRef = findReferencedWasmPath(scriptText, scriptPath, recordsByPath);
    if (!wasmRef) {
      return scriptText;
    }

    const wasmPath = wasmRef.path;
    const wasmRecord = recordsByPath.get(wasmPath);
    if (!wasmRecord) {
      return scriptText;
    }

    let wasmDataUrl = dataUrlCache.get(wasmPath) || "";
    if (!wasmDataUrl) {
      const wasmBytes = new Uint8Array(await wasmRecord.blob.arrayBuffer());
      wasmDataUrl = "data:application/wasm;base64," + bytesToBase64(wasmBytes);
      dataUrlCache.set(wasmPath, wasmDataUrl);
    }

    const wasmRefRaw = String(wasmRef.rawRef || "");
    const marker = "if(!F(O=" + JSON.stringify(wasmRefRaw) + ")){var L=O;O=n.locateFile?n.locateFile(L,u):u+L}";
    const forcedWasmAssign = "O=" + JSON.stringify(wasmDataUrl) + ";";
    if (scriptText.includes(marker)) {
      return scriptText.replace(marker, forcedWasmAssign);
    }
    return replaceFirstWasmRef(scriptText, wasmRefRaw, wasmDataUrl);
  }

  async function buildEmscriptenInlineDataUrl(scriptPath, recordsByPath, dataUrlCache) {
    if (!scriptPath) {
      return null;
    }
    const scriptRecord = recordsByPath.get(scriptPath);
    if (!scriptRecord) {
      return null;
    }

    const scriptText = await scriptRecord.blob.text();
    if (!shouldInlineWasmForScript(scriptPath, scriptText)) {
      return null;
    }
    const wasmRef = findReferencedWasmPath(scriptText, scriptPath, recordsByPath);
    if (!wasmRef) {
      return null;
    }

    const wasmPath = wasmRef.path;
    const wasmRecord = recordsByPath.get(wasmPath);
    if (!wasmRecord) {
      return null;
    }

    const cacheKey = "__ems_inline__:" + scriptPath + ":" + wasmPath;
    if (dataUrlCache.has(cacheKey)) {
      return dataUrlCache.get(cacheKey);
    }

    let wasmDataUrl = dataUrlCache.get(wasmPath) || "";
    if (!wasmDataUrl) {
      const wasmBytes = new Uint8Array(await wasmRecord.blob.arrayBuffer());
      wasmDataUrl = "data:application/wasm;base64," + bytesToBase64(wasmBytes);
      dataUrlCache.set(wasmPath, wasmDataUrl);
    }

    const wasmRefRaw = String(wasmRef.rawRef || "");
    const patchedScriptText = await patchEmscriptenWasmScriptText(
      scriptText,
      scriptPath,
      recordsByPath,
      dataUrlCache
    );

    const wasmBasename = String(wasmPath).split("/").pop() || "";
    const loaderKeys = [wasmRefRaw, wasmBasename].filter((value, index, arr) => value && arr.indexOf(value) === index);
    const prelude =
      "(function(){var __loaderWasmUrl=" + JSON.stringify(wasmDataUrl) + ";" +
      "var __loaderWasmKeys=" + JSON.stringify(loaderKeys) + ";" +
      "function __isLoaderWasmPath(path){if(typeof path!=='string'){return false;}for(var i=0;i<__loaderWasmKeys.length;i++){if(path===__loaderWasmKeys[i]){return true;}}return false;}" +
      "self.Module=self.Module||{};" +
      "var __prevLocate=self.Module.locateFile;" +
      "self.Module.locateFile=function(path,prefix){" +
      "if(__isLoaderWasmPath(path)){return __loaderWasmUrl;}" +
      "if(typeof __prevLocate==='function'){return __prevLocate(path,prefix);}" +
      "return (prefix||'')+path;};" +
      "if(typeof self.fetch==='function'){var __prevFetch=self.fetch.bind(self);self.fetch=function(input,init){if(__isLoaderWasmPath(input)){input=__loaderWasmUrl;}return __prevFetch(input,init);};}" +
      "if(typeof XMLHttpRequest==='function'){var __prevOpen=XMLHttpRequest.prototype.open;XMLHttpRequest.prototype.open=function(method,url){if(__isLoaderWasmPath(url)){url=__loaderWasmUrl;}return __prevOpen.apply(this,[method,url].concat(Array.prototype.slice.call(arguments,2)));};}" +
      "})();\n";
    const dataUrl = "data:application/javascript;base64," + textToBase64(prelude + patchedScriptText);
    dataUrlCache.set(cacheKey, dataUrl);
    return dataUrl;
  }

  async function buildInlineScriptDataUrl(scriptPath, recordsByPath, dataUrlCache) {
    if (!scriptPath) {
      return null;
    }
    const cacheKey = "__js_inline__:" + scriptPath;
    if (dataUrlCache.has(cacheKey)) {
      return dataUrlCache.get(cacheKey);
    }
    const scriptRecord = recordsByPath.get(scriptPath);
    if (!scriptRecord) {
      return null;
    }
    const scriptText = await scriptRecord.blob.text();
    const dataUrl = "data:application/javascript;base64," + textToBase64(scriptText);
    dataUrlCache.set(cacheKey, dataUrl);
    return dataUrl;
  }

  async function rewriteImportScriptsText(scriptText, scriptPath, recordsByPath, dataUrlCache) {
    if (typeof scriptText !== "string" || !scriptText) {
      return scriptText;
    }
    const baseHref = toVirtualUrl(scriptPath);
    const matches = Array.from(scriptText.matchAll(/importScripts\(([^)]*)\)/g));
    if (!matches.length) {
      return scriptText;
    }

    let rewritten = "";
    let cursor = 0;
    for (const match of matches) {
      const full = match[0];
      const argsText = match[1];
      const start = match.index || 0;
      const end = start + full.length;
      rewritten += scriptText.slice(cursor, start);
      if (!argsText || typeof argsText !== "string") {
        rewritten += full;
        cursor = end;
        continue;
      }

      let argsOut = "";
      let argCursor = 0;
      const argMatches = Array.from(argsText.matchAll(/(['"])([^"'\\]+)\1/g));
      for (const argMatch of argMatches) {
        const segment = argMatch[0];
        const quote = argMatch[1];
        const rawPath = argMatch[2];
        const segStart = argMatch.index || 0;
        const segEnd = segStart + segment.length;
        argsOut += argsText.slice(argCursor, segStart);

        const resolvedPath = resolveToPath(rawPath, baseHref);
        let mapped = requestToObjectUrl(rawPath, baseHref);
        if (resolvedPath && /\.(?:js|mjs|cjs)$/i.test(resolvedPath)) {
          const emscriptenInlineUrl = await buildEmscriptenInlineDataUrl(
            resolvedPath,
            recordsByPath,
            dataUrlCache
          );
          if (emscriptenInlineUrl) {
            mapped = emscriptenInlineUrl;
          } else {
            const inlineScriptUrl = await buildInlineScriptDataUrl(
              resolvedPath,
              recordsByPath,
              dataUrlCache
            );
            if (inlineScriptUrl) {
              mapped = inlineScriptUrl;
            }
          }
        }

        if (!mapped) {
          argsOut += segment;
        } else {
          argsOut += quote + mapped + quote;
        }
        argCursor = segEnd;
      }
      argsOut += argsText.slice(argCursor);
      rewritten += "importScripts(" + argsOut + ")";
      cursor = end;
    }
    rewritten += scriptText.slice(cursor);
    return rewritten;
  }

  function isUnityWebConfigObject(value) {
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      return false;
    }
    if (typeof value.dataUrl !== "string") {
      return false;
    }
    return (
      typeof value.asmCodeUrl === "string" ||
      typeof value.wasmCodeUrl === "string" ||
      typeof value.asmFrameworkUrl === "string" ||
      typeof value.frameworkUrl === "string"
    );
  }

  function rewriteUnityWebConfigText(jsonText, path) {
    if (!UNITY_GPU_SAFE_MODE || typeof jsonText !== "string" || !/\.json$/i.test(path)) {
      return { text: jsonText, changed: false };
    }

    let config;
    try {
      config = JSON.parse(jsonText);
    } catch {
      return { text: jsonText, changed: false };
    }

    if (!isUnityWebConfigObject(config)) {
      return { text: jsonText, changed: false };
    }

    let changed = false;
    if (UNITY_FORCE_WEBGL1) {
      const currentApis = Array.isArray(config.graphicsAPI)
        ? config.graphicsAPI.map((api) => String(api))
        : [];
      const supportsWebGL1 = currentApis.some((api) => api === "WebGL 1.0");
      if (supportsWebGL1 || !currentApis.length) {
        const nextApis = ["WebGL 1.0"];
        if (
          currentApis.length !== nextApis.length ||
          currentApis.some((api, index) => api !== nextApis[index])
        ) {
          config.graphicsAPI = nextApis;
          changed = true;
        }
      }
    }

    const nextContextAttrs = {
      ...(config.webglContextAttributes && typeof config.webglContextAttributes === "object"
        ? config.webglContextAttributes
        : {})
    };
    const requiredAttrs = {
      antialias: false,
      alpha: false,
      stencil: false,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false,
      desynchronized: true,
      powerPreference: "low-power"
    };
    for (const [key, value] of Object.entries(requiredAttrs)) {
      if (nextContextAttrs[key] !== value) {
        nextContextAttrs[key] = value;
        changed = true;
      }
    }
    config.webglContextAttributes = nextContextAttrs;

    const forcedDpr = Number(UNITY_CLAMP_DEVICE_PIXEL_RATIO);
    if (forcedDpr > 0 && Number(config.devicePixelRatio) !== forcedDpr) {
      config.devicePixelRatio = forcedDpr;
      changed = true;
    }

    if (!changed) {
      return { text: jsonText, changed: false };
    }

    return {
      text: JSON.stringify(config),
      changed: true
    };
  }

  async function buildObjectUrlCacheFromRecords(records, hostWindow) {
    let host = window;
    try {
      if (
        hostWindow &&
        hostWindow.URL &&
        typeof hostWindow.URL.createObjectURL === "function" &&
        typeof hostWindow.URL.revokeObjectURL === "function"
      ) {
        host = hostWindow;
      }
    } catch {
      host = window;
    }
    clearObjectUrls();
    state.objectUrlHost = host;
    const recordsByPath = new Map(records.map((record) => [record.path, record]));
    const dataUrlCache = new Map();

    for (const record of records) {
      state.objectUrls.set(record.path, host.URL.createObjectURL(record.blob));
    }

    let rewrittenCssCount = 0;
    let rewrittenUnityConfigCount = 0;
    for (const record of records) {
      try {
        let rewrittenText = "";
        let rewrittenMime = "";

        if (/\.css$/i.test(record.path)) {
          const originalText = await record.blob.text();
          rewrittenText = rewriteCssText(originalText, record.path);
          if (rewrittenText === originalText) {
            continue;
          }
          rewrittenMime = "text/css";
          rewrittenCssCount += 1;
        } else if (/\.json$/i.test(record.path)) {
          const originalText = await record.blob.text();
          const rewrite = rewriteUnityWebConfigText(originalText, record.path);
          if (!rewrite.changed) {
            continue;
          }
          rewrittenText = rewrite.text;
          rewrittenMime = "application/json";
          rewrittenUnityConfigCount += 1;
        } else if (/\.(?:js|mjs|cjs)$/i.test(record.path)) {
          const originalText = await record.blob.text();
          const emsPatchedText = await patchEmscriptenWasmScriptText(
            originalText,
            record.path,
            recordsByPath,
            dataUrlCache
          );
          rewrittenText = await rewriteImportScriptsText(
            emsPatchedText,
            record.path,
            recordsByPath,
            dataUrlCache
          );
          if (rewrittenText === originalText) {
            continue;
          }
          rewrittenMime = "application/javascript";
        } else {
          continue;
        }

        const oldUrl = state.objectUrls.get(record.path);
        const rewrittenBlob = new Blob([rewrittenText], {
          type: rewrittenMime || record.type || mimeFromPath(record.path)
        });
        record.blob = rewrittenBlob;
        record.size = rewrittenBlob.size;
        record.type = rewrittenBlob.type;
        const rewrittenUrl = host.URL.createObjectURL(rewrittenBlob);
        state.objectUrls.set(record.path, rewrittenUrl);
        if (oldUrl) {
          host.URL.revokeObjectURL(oldUrl);
        }
      } catch (error) {
        console.error(error);
        log("Failed to rewrite asset " + record.path + ".", "error");
      }
    }

    if (rewrittenCssCount > 0) {
      log("Rewrote " + rewrittenCssCount + " stylesheet(s) for local asset URLs.");
    }
    if (rewrittenUnityConfigCount > 0) {
      log("Applied Unity GPU-safe config to " + rewrittenUnityConfigCount + " Web config file(s).");
    }
  }

  function rewriteSrcSet(value, baseHref) {
    if (typeof value !== "string") {
      return value;
    }
    let changed = false;
    const items = value.split(",");
    const rewritten = items.map((item) => {
      const trimmed = item.trim();
      if (!trimmed) {
        return trimmed;
      }
      const match = trimmed.match(/^(\S+)(\s+.*)?$/);
      if (!match) {
        return trimmed;
      }
      const mapped = requestToObjectUrl(match[1], baseHref);
      if (!mapped) {
        return trimmed;
      }
      changed = true;
      return mapped + (match[2] || "");
    });
    return changed ? rewritten.join(", ") : value;
  }

  function injectRuntimeBridge(documentNode) {
    const script = documentNode.createElement("script");
    script.textContent = `
(function () {
  var getResolverHost = function () {
    try {
      if (window.parent && window.parent !== window && typeof window.parent.__loaderResolve === "function") {
        return window.parent;
      }
    } catch (_error) {
      // continue to opener fallback
    }
    try {
      if (window.opener && !window.opener.closed && typeof window.opener.__loaderResolve === "function") {
        return window.opener;
      }
    } catch (_error) {
      // no resolver host available
    }
    return null;
  };

  var getBaseHref = function () {
    var baseEl = document.querySelector("base[href]");
    if (baseEl && baseEl.href) {
      return baseEl.href;
    }
    return document.baseURI;
  };

  var resolver = function (value) {
    try {
      var host = getResolverHost();
      if (!host) return null;
      return host.__loaderResolve(String(value), getBaseHref());
    } catch (_error) {
      return null;
    }
  };

  var normalizeVirtualDataUrl = function (value) {
    var text = String(value || "");
    var marker = "data:application/";
    var markerIndex = text.indexOf(marker);
    if (markerIndex > 0) {
      return text.slice(markerIndex);
    }
    return value;
  };

  var mapValue = function (value) {
    var normalized = normalizeVirtualDataUrl(value);
    var mapped = resolver(normalized);
    return mapped || normalized;
  };

  var UNITY_GPU_SAFE_MODE = true;
  var UNITY_FORCE_WEBGL1 = false;
  var UNITY_CLAMP_DEVICE_PIXEL_RATIO = 1;

  var mapSrcSet = function (value) {
    if (typeof value !== "string") return value;
    var changed = false;
    var rewritten = value.split(",").map(function (item) {
      var trimmed = item.trim();
      if (!trimmed) return trimmed;
      var match = trimmed.match(/^(\\S+)(\\s+.*)?$/);
      if (!match) return trimmed;
      var mapped = resolver(match[1]);
      if (!mapped) return trimmed;
      changed = true;
      return mapped + (match[2] || "");
    });
    return changed ? rewritten.join(", ") : value;
  };

  var rewriteCssRuntime = function (value) {
    if (typeof value !== "string" || !value) return value;
    return value.replace(
      /url\\(\\s*(['"]?)([^"')]+)\\1\\s*\\)/gi,
      function (full, quote, urlPath) {
        var mapped = resolver(urlPath);
        if (!mapped) return full;
        var wrapped = quote || '"';
        return "url(" + wrapped + mapped + wrapped + ")";
      }
    );
  };

  var remapElementTree = function (root) {
    if (!root) return;
    var targetAttrs = [
      "src",
      "href",
      "data",
      "poster",
      "action"
    ];
    var all = [];
    if (root.nodeType === 1) {
      all.push(root);
    }
    if (root.querySelectorAll) {
      var nested = root.querySelectorAll("*");
      for (var n = 0; n < nested.length; n++) {
        all.push(nested[n]);
      }
    }
    for (var i = 0; i < all.length; i++) {
      var el = all[i];
      for (var a = 0; a < targetAttrs.length; a++) {
        var attr = targetAttrs[a];
        if (!el.hasAttribute(attr)) continue;
        var current = el.getAttribute(attr);
        var mapped = mapValue(current);
        if (mapped !== current) {
          el.setAttribute(attr, mapped);
        }
      }
      if (el.hasAttribute("srcset")) {
        var currentSrcSet = el.getAttribute("srcset");
        var mappedSrcSet = mapSrcSet(currentSrcSet);
        if (mappedSrcSet !== currentSrcSet) {
          el.setAttribute("srcset", mappedSrcSet);
        }
      }
      if (el.tagName === "STYLE") {
        var cssText = el.textContent || "";
        var cssMapped = rewriteCssRuntime(cssText);
        if (cssMapped !== cssText) {
          el.textContent = cssMapped;
        }
      }
    }
  };

  var patchProperty = function (ctor, prop, mapper) {
    if (!ctor || !ctor.prototype) return;
    var desc = Object.getOwnPropertyDescriptor(ctor.prototype, prop);
    if (!desc || typeof desc.get !== "function" || typeof desc.set !== "function") return;
    var convert = mapper || mapValue;
    Object.defineProperty(ctor.prototype, prop, {
      configurable: desc.configurable,
      enumerable: desc.enumerable,
      get: function () {
        return desc.get.call(this);
      },
      set: function (value) {
        desc.set.call(this, convert(value));
      }
    });
  };

  var nativeSetAttribute = Element.prototype.setAttribute;
  Element.prototype.setAttribute = function (name, value) {
    var attr = String(name || "").toLowerCase();
    if (attr === "srcset") {
      value = mapSrcSet(value);
    } else if (
      attr === "src" ||
      attr === "href" ||
      attr === "data" ||
      attr === "poster" ||
      attr === "action"
    ) {
      value = mapValue(value);
    }
    return nativeSetAttribute.call(this, name, value);
  };

  if (Element.prototype.setAttributeNS) {
    var nativeSetAttributeNS = Element.prototype.setAttributeNS;
    Element.prototype.setAttributeNS = function (namespace, name, value) {
      var attr = String(name || "").toLowerCase();
      if (attr === "srcset") {
        value = mapSrcSet(value);
      } else if (
        attr === "src" ||
        attr === "href" ||
        attr === "data" ||
        attr === "poster" ||
        attr === "action"
      ) {
        value = mapValue(value);
      }
      return nativeSetAttributeNS.call(this, namespace, name, value);
    };
  }

  patchProperty(HTMLScriptElement, "src");
  patchProperty(HTMLLinkElement, "href");
  patchProperty(HTMLImageElement, "src");
  patchProperty(HTMLImageElement, "srcset", mapSrcSet);
  patchProperty(HTMLIFrameElement, "src");
  patchProperty(HTMLObjectElement, "data");
  patchProperty(HTMLEmbedElement, "src");
  patchProperty(HTMLAnchorElement, "href");
  patchProperty(HTMLFormElement, "action");
  patchProperty(HTMLSourceElement, "src");
  patchProperty(HTMLTrackElement, "src");
  patchProperty(HTMLInputElement, "src");
  if (window.HTMLMediaElement) {
    patchProperty(HTMLMediaElement, "src");
  }

  var nativeFetch = window.fetch.bind(window);
  window.fetch = function (input, init) {
    if (typeof input === "string" || input instanceof URL) {
      var originalInput = input;
      var mappedInput = mapValue(input);
      if (mappedInput === originalInput) {
        return nativeFetch(originalInput, init);
      }
      return nativeFetch(mappedInput, init).catch(function () {
        return nativeFetch(originalInput, init);
      });
    }
    if (input instanceof Request) {
      var mapped = resolver(input.url);
      if (mapped) {
        try {
          return nativeFetch(new Request(mapped, input), init).catch(function () {
            return nativeFetch(input, init);
          });
        } catch (_error) {
          return nativeFetch(input, init);
        }
      }
    }
    return nativeFetch(input, init);
  };

  var nativeOpen = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function (method, url) {
    var rest = Array.prototype.slice.call(arguments, 2);
    return nativeOpen.apply(this, [method, mapValue(url)].concat(rest));
  };

  if (window.Worker) {
    var NativeWorker = window.Worker;
    window.Worker = function (url, options) {
      return new NativeWorker(mapValue(url), options);
    };
    window.Worker.prototype = NativeWorker.prototype;
  }

  if (window.SharedWorker) {
    var NativeSharedWorker = window.SharedWorker;
    window.SharedWorker = function (url, options) {
      return new NativeSharedWorker(mapValue(url), options);
    };
    window.SharedWorker.prototype = NativeSharedWorker.prototype;
  }

  if (window.FontFace) {
    var NativeFontFace = window.FontFace;
    window.FontFace = function (family, source, descriptors) {
      var nextSource = source;
      if (typeof source === "string") {
        nextSource = source.replace(
          /url\\(\\s*(['"]?)([^"')]+)\\1\\s*\\)/gi,
          function (full, quote, urlPath) {
            var mapped = resolver(urlPath);
            if (!mapped) {
              return full;
            }
            var wrapped = quote || '"';
            return "url(" + wrapped + mapped + wrapped + ")";
          }
        );
      }
      return new NativeFontFace(family, nextSource, descriptors);
    };
    window.FontFace.prototype = NativeFontFace.prototype;
  }

  var innerHtmlDesc = Object.getOwnPropertyDescriptor(Element.prototype, "innerHTML");
  if (innerHtmlDesc && typeof innerHtmlDesc.get === "function" && typeof innerHtmlDesc.set === "function") {
    Object.defineProperty(Element.prototype, "innerHTML", {
      configurable: innerHtmlDesc.configurable,
      enumerable: innerHtmlDesc.enumerable,
      get: function () {
        return innerHtmlDesc.get.call(this);
      },
      set: function (value) {
        innerHtmlDesc.set.call(this, value);
        remapElementTree(this);
      }
    });
  }

  if (window.CSSStyleSheet && CSSStyleSheet.prototype) {
    var nativeInsertRule = CSSStyleSheet.prototype.insertRule;
    if (typeof nativeInsertRule === "function") {
      CSSStyleSheet.prototype.insertRule = function (rule, index) {
        return nativeInsertRule.call(this, rewriteCssRuntime(String(rule || "")), index);
      };
    }
  }

  if (window.MutationObserver) {
    var observer = new MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) {
        var mutation = mutations[i];
        if (mutation.type === "attributes" && mutation.target) {
          remapElementTree(mutation.target);
          continue;
        }
        if (mutation.type === "childList") {
          for (var j = 0; j < mutation.addedNodes.length; j++) {
            var node = mutation.addedNodes[j];
            if (node && node.nodeType === 1) {
              remapElementTree(node);
            }
          }
        }
      }
    });
    observer.observe(document.documentElement || document, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["src", "href", "data", "poster", "action", "srcset"]
    });
  }

  var installWebGLSafetyPatch = function () {
    if (!UNITY_GPU_SAFE_MODE || !window.HTMLCanvasElement || !HTMLCanvasElement.prototype) {
      return;
    }
    if (window.__loaderWebglSafetyInstalled) {
      return;
    }
    window.__loaderWebglSafetyInstalled = true;

    var forcedDpr = Number(UNITY_CLAMP_DEVICE_PIXEL_RATIO) || 0;
    if (forcedDpr > 0) {
      try {
        Object.defineProperty(window, "devicePixelRatio", {
          configurable: true,
          get: function () {
            return forcedDpr;
          }
        });
      } catch (_error) {
        // read-only in some environments
      }
    }

    var nativeGetContext = HTMLCanvasElement.prototype.getContext;
    if (typeof nativeGetContext !== "function") {
      return;
    }

    var isLikelyUnityPage = function () {
      try {
        if (typeof window.createUnityInstance === "function" || typeof window.UnityLoader !== "undefined") {
          return true;
        }
      } catch (_error) {
        // ignore and continue to DOM checks
      }
      try {
        return !!document.querySelector(
          'script[src*="UnityLoader"], script[src*="unityloader"], script[src*="/Build/"], script[src*="framework"]'
        );
      } catch (_error) {
        return false;
      }
    };

    HTMLCanvasElement.prototype.getContext = function (type, attrs) {
      var kind = String(type || "").toLowerCase();
      if (UNITY_FORCE_WEBGL1 && kind === "webgl2" && isLikelyUnityPage()) {
        return null;
      }

      if (
        kind === "webgl" ||
        kind === "experimental-webgl" ||
        kind === "webgl2"
      ) {
        var nextAttrs = Object.assign({}, attrs || {}, {
          antialias: false,
          alpha: false,
          stencil: false,
          premultipliedAlpha: false,
          preserveDrawingBuffer: false,
          desynchronized: true,
          powerPreference: "low-power"
        });
        return nativeGetContext.call(this, type, nextAttrs);
      }

      return nativeGetContext.call(this, type, attrs);
    };

    console.log("[GPU Safe] WebGL safety mode active (low-memory attrs; WebGL1 fallback for Unity pages).");
  };
  installWebGLSafetyPatch();

  var ensureVisibleSurface = function () {
    if (!document.documentElement || !document.body) {
      return;
    }
    if (!document.documentElement.style.height) {
      document.documentElement.style.height = "100%";
    }
    if (!document.body.style.height) {
      document.body.style.height = "100%";
    }
    if (!document.body.style.margin || document.body.style.margin === "8px") {
      document.body.style.margin = "0";
    }

    var fixBox = function (element) {
      if (!element || !element.getBoundingClientRect) return;
      var rect = element.getBoundingClientRect();
      var isCanvas = element.tagName === "CANVAS";
      if (rect.width > 0 && rect.height > 0 && (!isCanvas || (element.width > 0 && element.height > 0))) {
        return;
      }

      var widthStyle = element.style.width || "";
      var heightStyle = element.style.height || "";
      if (!widthStyle || widthStyle === "100%" || widthStyle === "0px") {
        element.style.width = "100vw";
      }
      if (!heightStyle || heightStyle === "100%" || heightStyle === "0px") {
        element.style.height = "100vh";
      }
      if (!element.style.display) {
        element.style.display = "block";
      }
      if (!element.style.position || element.style.position === "static") {
        element.style.position = "relative";
      }

      if (isCanvas) {
        var viewportWidth = Math.max(window.innerWidth || 0, 1);
        var viewportHeight = Math.max(window.innerHeight || 0, 1);
        if (!element.width || element.width === 0) {
          element.width = viewportWidth;
        }
        if (!element.height || element.height === 0) {
          element.height = viewportHeight;
        }
      }
    };

    var roots = [
      document.getElementById("gameContainer"),
      document.getElementById("unityContainer"),
      document.getElementById("unity-canvas"),
      document.querySelector(".webgl-content"),
      document.querySelector("#canvas")
    ];

    for (var i = 0; i < roots.length; i++) {
      fixBox(roots[i]);
    }

    var canvases = document.querySelectorAll("canvas");
    for (var c = 0; c < canvases.length; c++) {
      var canvas = canvases[c];
      fixBox(canvas);
      if (canvas.parentElement) {
        fixBox(canvas.parentElement);
      }
    }
  };

  window.addEventListener("load", function () {
    ensureVisibleSurface();
    try {
      window.dispatchEvent(new Event("resize"));
    } catch (_error) {
      // ignore
    }
  });
  window.addEventListener("resize", ensureVisibleSurface);
  document.addEventListener("DOMContentLoaded", ensureVisibleSurface);
  var surfaceTries = 0;
  var surfaceTimer = setInterval(function () {
    ensureVisibleSurface();
    surfaceTries += 1;
    if (surfaceTries >= 40) {
      clearInterval(surfaceTimer);
    }
  }, 250);

  window.addEventListener(
    "error",
    function (event) {
      var target = event && event.target;
      if (!target || target === window) return;
      var badUrl = target.src || target.href || target.data || "";
      if (typeof badUrl === "string" && badUrl.indexOf("https://loader.invalid/") === 0) {
        console.error("Unresolved asset URL:", badUrl);
      }
    },
    true
  );

  // Suppress popups that mention file:// from bundled games.
  (function () {
    var originalAlert = window.alert;
    var originalConfirm = window.confirm;
    var originalPrompt = window.prompt;
    var shouldSuppress = function (message) {
      var text = String(message || "");
      return /file:/i.test(text);
    };
    if (typeof originalAlert === "function") {
      window.alert = function (message) {
        if (shouldSuppress(message)) {
          console.warn("Suppressed popup containing file://:", String(message || ""));
          return;
        }
        return originalAlert.call(window, message);
      };
    }
    if (typeof originalConfirm === "function") {
      window.confirm = function (message) {
        if (shouldSuppress(message)) {
          console.warn("Suppressed popup containing file://:", String(message || ""));
          return true;
        }
        return originalConfirm.call(window, message);
      };
    }
    if (typeof originalPrompt === "function") {
      window.prompt = function (message, defaultValue) {
        if (shouldSuppress(message)) {
          console.warn("Suppressed popup containing file://:", String(message || ""));
          return defaultValue == null ? "" : String(defaultValue);
        }
        return originalPrompt.call(window, message, defaultValue);
      };
    }
  })();
})();
`;
    const base = documentNode.head.querySelector("base");
    if (base && base.nextSibling) {
      documentNode.head.insertBefore(script, base.nextSibling);
      return;
    }
    if (base) {
      documentNode.head.append(script);
      return;
    }
    documentNode.head.prepend(script);
  }

  function rewriteDocumentHtml(htmlText, entryPath) {
    const parser = new DOMParser();
    const documentNode = parser.parseFromString(htmlText, "text/html");
    const baseHref = toVirtualUrl(entryPath);

    let baseElement = documentNode.querySelector("base");
    if (!baseElement) {
      baseElement = documentNode.createElement("base");
      documentNode.head.prepend(baseElement);
    }
    baseElement.setAttribute("href", baseHref);

    for (const manifestLink of documentNode.querySelectorAll('link[rel="manifest"]')) {
      manifestLink.remove();
    }

    const targets = [
      ["script", "src"],
      ["link", "href"],
      ["img", "src"],
      ["audio", "src"],
      ["video", "src"],
      ["source", "src"],
      ["track", "src"],
      ["object", "data"],
      ["embed", "src"],
      ["iframe", "src"]
    ];

    for (const [selector, attribute] of targets) {
      const elements = documentNode.querySelectorAll(selector + "[" + attribute + "]");
      for (const element of elements) {
        const original = element.getAttribute(attribute);
        const mapped = requestToObjectUrl(original, baseHref);
        if (mapped) {
          element.setAttribute(attribute, mapped);
        }
      }
    }

    for (const element of documentNode.querySelectorAll("[srcset]")) {
      const rewritten = rewriteSrcSet(element.getAttribute("srcset"), baseHref);
      element.setAttribute("srcset", rewritten);
    }

    injectRuntimeBridge(documentNode);
    return "<!DOCTYPE html>\n" + documentNode.documentElement.outerHTML;
  }

  async function launchSelectedGame() {
    const gameId = state.selectedGameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game) {
      log("Choose a saved game first.", "error");
      return;
    }

    const chosenEntry = entrySelect.value || game.entryPath || chooseBestEntryPath(game.htmlEntries || [], "");
    if (!chosenEntry) {
      log("No startup HTML file was found for this game.", "error");
      return;
    }

    launchButton.disabled = true;
    deleteGameButton.disabled = true;

    try {
      setWorkProgress("Loading game data", 0, 4);
      log("Loading \"" + game.name + "\" from IndexedDB...");
      if (!state.playerWindow || state.playerWindow.closed) {
        state.playerWindow = window.open("about:blank", "cbgamesOfflinePlayer");
      }
      if (!state.playerWindow) {
        throw new Error("Popup blocked. Allow popups for this file page.");
      }

      const files = await getAllFilesForGame(game.id);
      setWorkProgress("Preparing game assets", 1, 4);
      if (!files.length) {
        throw new Error("No files were found for this game in IndexedDB.");
      }

      await buildObjectUrlCacheFromRecords(files, state.playerWindow);
      setWorkProgress("Preparing game assets", 2, 4);
      state.activeEntryPath = chosenEntry;

      const fileMap = new Map(files.map((record) => [record.path, record]));
      let entryPath = chosenEntry;
      let entryRecord = fileMap.get(entryPath);

      if (!entryRecord) {
        const htmlEntries = files
          .map((record) => record.path)
          .filter((path) => /\.html?$/i.test(path));
        entryPath = chooseBestEntryPath(htmlEntries, game.entryPath || "");
        entryRecord = fileMap.get(entryPath);
      }

      if (!entryRecord) {
        throw new Error("Startup file is missing from saved data.");
      }

      const htmlText = await entryRecord.blob.text();
      const rewrittenHtml = rewriteDocumentHtml(htmlText, entryPath);
      setWorkProgress("Opening player window", 3, 4);

      state.playerWindow.document.open();
      state.playerWindow.document.write(rewrittenHtml);
      state.playerWindow.document.close();
      state.playerWindow.focus();

      if (game.entryPath !== entryPath) {
        game.entryPath = entryPath;
        state.gamesById.set(game.id, game);
        await putGame(game);
        updateSelectedGameInfo(game);
      }

      setWorkProgress("Launch complete", 4, 4);
      log("Launched: " + game.name + " (" + entryPath + ")");
    } catch (error) {
      console.error(error);
      log("Launch failed: " + (error.message || String(error)), "error");
    } finally {
      launchButton.disabled = false;
      deleteGameButton.disabled = false;
      setTimeout(clearWorkProgress, 350);
    }
  }

  async function deleteSelectedGame() {
    const gameId = state.selectedGameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game) {
      log("Choose a saved game to delete.", "error");
      return;
    }

    const ok = window.confirm("Delete \"" + game.name + "\" from IndexedDB? This cannot be undone.");
    if (!ok) {
      return;
    }

    setActionButtonsDisabled(true);

    try {
      await deleteFilesByGameId(game.id);
      await deleteGameRecord(game.id);
      state.gamesById.delete(game.id);

      if (state.selectedGameId === game.id) {
        state.selectedGameId = null;
      }

      clearObjectUrls();
      state.activeEntryPath = null;

      if (state.playerWindow && !state.playerWindow.closed) {
        state.playerWindow.close();
      }
      state.playerWindow = null;

      // Recycling the DB connection helps some browsers update storage estimates
      // sooner after large IndexedDB deletions.
      await reopenDatabaseConnection();
      await putSetting(SETTING_SELECTED_GAME, "");
      await loadLibrary();
      log("Deleted game: " + game.name);
    } catch (error) {
      console.error(error);
      log("Delete failed: " + (error.message || String(error)), "error");
    } finally {
      setActionButtonsDisabled(false);
    }
  }

  function normalizeBundleGameRecord(record) {
    const source = record && typeof record === "object" ? record : {};
    const normalized = {
      id: typeof source.id === "string" && source.id ? source.id : makeId(),
      name: typeof source.name === "string" && source.name ? source.name : "Imported Game",
      zipName: typeof source.zipName === "string" && source.zipName ? source.zipName : "Imported Bundle",
      importedAt: Number(source.importedAt) || Date.now(),
      fileCount: Number(source.fileCount) || 0,
      totalBytes: Number(source.totalBytes) || 0,
      htmlEntries: Array.isArray(source.htmlEntries) ? source.htmlEntries.map((v) => normalizePath(v)).filter(Boolean) : [],
      entryPath: typeof source.entryPath === "string" ? normalizePath(source.entryPath) : "",
      thumbnailDataUrl: typeof source.thumbnailDataUrl === "string" ? source.thumbnailDataUrl : ""
    };
    normalized.entryPath = chooseBestEntryPath(normalized.htmlEntries, normalized.entryPath);
    return normalized;
  }

  async function exportAllGamesBundle(progressCallback) {
    const games = await getAllGames();
    if (!games.length) {
      throw new Error("No saved games to export.");
    }
    const zipEntries = [];
    const manifest = {
      format: "cbgames-zip-v2",
      createdAt: Date.now(),
      games: []
    };
    let processedGames = 0;
    for (const game of games) {
      const files = await getAllFilesForGame(game.id);
      const gameFolder = "games/" + encodeURIComponent(game.id);
      const manifestGame = {
        id: game.id,
        name: game.name,
        zipName: game.zipName,
        importedAt: game.importedAt,
        fileCount: game.fileCount,
        totalBytes: game.totalBytes,
        htmlEntries: Array.isArray(game.htmlEntries) ? game.htmlEntries : [],
        entryPath: game.entryPath || "",
        files: []
      };
      if (typeof game.thumbnailDataUrl === "string" && game.thumbnailDataUrl) {
        const thumb = parseDataUrlToBytes(game.thumbnailDataUrl);
        if (thumb && thumb.bytes.length) {
          const thumbPath = gameFolder + "/thumbnail" + extensionFromMime(thumb.mime);
          zipEntries.push({
            path: thumbPath,
            bytes: thumb.bytes
          });
          manifestGame.thumbnail = {
            path: thumbPath,
            type: thumb.mime
          };
        }
      }
      for (const file of files) {
        const bytes = new Uint8Array(await file.blob.arrayBuffer());
        const zipPath = gameFolder + "/files/" + normalizePath(file.path);
        zipEntries.push({
          path: zipPath,
          bytes
        });
        manifestGame.files.push({
          path: normalizePath(file.path),
          type: file.type || mimeFromPath(file.path),
          size: Number(file.size) || bytes.byteLength,
          zipPath
        });
      }
      manifest.games.push(manifestGame);
      processedGames += 1;
      if (typeof progressCallback === "function") {
        progressCallback(processedGames, games.length);
      }
    }

    const manifestBytes = encodeUtf8(JSON.stringify(manifest));
    zipEntries.unshift({
      path: "bundle.json",
      bytes: manifestBytes
    });

    return createZipStoreArchive(zipEntries);
  }

  async function downloadAllGamesBundle() {
    setActionButtonsDisabled(true);
    try {
      setWorkProgress("Preparing game bundle", 0, 0);
      log("Preparing game bundle...");
      const bundleZip = await exportAllGamesBundle((current, total) => {
        setWorkProgress("Reading saved games", current, total);
      });
      setWorkProgress("Writing bundle file", 1, 1);
      const filename = "cbgames-bundle.zip";
      const url = URL.createObjectURL(bundleZip);
      try {
        const anchor = document.createElement("a");
        anchor.href = url;
        anchor.download = filename;
        document.body.append(anchor);
        anchor.click();
        anchor.remove();
      } finally {
        URL.revokeObjectURL(url);
      }
      log("Exported games to " + filename + ".");
    } finally {
      setActionButtonsDisabled(false);
      clearWorkProgress();
    }
  }

  async function pickBundleFile() {
    if (window.showOpenFilePicker) {
      try {
        const handles = await window.showOpenFilePicker({
          multiple: false,
          excludeAcceptAllOption: false,
          types: [
            {
              description: "CBGames bundle",
              accept: {
                "application/zip": [".zip"],
                "application/x-zip-compressed": [".zip"]
              }
            }
          ]
        });
        if (!handles.length) {
          return;
        }
        const file = await handles[0].getFile();
        await importBundleFile(file);
      } catch (error) {
        if (error && error.name === "AbortError") {
          log("Bundle import canceled.");
          return;
        }
        console.error(error);
        log("Bundle import failed: " + (error.message || String(error)), "error");
      }
      return;
    }

    bundleInput.value = "";
    bundleInput.click();
  }

  async function importBundleFile(file) {
    if (!file) {
      return;
    }
    setActionButtonsDisabled(true);
    try {
      setWorkProgress("Reading bundle", 0, 0);
      log("Reading bundle: " + file.name);
      const buffer = await file.arrayBuffer();
      let parsedZip;
      try {
        parsedZip = parseZipArchive(buffer);
      } catch {
        throw new Error("Bundle import only supports .zip files.");
      }
      const entryByPath = new Map(parsedZip.entries.map((entry) => [normalizePath(entry.path), entry]));
      const manifestEntry = entryByPath.get("bundle.json");
      if (!manifestEntry) {
        throw new Error("Bundle ZIP missing bundle.json.");
      }
      const manifestBytes = await extractEntryBytes(parsedZip, manifestEntry);
      let bundle;
      try {
        bundle = JSON.parse(decodeUtf8(manifestBytes));
      } catch {
        throw new Error("Invalid bundle JSON inside ZIP.");
      }
      if (!bundle || bundle.format !== "cbgames-zip-v2" || !Array.isArray(bundle.games)) {
        throw new Error("Unsupported backup format.");
      }

      const idMap = new Map();
      for (const rawGame of bundle.games) {
        const game = normalizeBundleGameRecord({
          ...rawGame,
          thumbnailDataUrl: ""
        });
        if (state.gamesById.has(game.id) || idMap.has(game.id)) {
          idMap.set(game.id, makeId());
        } else {
          idMap.set(game.id, game.id);
        }
      }

      let importedGames = 0;
      setWorkProgress("Importing game metadata", 0, bundle.games.length || 1);
      for (const rawGame of bundle.games) {
        const game = normalizeBundleGameRecord({
          ...rawGame,
          thumbnailDataUrl: ""
        });
        game.id = idMap.get(game.id) || makeId();
        if (rawGame && rawGame.thumbnail && typeof rawGame.thumbnail.path === "string") {
          const thumbEntry = entryByPath.get(normalizePath(rawGame.thumbnail.path));
          if (thumbEntry) {
            const thumbBytes = await extractEntryBytes(parsedZip, thumbEntry);
            const thumbMime = typeof rawGame.thumbnail.type === "string" && rawGame.thumbnail.type
              ? rawGame.thumbnail.type
              : mimeFromPath(rawGame.thumbnail.path);
            game.thumbnailDataUrl = "data:" + thumbMime + ";base64," + bytesToBase64(thumbBytes);
          }
        }
        await putGame(game);
        state.gamesById.set(game.id, game);
        importedGames += 1;
        if (importedGames % 5 === 0 || importedGames === bundle.games.length) {
          setWorkProgress("Importing game metadata", importedGames, bundle.games.length || 1);
        }
      }

      let importedFiles = 0;
      const totalFiles = bundle.games.reduce((sum, game) => {
        const files = Array.isArray(game && game.files) ? game.files.length : 0;
        return sum + files;
      }, 0);
      setWorkProgress("Importing game files", 0, totalFiles || 1);
      for (const rawGame of bundle.games) {
        const sourceGameId = typeof rawGame.id === "string" ? rawGame.id : "";
        const mappedGameId = idMap.get(sourceGameId);
        if (!mappedGameId) {
          continue;
        }
        const fileList = Array.isArray(rawGame.files) ? rawGame.files : [];
        for (const fileInfo of fileList) {
          if (!fileInfo || typeof fileInfo !== "object") {
            continue;
          }
          const sourcePath = normalizePath(fileInfo.path || "");
          const zipPath = normalizePath(fileInfo.zipPath || "");
          if (!sourcePath || !zipPath) {
            continue;
          }
          const zipEntry = entryByPath.get(zipPath);
          if (!zipEntry) {
            throw new Error("Bundle missing file payload: " + zipPath);
          }
          const fileBytes = await extractEntryBytes(parsedZip, zipEntry);
          const type = typeof fileInfo.type === "string" && fileInfo.type ? fileInfo.type : mimeFromPath(sourcePath);
          const blob = new Blob([fileBytes], { type });
          await putFileRecord({
            gameId: mappedGameId,
            path: sourcePath,
            size: blob.size,
            type: blob.type,
            blob
          });
          importedFiles += 1;
          if (importedFiles % 25 === 0 || importedFiles === totalFiles) {
            setWorkProgress("Importing game files", importedFiles, totalFiles || 1);
          }
        }
      }

      setWorkProgress("Refreshing library", 0, 0);
      const preferredSelected = state.selectedGameId && state.gamesById.has(state.selectedGameId)
        ? state.selectedGameId
        : (bundle.games[0] && idMap.get(bundle.games[0].id)) || "";
      await loadLibrary(preferredSelected);
      if (preferredSelected) {
        await putSetting(SETTING_SELECTED_GAME, preferredSelected);
      }
      log("Imported bundle: " + importedGames + " games and " + importedFiles + " files.");
    } catch (error) {
      console.error(error);
      log("Bundle import failed: " + (error.message || String(error)), "error");
    } finally {
      setActionButtonsDisabled(false);
      clearWorkProgress();
    }
  }

  gameSelect.addEventListener("change", async () => {
    const nextId = gameSelect.value || null;
    await selectGameById(nextId);
  });

  entrySelect.addEventListener("change", async () => {
    const gameId = state.selectedGameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game || !entrySelect.value) {
      return;
    }
    game.entryPath = entrySelect.value;
    state.gamesById.set(game.id, game);
    try {
      await putGame(game);
      selectedEntry.textContent = game.entryPath;
      log("Startup file set to " + game.entryPath);
    } catch (error) {
      console.error(error);
      log("Could not save startup file selection.", "error");
    }
  });

  importZipButton.addEventListener("click", pickZipFile);
  exportAllGamesButton.addEventListener("click", async () => {
    try {
      await downloadAllGamesBundle();
    } catch (error) {
      console.error(error);
      log("Bundle export failed: " + (error.message || String(error)), "error");
    }
  });
  importAllGamesButton.addEventListener("click", pickBundleFile);
  launchButton.addEventListener("click", launchSelectedGame);
  deleteGameButton.addEventListener("click", deleteSelectedGame);
  gameSearch.addEventListener("input", () => {
    state.searchQuery = gameSearch.value || "";
    renderGameCards();
  });

  gamesGrid.addEventListener("click", async (event) => {
    const target = event.target;
    if (!(target instanceof HTMLElement)) {
      return;
    }
    const action = target.dataset.action || "";
    const gameId = target.dataset.gameId || target.closest("[data-game-id]")?.dataset.gameId || "";
    if (!gameId || !state.gamesById.has(gameId)) {
      return;
    }

    if (action === "thumb") {
      await selectGameById(gameId);
      openThumbnailModal(gameId);
      return;
    }
    if (action === "launch") {
      await selectGameById(gameId);
      await launchSelectedGame();
      return;
    }
    if (action === "delete") {
      await selectGameById(gameId);
      await deleteSelectedGame();
      return;
    }
    await selectGameById(gameId);
  });

  gamesGrid.addEventListener("dblclick", async (event) => {
    const target = event.target;
    if (!(target instanceof HTMLElement)) {
      return;
    }
    const gameId = target.closest("[data-game-id]")?.dataset.gameId || "";
    if (!gameId || !state.gamesById.has(gameId)) {
      return;
    }
    await selectGameById(gameId);
    await launchSelectedGame();
  });

  closeThumbModalButton.addEventListener("click", closeThumbModal);
  thumbModal.addEventListener("click", (event) => {
    if (event.target === thumbModal) {
      closeThumbModal();
    }
  });
  document.addEventListener("keydown", (event) => {
    if (event.key === "Escape" && thumbModal.classList.contains("open")) {
      closeThumbModal();
    }
  });
  uploadThumbButton.addEventListener("click", () => {
    thumbInput.value = "";
    thumbInput.click();
  });
  thumbInput.addEventListener("change", () => {
    if (!thumbInput.files || !thumbInput.files.length) {
      return;
    }
    loadThumbnailSource(thumbInput.files[0]);
  });
  saveThumbButton.addEventListener("click", async () => {
    try {
      await saveThumbnailCrop();
    } catch (error) {
      console.error(error);
      log("Could not save thumbnail.", "error");
    }
  });
  removeThumbButton.addEventListener("click", async () => {
    try {
      await removeThumbnail();
    } catch (error) {
      console.error(error);
      log("Could not remove thumbnail.", "error");
    }
  });

  zipInput.addEventListener("change", async () => {
    if (!zipInput.files || !zipInput.files.length) {
      return;
    }
    await importZipFile(zipInput.files[0]);
  });
  bundleInput.addEventListener("change", async () => {
    if (!bundleInput.files || !bundleInput.files.length) {
      return;
    }
    await importBundleFile(bundleInput.files[0]);
  });

  setEmptyEntryState("Loading...");

  (async () => {
    try {
      state.db = await openDatabase();
      const savedGameId = await getSetting(SETTING_SELECTED_GAME);
      await loadLibrary(savedGameId || "");
      log("Ready. Import a ZIP game to begin.");
       const urlParams = new URLSearchParams(window.location.search);
      const loadParam = urlParams.get('load');
      if (loadParam) {
        const lower = loadParam.toLowerCase();
        const match =
          state.gamesById.get(loadParam) ||
          Array.from(state.gamesById.values()).find(
            g => g.name.toLowerCase() === lower ||
                 g.name.toLowerCase().replace(/\s+/g, '') === lower.replace(/\s+/g, '')
          );
        if (match) {
          await selectGameById(match.id);
          await launchSelectedGame();
        } else {
          log('No saved game found matching "' + loadParam + '".', "error");
        }
      }
    } catch (error) {
      console.error(error);
      setEmptyEntryState("Initialization failed");
      log("Initialization failed: " + (error.message || String(error)), "error");
      setActionButtonsDisabled(true);
    }
  })();
})();
</script>

</body>
</html>
