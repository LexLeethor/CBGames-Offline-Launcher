<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CBGames Offline Launcher</title>
<link rel="icon" type="image/png" href="./favicon.png">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="./lib/cropper.min.css">
<style>
  :root {
    --error-color: #ff4d4f;
    --scroll-track: #111;
    --scroll-thumb: #2d2d2d;
    --scroll-thumb-hover: #3a3a3a;
    --scroll-edge: #222;
  }
  html,
  body {
    height: 100%;
  }
  * { box-sizing: border-box; }
  .container,
  .side-panel,
  #status,
  .game-edit-dialog,
  .bundle-preview-dialog,
  .bundle-preview-list {
    scrollbar-width: thin;
    scrollbar-color: var(--scroll-thumb) var(--scroll-track);
  }
  .container::-webkit-scrollbar,
  .side-panel::-webkit-scrollbar,
  #status::-webkit-scrollbar,
  .game-edit-dialog::-webkit-scrollbar,
  .bundle-preview-dialog::-webkit-scrollbar,
  .bundle-preview-list::-webkit-scrollbar {
    width: 10px;
    height: 10px;
  }
  .container::-webkit-scrollbar-track,
  .side-panel::-webkit-scrollbar-track,
  #status::-webkit-scrollbar-track,
  .game-edit-dialog::-webkit-scrollbar-track,
  .bundle-preview-dialog::-webkit-scrollbar-track,
  .bundle-preview-list::-webkit-scrollbar-track {
    background: var(--scroll-track);
    border-radius: 999px;
    box-shadow: inset 0 0 0 1px var(--scroll-edge);
  }
  .container::-webkit-scrollbar-thumb,
  .side-panel::-webkit-scrollbar-thumb,
  #status::-webkit-scrollbar-thumb,
  .game-edit-dialog::-webkit-scrollbar-thumb,
  .bundle-preview-dialog::-webkit-scrollbar-thumb,
  .bundle-preview-list::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #363636 0%, var(--scroll-thumb) 100%);
    border-radius: 999px;
    border: 1px solid #1a1a1a;
  }
  .container::-webkit-scrollbar-thumb:hover,
  .side-panel::-webkit-scrollbar-thumb:hover,
  #status::-webkit-scrollbar-thumb:hover,
  .game-edit-dialog::-webkit-scrollbar-thumb:hover,
  .bundle-preview-dialog::-webkit-scrollbar-thumb:hover,
  .bundle-preview-list::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #4a4a4a 0%, var(--scroll-thumb-hover) 100%);
  }
  body {
    background-color: #121212;
    margin: 0;
    color: #fff;
    font-family: "Poppins", sans-serif;
    display: flex;
    flex-direction: column;
    min-height: 100dvh;
    overflow: hidden;
  }
  header {
    position: sticky;
    top: 0;
    background-color: #181818;
    display: flex;
    justify-content: space-between;
    padding: 15px 30px;
    z-index: 1000;
  }
  header .logo {
    color: #fff;
    font-size: 24px;
    font-weight: 600;
  }
  header nav {
    display: flex;
    gap: 20px;
    align-items: center;
  }
  header nav a {
    text-decoration: none;
    color: white;
    font-size: 18px;
    padding: 5px 10px;
    border-radius: 5px;
    background-color: #1a1a1a;
    transition: background 0.3s;
  }
  header nav a:hover {
    background-color: #2a2a2a;
  }
  .profile-pic-container {
    margin-left: auto;
    padding: 0 10px;
  }
  #profilePicture {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid #444;
    transition: none;
  }
  #profilePicture:hover {
    transform: none;
    cursor: pointer;
  }
  .search-bar {
    margin: 12px auto;
    width: min(980px, 90vw);
    display: flex;
    justify-content: center;
    flex: 0 0 auto;
  }
  .search-bar input {
    width: 100%;
    padding: 10px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    background: #1a1a1a;
    color: #fff;
  }
  button {
    border: 1px solid #2d2d2d;
    background: #1a1a1a;
    color: #fff;
    border-radius: 8px;
    padding: 10px 12px;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
  }
  button:hover:not(:disabled):not(.square-button) { background: #2a2a2a; }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  #deleteGame { color: #ffbcbc; }
  .workspace {
    width: min(1480px, 96vw);
    margin: 0 auto 14px;
    display: grid;
    grid-template-columns: minmax(220px, 280px) minmax(0, 1fr) minmax(250px, 320px);
    gap: 16px;
    align-items: stretch;
    flex: 1 1 auto;
    min-height: 0;
    overflow: hidden;
  }
  .games-column {
    display: grid;
    justify-items: stretch;
    gap: 10px;
    min-height: 0;
  }
  .container {
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr));
    grid-auto-flow: row;
    grid-auto-rows: max-content;
    gap: 20px;
    align-content: start;
    padding: 20px;
    background: #141414;
    border-radius: 12px;
    min-height: 0;
    width: 100%;
    height: 100%;
    overflow-y: auto;
    overscroll-behavior: contain;
  }
  .game-item {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-self: start;
    align-items: stretch;
    text-align: center;
    transition: background-color 0.3s, transform 0.2s;
    border-radius: 15px;
    overflow: hidden;
    background: transparent;
    min-width: 0;
    position: relative;
    z-index: 0;
  }
  .game-item.is-drag-source {
    opacity: 0.2;
  }
  .game-item:hover {
    background-color: #1e1e1e;
    transform: scale(1.02);
    z-index: 1;
  }
  .game-item.is-selected {
    background-color: #222;
    outline: 1px solid #3b3b3b;
  }
  .square-button {
    width: 100%;
    height: auto;
    border: none;
    padding: 0;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-color: #202938;
    position: relative;
    cursor: pointer;
    display: block;
    transform: none;
    min-width: 0;
    appearance: none;
    -webkit-appearance: none;
  }
  .square-button::after {
    content: "";
    display: block;
    padding-top: 100%;
  }
  .square-button:hover {
    transform: none;
  }
  .square-button.no-thumb::before {
    content: "No image";
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 13px;
    color: #d8deeb;
    background: rgba(0, 0, 0, 0.25);
    border-radius: 999px;
    padding: 3px 8px;
  }
  .game-edit-trigger {
    position: absolute;
    right: 8px;
    bottom: 8px;
    width: 24px;
    height: 24px;
    border: 1px solid #444;
    background: rgba(16, 16, 16, 0.85);
    border-radius: 999px;
    display: grid;
    place-items: center;
    font-size: 0;
    color: transparent;
    padding: 0;
  }
  .game-edit-trigger::before {
    content: "";
    width: 13px;
    height: 13px;
    background-color: #fff;
    -webkit-mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zm2.92 2.33H5v-.92l8.06-8.06.92.92L5.92 19.58zM20.71 7.04c.39-.39.39-1.02 0-1.41L18.37 3.29a.996.996 0 1 0-1.41 1.41l2.34 2.34c.39.39 1.02.39 1.41 0z'/%3E%3C/svg%3E") center / contain no-repeat;
    mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zm2.92 2.33H5v-.92l8.06-8.06.92.92L5.92 19.58zM20.71 7.04c.39-.39.39-1.02 0-1.41L18.37 3.29a.996.996 0 1 0-1.41 1.41l2.34 2.34c.39.39 1.02.39 1.41 0z'/%3E%3C/svg%3E") center / contain no-repeat;
  }
  .game-badges {
    position: absolute;
    left: 8px;
    bottom: 8px;
    display: flex;
    align-items: center;
    gap: 6px;
    pointer-events: none;
  }
  .game-github-badge {
    width: 24px;
    height: 24px;
    border: 1px solid #444;
    background: rgba(16, 16, 16, 0.9);
    border-radius: 999px;
    display: grid;
    place-items: center;
  }
  .game-github-badge::before {
    content: "";
    width: 14px;
    height: 14px;
    background-color: #fff;
    -webkit-mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='black'%3E%3Cpath d='M8 0C3.58 0 0 3.58 0 8a8 8 0 0 0 5.47 7.59c.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.5-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82a7.66 7.66 0 0 1 4 0c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8z'/%3E%3C/svg%3E") center / contain no-repeat;
    mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='black'%3E%3Cpath d='M8 0C3.58 0 0 3.58 0 8a8 8 0 0 0 5.47 7.59c.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.5-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82a7.66 7.66 0 0 1 4 0c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8z'/%3E%3C/svg%3E") center / contain no-repeat;
  }
  .game-unity-badge {
    width: 24px;
    height: 24px;
    border: 1px solid #444;
    background: rgba(16, 16, 16, 0.92);
    border-radius: 999px;
    display: grid;
    place-items: center;
    padding: 0;
  }
  .game-unity-badge::before {
    content: "";
    width: 14px;
    height: 14px;
    background-color: #fff;
    transform: translateX(-1px);
    -webkit-mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32' fill='black'%3E%3Cpath d='M25.94 25.061l-5.382-9.060 5.382-9.064 2.598 9.062-2.599 9.060zM13.946 24.191l-6.768-6.717h10.759l5.38 9.061-9.372-2.342zM13.946 7.809l9.371-2.342-5.379 9.061h-10.761zM30.996 12.917l-3.282-11.913-12.251 3.193-1.812 3.112-3.68-0.027-8.966 8.719 8.967 8.72 3.678-0.029 1.817 3.112 12.246 3.192 3.283-11.908-1.864-3.087z'/%3E%3C/svg%3E") center / contain no-repeat;
    mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32' fill='black'%3E%3Cpath d='M25.94 25.061l-5.382-9.060 5.382-9.064 2.598 9.062-2.599 9.060zM13.946 24.191l-6.768-6.717h10.759l5.38 9.061-9.372-2.342zM13.946 7.809l9.371-2.342-5.379 9.061h-10.761zM30.996 12.917l-3.282-11.913-12.251 3.193-1.812 3.112-3.68-0.027-8.966 8.719 8.967 8.72 3.678-0.029 1.817 3.112 12.246 3.192 3.283-11.908-1.864-3.087z'/%3E%3C/svg%3E") center / contain no-repeat;
  }
  .game-flash-badge {
    width: 24px;
    height: 24px;
    border: 1px solid #6f1a1f;
    border-radius: 999px;
    overflow: hidden;
    background:
      url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyNC4zLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MTIgNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDp1cmwoI1hNTElEXzJfKTt9DQoJLnN0MXtmaWxsOiNGRkZGRkY7fQ0KPC9zdHlsZT4NCjxnIGlkPSJYTUxJRF8xOF8iPg0KCQ0KCQk8bGluZWFyR3JhZGllbnQgaWQ9IlhNTElEXzJfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjUuOTg4IiB5MT0iNTA2IiB4Mj0iNy4wMTIiIHkyPSI1MDYiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMCAtNTAwIDUwMCAwIC0yNTI3NDQgMzUwNi4wMDAyKSI+DQoJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiM0QzA2MEEiLz4NCgkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0QyMTkyMSIvPg0KCTwvbGluZWFyR3JhZGllbnQ+DQoJPHJlY3QgaWQ9IlhNTElEXzIwXyIgY2xhc3M9InN0MCIgd2lkdGg9IjUxMiIgaGVpZ2h0PSI1MTIiLz4NCgk8cGF0aCBpZD0iWE1MSURfMjRfIiBjbGFzcz0ic3QxIiBkPSJNMjE1LjA0LDI2Ny4yMmMtMzkuOTgsOTguNjEtMTA0LjUsOTcuMzUtMTA0LjUsOTcuMzV2NjIuODQNCgkJYzk5Ljg4LDAsMTM5LjU3LTY5LjAxLDE2OC42MS0xMzguNTloODEuMjJ2LTY1LjUxaC01NC43MWMzNC41MS03OC41NSw5MS42LTc1Ljc1LDkxLjYtNzUuNzVWODQuMDINCgkJQzI4Mi42NSw4NC4wMiwyNTAuMjUsMTgwLjI1LDIxNS4wNCwyNjcuMjJ6Ii8+DQo8L2c+DQo8L3N2Zz4NCg==") center / cover no-repeat;
  }
  .game-info {
    padding: 10px;
    width: 100%;
    background: #181818;
  }
  .game-title {
    color: #fff;
    font-size: 16px;
    margin: 0 0 8px;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    min-height: 40px;
  }
  .game-buttons {
    display: flex;
    justify-content: center;
    gap: 8px;
  }
  .game-buttons button {
    font-size: 12px;
    padding: 6px 8px;
    border-radius: 6px;
    background: #202020;
    border-color: #333;
    width: 100%;
  }
  .game-buttons .danger { color: #ffbcbc; }
  .side-panel {
    display: grid;
    gap: 12px;
    min-height: 0;
    overflow-x: hidden;
    overflow-y: auto;
    align-content: start;
  }
  .control-stack {
    display: grid;
    gap: 8px;
  }
  .ops-open-cta {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: 14px;
    border: 1px solid #2d2d2d;
    background: #1a1a1a;
    color: #fff;
    font-size: 16px;
    font-weight: 700;
    letter-spacing: 0.2px;
    text-align: center;
    line-height: 1.2;
    display: grid;
    place-items: center;
    padding: 14px;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
  }
  .ops-open-cta:hover:not(:disabled) {
    background: #2a2a2a;
  }
  .ops-open-cta::before {
    content: "";
    width: 90px;
    height: 90px;
    margin-bottom: 8px;
    background-color: #d8d8d8;
    -webkit-mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpolygon fill='none' stroke='black' stroke-width='2' stroke-miterlimit='10' points='63,18 63,54 1,54 1,10 22,10 30,18'/%3E%3Cpolyline fill='none' stroke='black' stroke-width='2' stroke-linejoin='bevel' stroke-miterlimit='10' points='23.998,34 31.998,26 39.998,34'/%3E%3Cline fill='none' stroke='black' stroke-width='2' stroke-miterlimit='10' x1='31.998' y1='26' x2='31.998' y2='46'/%3E%3C/svg%3E") center / contain no-repeat;
    mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpolygon fill='none' stroke='black' stroke-width='2' stroke-miterlimit='10' points='63,18 63,54 1,54 1,10 22,10 30,18'/%3E%3Cpolyline fill='none' stroke='black' stroke-width='2' stroke-linejoin='bevel' stroke-miterlimit='10' points='23.998,34 31.998,26 39.998,34'/%3E%3Cline fill='none' stroke='black' stroke-width='2' stroke-miterlimit='10' x1='31.998' y1='26' x2='31.998' y2='46'/%3E%3C/svg%3E") center / contain no-repeat;
  }
  .legacy-launch-actions {
    display: none;
  }
  .work-progress {
    display: grid;
    justify-items: center;
    gap: 8px;
  }
  .work-progress-circle {
    --progress-pct: 0;
    width: 118px;
    height: 118px;
    border-radius: 50%;
    background: conic-gradient(#73c9ff calc(var(--progress-pct) * 1%), #2a2a2a 0);
    position: relative;
    display: grid;
    place-items: center;
    transition: background 0.2s ease;
  }
  .work-progress-circle::before {
    content: "";
    width: 94px;
    height: 94px;
    border-radius: 50%;
    background: #151515;
    border: 1px solid #333;
  }
  .work-progress-value {
    position: absolute;
    font-size: 16px;
    font-weight: 600;
    color: #dff0ff;
  }
  .work-progress-label {
    font-size: 12px;
    color: #d6d6d6;
    text-align: center;
  }
  .work-progress.indeterminate .work-progress-circle {
    --progress-pct: 25;
    animation: workProgressSpin 1s linear infinite;
  }
  @keyframes workProgressSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
  .selected-stats {
    display: grid;
    gap: 8px;
    margin-top: 8px;
  }
  .panel-block {
    background: #181818;
    border-radius: 10px;
    border: 1px solid #2a2a2a;
    padding: 12px;
  }
  .panel-block h3 {
    margin: 0 0 10px;
    font-size: 15px;
    font-weight: 600;
  }
  .metrics {
    display: grid;
    gap: 8px;
  }
  .storage-visual {
    display: grid;
    gap: 12px;
  }
  .storage-donut {
    --used-pct: 0;
    width: 170px;
    height: 170px;
    margin: 0 auto;
    border-radius: 50%;
    background: conic-gradient(#73c9ff 0 calc(var(--used-pct) * 1%), #2a2a2a 0 100%);
    position: relative;
    display: grid;
    place-items: center;
  }
  .storage-donut::before {
    content: "";
    width: 126px;
    height: 126px;
    border-radius: 50%;
    background: #151515;
    border: 1px solid #333;
  }
  .storage-donut-center {
    position: absolute;
    display: grid;
    justify-items: center;
    gap: 2px;
  }
  .storage-donut-center strong {
    font-size: 24px;
    color: #e7f3ff;
    line-height: 1;
  }
  .storage-donut-center span {
    font-size: 12px;
    color: #c6c6c6;
    text-transform: uppercase;
    letter-spacing: 0.4px;
  }
  .storage-breakdown {
    display: grid;
    gap: 6px;
  }
  .storage-breakdown .metric {
    padding: 7px 9px;
  }
  .storage-breakdown .metric-label {
    font-size: 11px;
  }
  .storage-breakdown .metric-value {
    font-size: 12px;
  }
  .metric {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #1d1d1d;
    border: 1px solid #2a2a2a;
    border-radius: 8px;
    padding: 8px 10px;
  }
  .metric-label { color: #bababa; font-size: 12px; text-transform: uppercase; }
  .metric-value { color: #fff; font-size: 13px; font-weight: 600; }
  .hint {
    font-size: 13px;
    color: #c9c9c9;
    background: #1d1d1d;
    border: 1px solid #2b2b2b;
    padding: 8px 10px;
    border-radius: 8px;
    margin: 0;
  }
  .selected-summary {
    display: grid;
    grid-template-columns: 64px minmax(0, 1fr);
    gap: 10px;
    align-items: center;
  }
  .selected-thumb {
    width: 64px;
    height: 64px;
    border-radius: 10px;
    border: 1px solid #333;
    background: #202020 center / cover no-repeat;
    position: relative;
    overflow: hidden;
  }
  .selected-thumb.no-thumb::before {
    content: "";
    position: absolute;
    inset: 0;
    margin: auto;
    width: 28px;
    height: 28px;
    background: linear-gradient(180deg, #7a7a7a, #5e5e5e);
    -webkit-mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M10 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-8l-2-2zm2 6h2v3h3v2h-3v3h-2v-3H9v-2h3v-3z'/%3E%3C/svg%3E") center / contain no-repeat;
    mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M10 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-8l-2-2zm2 6h2v3h3v2h-3v3h-2v-3H9v-2h3v-3z'/%3E%3C/svg%3E") center / contain no-repeat;
  }
  .selected-title-wrap {
    min-width: 0;
    display: grid;
    gap: 4px;
  }
  .selected-title {
    margin: 0;
    font-size: 15px;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .selected-subtitle {
    margin: 0;
    font-size: 12px;
    color: #bdbdbd;
  }
  .selected-actions {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 8px;
    margin-top: 8px;
  }
  .selected-startup-picker {
    margin-top: 8px;
    display: grid;
    gap: 6px;
  }
  .selected-startup-picker label {
    font-size: 11px;
    color: #bababa;
    text-transform: uppercase;
    letter-spacing: 0.35px;
  }
  .selected-actions button {
    min-height: 36px;
    font-size: 13px;
  }
  details.advanced {
    border: 1px dashed #3a3a3a;
    border-radius: 10px;
    padding: 8px;
    margin-top: 10px;
    background: #171717;
  }
  details.advanced summary {
    cursor: pointer;
    color: #fff;
    font-size: 13px;
    font-weight: 600;
  }
  .log-dropdown {
    margin-top: 0;
  }
  .log-dropdown #status {
    margin-top: 8px;
  }
  #entryFile {
    width: 100%;
    border: 1px solid #3a3a3a;
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 14px;
    background: #1a1a1a;
    color: #fff;
    margin-top: 8px;
  }
  #status {
    min-height: 120px;
    max-height: 240px;
    overflow: auto;
    white-space: pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size: 12px;
    line-height: 1.45;
    border: 1px solid #2f2f2f;
    border-radius: 8px;
    background: #111;
    padding: 10px;
  }
  #status > div { padding: 3px 0; border-bottom: 1px solid #232323; }
  #status > div:last-child { border-bottom: 0; }
  #status .error { color: var(--error-color); }
  .sr-only {
    position: absolute !important;
    width: 1px;
    height: 1px;
    margin: -1px;
    padding: 0;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
    white-space: nowrap;
  }
  .empty-library {
    display: none;
    text-align: center;
    padding: 14px;
    color: #d3d3d3;
  }
  .empty-library.visible { display: block; }
  .game-edit-modal {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.85);
    display: none;
    align-items: center;
    justify-content: center;
    padding: 14px;
    z-index: 10000;
  }
  .game-edit-modal.open { display: flex; }
  .game-edit-dialog {
    width: min(920px, 96vw);
    border: 1px solid #3b3b3b;
    background: linear-gradient(180deg, #191919 0%, #161616 100%);
    border-radius: 16px;
    padding: 12px;
    display: grid;
    gap: 10px;
    max-height: calc(100dvh - 28px);
    overflow: auto;
  }
  .game-edit-head {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
    border-bottom: 1px solid #2c2c2c;
    padding-bottom: 8px;
  }
  .game-edit-head h3 { margin: 0; font-size: 16px; }
  .game-edit-close { width: auto; }
  .editor-shell {
    display: grid;
    grid-template-columns: minmax(0, 1fr) 220px;
    gap: 14px;
    align-items: stretch;
  }
  .game-edit-layout {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    justify-items: center;
  }
  .game-edit-name {
    display: grid;
    gap: 6px;
    width: min(560px, 100%);
    justify-items: center;
  }
  .game-edit-name label {
    font-size: 12px;
    color: #d0d0d0;
  }
  .game-edit-name input {
    width: min(420px, 100%);
    border: 1px solid #3a3a3a;
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 14px;
    background: #1a1a1a;
    color: #fff;
  }
  .game-edit-canvas-wrap,
  .game-edit-crop-wrap {
    border: 1px solid #343434;
    border-radius: 10px;
    background: #0f0f0f;
    padding: 8px;
    aspect-ratio: 1 / 1;
    display: block;
    position: relative;
    width: min(560px, 100%, calc(100dvh - 280px));
    max-height: calc(100dvh - 280px);
    overflow: hidden;
  }
  #gameEditCropImage {
    width: 100%;
    height: 100%;
    object-fit: contain;
    border-radius: 8px;
    background: #0a0a0a;
    display: block;
    max-width: 100%;
    max-height: 100%;
  }
  .game-edit-crop-wrap .cropper-container {
    max-width: 100%;
    max-height: 100%;
    overflow: hidden;
  }
  .game-edit-crop-wrap.is-empty #gameEditCropImage {
    display: none;
  }
  .game-edit-empty-note {
    display: none;
    color: #c8c8c8;
    font-size: 14px;
    text-align: center;
    padding: 10px;
    border: 1px dashed #404040;
    border-radius: 10px;
    width: 100%;
    height: 100%;
    align-content: center;
  }
  .game-edit-crop-wrap.is-empty .game-edit-empty-note {
    display: grid;
  }
  .game-edit-side-panel {
    display: grid;
    gap: 10px;
    background: #151515;
    border: 1px solid #2b2b2b;
    border-radius: 10px;
    padding: 10px;
    align-self: center;
    justify-self: center;
    width: min(210px, 100%);
  }
  .preview-card {
    border-radius: 15px;
    overflow: hidden;
    background: transparent;
    border: 0;
  }
  .preview-square {
    width: 100%;
    border: 0;
    padding: 0;
    display: block;
    position: relative;
    background-color: #202938;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
  }
  .preview-square::after {
    content: "";
    display: block;
    padding-top: 100%;
  }
  .preview-empty::before {
    content: "No image";
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 13px;
    color: #d8deeb;
    background: rgba(0, 0, 0, 0.25);
    border-radius: 999px;
    padding: 3px 8px;
  }
  .preview-edit-pill {
    position: absolute;
    right: 8px;
    bottom: 8px;
    border: 1px solid #444;
    background: rgba(16, 16, 16, 0.85);
    color: #fff;
    border-radius: 999px;
    font-size: 11px;
    padding: 4px 8px;
  }
  .preview-info {
    background: #181818;
    padding: 10px;
    display: grid;
    gap: 8px;
  }
  .preview-title {
    margin: 0;
    color: #fff;
    font-size: 16px;
    text-align: center;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    min-height: 40px;
  }
  .preview-actions {
    display: flex;
    justify-content: center;
    gap: 8px;
  }
  .preview-actions button {
    width: 100%;
    font-size: 12px;
    padding: 6px 8px;
    border-radius: 6px;
    background: #202020;
    border-color: #333;
    cursor: default;
  }
  .preview-actions .danger {
    color: #ffbcbc;
  }
  .game-edit-buttons {
    display: grid;
    grid-template-columns: 1fr;
    gap: 8px;
  }
  .game-edit-buttons button[data-role="save"] {
    background: #2a2a2a;
    border-color: #424242;
  }
  .game-edit-buttons button[data-role="save"]:hover:not(:disabled) {
    background: #343434;
  }
  #removeGameEditImage { color: #ffd7bc; }
  .confirm-modal {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10100;
    background: rgba(6, 8, 12, 0.72);
  }
  .confirm-modal.open {
    display: flex;
  }
  .confirm-dialog {
    width: min(92vw, 560px);
    background: #141414;
    border: 1px solid #2e2e2e;
    border-radius: 14px;
    box-shadow: 0 26px 60px rgba(0, 0, 0, 0.52);
    padding: 18px;
    display: grid;
    gap: 12px;
  }
  .confirm-dialog h3 {
    margin: 0;
    font-size: 20px;
  }
  .confirm-dialog p {
    margin: 0;
    color: #d6d6d6;
    line-height: 1.45;
  }
  #updatePromptMessage {
    white-space: pre-line;
  }
  .confirm-dialog .actions {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: flex-end;
  }
  .confirm-dialog .actions button[data-variant="replace"] {
    background: #28333a;
    border-color: #435865;
  }
  .replace-target-dialog {
    width: min(96vw, 760px);
    max-height: calc(100dvh - 32px);
  }
  .replace-target-list {
    max-height: 56dvh;
    overflow: auto;
    border: 1px solid #2f2f2f;
    border-radius: 12px;
    background: #141414;
    padding: 20px;
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr));
    grid-auto-rows: max-content;
    gap: 14px;
    align-content: start;
    scrollbar-width: thin;
    scrollbar-color: #3a3a3a #151515;
  }
  .replace-target-list::-webkit-scrollbar {
    width: 11px;
    height: 11px;
  }
  .replace-target-list::-webkit-scrollbar-track {
    background: #151515;
    border-radius: 999px;
  }
  .replace-target-list::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #4a4a4a 0%, #2f2f2f 100%);
    border: 2px solid #151515;
    border-radius: 999px;
  }
  .replace-target-list::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #5b5b5b 0%, #3a3a3a 100%);
  }
  .replace-target-card {
    cursor: pointer;
    transform: none !important;
  }
  .replace-target-card:hover {
    transform: none !important;
  }
  .confirm-dialog input[type="text"] {
    width: 100%;
    border: 1px solid #3a3a3a;
    border-radius: 8px;
    padding: 9px 10px;
    font-size: 14px;
    background: #1a1a1a;
    color: #fff;
  }
  .bundle-preview-dialog {
    width: min(96vw, 900px);
    max-height: calc(100dvh - 34px);
    overflow: auto;
  }
  .bundle-preview-summary {
    font-size: 14px;
  }
  .bundle-preview-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }
  .bundle-preview-toolbar button {
    width: auto;
    padding: 8px 12px;
  }
  .bundle-preview-list {
    display: grid;
    gap: 8px;
    max-height: 48dvh;
    overflow: auto;
    border: 1px solid #2b2b2b;
    border-radius: 10px;
    background: #121212;
    padding: 10px;
  }
  .bundle-preview-row {
    display: grid;
    grid-template-columns: auto 70px minmax(0, 1fr) 180px;
    gap: 10px;
    align-items: center;
    background: #181818;
    border: 1px solid #2c2c2c;
    border-radius: 9px;
    padding: 10px;
  }
  .bundle-preview-row.is-invalid {
    border-color: #5b3b3b;
    background: #211616;
  }
  .bundle-preview-row input[type="checkbox"] {
    width: 16px;
    height: 16px;
    margin: 0;
  }
  .bundle-preview-main {
    display: grid;
    gap: 5px;
    min-width: 0;
  }
  .bundle-preview-thumb {
    width: 70px;
    height: 70px;
    border-radius: 10px;
    border: 1px solid #2f2f2f;
    background-color: #202938;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    display: grid;
    place-items: center;
    font-size: 11px;
    color: #ced6e6;
    text-transform: uppercase;
    letter-spacing: 0.4px;
  }
  .bundle-preview-thumb.no-thumb::before {
    content: "No Image";
  }
  .bundle-preview-title {
    margin: 0;
    font-size: 14px;
    font-weight: 600;
    color: #fff;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .bundle-preview-meta {
    margin: 0;
    color: #c7c7c7;
    font-size: 12px;
    line-height: 1.4;
  }
  .bundle-preview-status {
    margin: 0;
    font-size: 12px;
    color: #dbd2b1;
  }
  .bundle-preview-status.error {
    color: #ffb9b9;
  }
  .bundle-preview-controls {
    display: grid;
    gap: 6px;
  }
  .bundle-preview-controls-hint {
    margin: 0;
    color: #bfc5d2;
    font-size: 12px;
  }
  .bundle-preview-controls select {
    width: 100%;
    border: 1px solid #3a3a3a;
    border-radius: 7px;
    padding: 7px 8px;
    background: #1a1a1a;
    color: #fff;
  }
  .bundle-preview-plan {
    margin: 0;
    color: #d6d6d6;
    font-size: 13px;
  }
  @media (max-width: 760px) {
    .bundle-preview-row {
      grid-template-columns: auto 58px minmax(0, 1fr);
      align-items: start;
    }
    .bundle-preview-thumb {
      width: 58px;
      height: 58px;
    }
    .bundle-preview-controls {
      grid-column: 2 / -1;
    }
  }
  .drag-gap {
    width: 100%;
    border-radius: 12px;
    border: 2px dashed #5f7ec8;
    background: rgba(63, 93, 165, 0.18);
    min-height: 120px;
  }
  .reorder-ghost {
    position: fixed;
    z-index: 7000;
    pointer-events: none;
    opacity: 0.95;
    transform-origin: top left;
    box-shadow: 0 28px 52px rgba(0, 0, 0, 0.5);
  }
  .game-item.row-wrap-down {
    animation: rowWrapDown 230ms cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  .game-item.row-wrap-up {
    animation: rowWrapUp 230ms cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  @keyframes rowWrapDown {
    0% { transform: translateX(44px); opacity: 0.2; }
    55% { opacity: 0.7; }
    100% { transform: translateX(0); opacity: 1; }
  }
  @keyframes rowWrapUp {
    0% { transform: translateX(-44px); opacity: 0.2; }
    55% { opacity: 0.7; }
    100% { transform: translateX(0); opacity: 1; }
  }
  .drag-drop-overlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(5, 7, 12, 0.76);
    backdrop-filter: blur(2px);
    z-index: 5000;
    pointer-events: none;
  }
  .drag-drop-overlay.open {
    display: flex;
  }
  .drag-drop-overlay-card {
    width: min(92vw, 640px);
    border: 2px dashed #6c88c9;
    border-radius: 18px;
    background: rgba(17, 21, 31, 0.93);
    padding: 28px 24px;
    text-align: center;
    color: #f3f6ff;
    box-shadow: 0 24px 56px rgba(0, 0, 0, 0.45);
  }
  .drag-drop-overlay-card p {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
    letter-spacing: 0.2px;
  }
  .ops-modal {
    position: fixed;
    inset: 0;
    z-index: 10020;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.25s ease, background 0.25s ease;
  }
  .ops-modal.open {
    opacity: 1;
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.45);
  }
  .ops-sheet {
    width: min(1120px, 96vw);
    max-height: min(88dvh, 900px);
    margin: 0 auto;
    border: 1px solid #323232;
    border-radius: 16px;
    background: #171717;
    transform: translateY(40px);
    opacity: 0;
    transition: transform 0.28s ease;
    display: grid;
    grid-template-columns: minmax(0, 1fr) minmax(300px, 340px);
    gap: 16px;
    padding: 16px;
    overflow: auto;
  }
  .ops-modal.open .ops-sheet {
    transform: translateY(0);
    opacity: 1;
  }
  .ops-actions {
    display: grid;
    gap: 12px;
    align-content: start;
  }
  .ops-head {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
  }
  .ops-head h3 {
    margin: 0;
    font-size: 19px;
  }
  .ops-head p {
    margin: 4px 0 0;
    color: #c0c0c0;
    font-size: 13px;
  }
  #closeOpsModal {
    width: 34px;
    height: 34px;
    border-radius: 999px;
    padding: 0;
    font-size: 18px;
    line-height: 1;
  }
  .ops-controls {
    display: grid;
    gap: 10px;
  }
  .ops-group {
    border: 1px solid #2c2c2c;
    border-radius: 12px;
    background: #121212;
    padding: 12px;
    display: grid;
    gap: 8px;
  }
  .ops-group h4 {
    margin: 0;
    font-size: 14px;
    color: #f2f2f2;
  }
  .ops-group p {
    margin: 0;
    font-size: 12px;
    color: #bebebe;
    line-height: 1.35;
  }
  .ops-row {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px;
  }
  .ops-row.one {
    grid-template-columns: 1fr;
  }
  .ops-controls button {
    width: 100%;
    min-height: 40px;
  }
  .ops-progress {
    border: 1px solid #2b2b2b;
    border-radius: 12px;
    background: #101010;
    padding: 14px;
    display: grid;
    gap: 10px;
    align-content: start;
    justify-items: center;
  }
  .ops-progress h4 {
    margin: 0;
    font-size: 15px;
    color: #d7d7d7;
    font-weight: 600;
  }
  .ops-progress p {
    margin: 0;
    font-size: 12px;
    color: #bdbdbd;
    text-align: center;
  }
  @media (max-width: 980px) {
    body {
      overflow: auto;
    }
    .workspace {
      grid-template-columns: 1fr;
      overflow: visible;
    }
    .container {
      grid-template-columns: repeat(3, minmax(0, 1fr));
      max-height: none;
      min-height: 260px;
      height: auto;
      overflow: visible;
    }
    .side-panel {
      overflow: visible;
    }
    .editor-shell {
      grid-template-columns: 1fr;
    }
    .game-edit-side-panel {
      width: min(560px, 100%);
      border: 0;
      background: transparent;
      padding: 0;
    }
    .preview-card {
      display: none;
    }
    .game-edit-buttons {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }
  @media (max-width: 1220px) {
    .workspace {
      grid-template-columns: minmax(200px, 240px) minmax(0, 1fr) minmax(230px, 280px);
      gap: 12px;
    }
    .replace-target-dialog {
      width: min(96vw, 680px);
    }
    .replace-target-list {
      padding: 14px;
      gap: 12px;
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }
  }
  @media (max-width: 740px) {
    header {
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
      padding: 15px;
    }
    header nav {
      flex-wrap: wrap;
      gap: 10px;
    }
    .container {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }
  @media (max-width: 480px) {
    .container {
      grid-template-columns: 1fr;
    }
    .game-edit-canvas-wrap,
    .game-edit-crop-wrap {
      width: min(100%, calc(100dvh - 340px));
      max-height: calc(100dvh - 340px);
    }
  }
  @media (max-height: 900px) and (min-width: 981px) {
    .workspace {
      gap: 12px;
      margin-bottom: 8px;
    }
    .side-panel {
      gap: 8px;
    }
    .panel-block {
      padding: 10px;
    }
    .panel-block h3 {
      margin-bottom: 8px;
      font-size: 14px;
    }
    .control-stack {
      gap: 6px;
    }
    .control-stack button,
    .control-stack select {
      padding-top: 8px;
      padding-bottom: 8px;
      font-size: 13px;
    }
    .selected-stats {
      gap: 6px;
      margin-top: 6px;
    }
    .metric {
      padding: 7px 8px;
    }
    .metric-label {
      font-size: 11px;
    }
    .metric-value {
      font-size: 12px;
    }
    #status {
      max-height: 170px;
    }
  }
  @media (max-width: 860px) {
    .ops-sheet {
      grid-template-columns: 1fr;
      gap: 12px;
      max-height: 92dvh;
    }
    .ops-row {
      grid-template-columns: 1fr;
    }
    .replace-target-list {
      grid-template-columns: 1fr;
    }
  }
</style>
</head>
<body>
<header>
  <div class="logo">CBGames - Offline Launcher</div>
</header>
<div id="dragDropOverlay" class="drag-drop-overlay" aria-hidden="true">
  <div class="drag-drop-overlay-card">
    <p id="dragDropOverlayText">Drop ZIP files to import</p>
  </div>
</div>

<div class="search-bar">
  <input id="gameSearch" type="search" placeholder="Search for games...">
</div>

<div class="workspace">
  <aside class="side-panel">
    <section class="panel-block">
      <button id="openOpsModal" type="button" class="ops-open-cta">
        Manage Games
      </button>
      <div class="legacy-launch-actions" aria-hidden="true">
        <button id="launch">Launch Selected</button>
        <button id="deleteGame">Delete Selected</button>
      </div>
    </section>
    <section class="panel-block">
      <details class="advanced log-dropdown">
        <summary>Activity Log</summary>
        <div id="status" aria-live="polite"></div>
      </details>
    </section>
  </aside>
  <div class="games-column">
    <div id="gamesGrid" class="container"></div>
    <p id="emptyLibrary" class="empty-library visible">No saved games yet.</p>
  </div>
  <aside class="side-panel">
    <section class="panel-block">
      <h3>Storage Overview</h3>
      <div class="storage-visual">
        <div id="storageDonut" class="storage-donut" aria-hidden="true">
          <div class="storage-donut-center">
            <strong id="storageUsedPct">0%</strong>
            <span>Used</span>
          </div>
        </div>
        <div class="storage-breakdown">
          <div class="metric">
            <span class="metric-label">Games</span>
            <strong id="libraryCount" class="metric-value">0</strong>
          </div>
          <div class="metric">
            <span class="metric-label">Saved by Launcher</span>
            <strong id="libraryBytes" class="metric-value">0 B</strong>
          </div>
          <div class="metric">
            <span class="metric-label">Browser Usage</span>
            <strong id="quotaUsage" class="metric-value">Checking...</strong>
          </div>
        </div>
      </div>
    </section>
    <section class="panel-block">
      <h3>Selected Game</h3>
      <div class="selected-summary">
        <div id="selectedThumb" class="selected-thumb no-thumb" aria-hidden="true"></div>
        <div class="selected-title-wrap">
          <p id="gameMeta" class="selected-title">No saved game selected.</p>
          <p id="selectedSubtext" class="selected-subtitle">Pick a game and press Play.</p>
        </div>
      </div>
      <div class="selected-actions">
        <button id="selectedPlayBtn" type="button">Play</button>
        <button id="selectedEditBtn" type="button">Edit</button>
        <button id="selectedDeleteBtn" type="button">Delete</button>
      </div>
      <div class="selected-startup-picker">
        <label for="entryFile">Startup File</label>
        <select id="entryFile"></select>
      </div>
      <div class="selected-stats">
        <div class="metric"><span class="metric-label">Saved Size</span><strong id="selectedSize" class="metric-value">-</strong></div>
        <div class="metric"><span class="metric-label">Startup</span><strong id="selectedEntry" class="metric-value">-</strong></div>
        <div class="metric"><span class="metric-label">Last Imported</span><strong id="selectedImported" class="metric-value">-</strong></div>
      </div>
    </section>
  </aside>
</div>
<div id="opsModal" class="ops-modal" aria-hidden="true">
  <div class="ops-sheet" role="dialog" aria-modal="true" aria-labelledby="opsModalTitle">
    <div class="ops-actions">
      <div class="ops-head">
        <div>
          <h3 id="opsModalTitle">Game Imports & Downloads</h3>
          <p>Add games, check updates, and manage backups in one place.</p>
        </div>
        <button id="closeOpsModal" type="button" aria-label="Close">Ã—</button>
      </div>
      <div class="ops-controls">
        <section class="ops-group">
          <h4>Add Games</h4>
          <p>Bring in individual games from local ZIP files or directly from GitHub.</p>
          <div class="ops-row">
            <button id="importZip">Import ZIP</button>
            <button id="importGithub" type="button">Import from GitHub</button>
          </div>
          <div class="ops-row one">
            <button id="replaceZipSelected" type="button">Replace Game with ZIP</button>
          </div>
        </section>
        <section class="ops-group">
          <h4>Updates</h4>
          <p>Scan every GitHub-linked game and choose which updates to install.</p>
          <div class="ops-row one">
            <button id="checkGithubUpdate" type="button">Check All GitHub Updates</button>
          </div>
          <p id="updateScanStatus">Update status: Not checked yet.</p>
        </section>
        <section class="ops-group">
          <h4>Backup & Restore</h4>
          <p>Export your whole library, import a bundle, or save error logs for troubleshooting.</p>
          <div class="ops-row">
            <button id="exportAllGames" type="button">Export All Games</button>
            <button id="importBundle" type="button">Import Bundle</button>
          </div>
          <div class="ops-row one">
            <button id="exportErrorLogs" type="button">Export Error Logs</button>
          </div>
        </section>
      </div>
    </div>
    <div class="ops-progress">
      <h4>Progress</h4>
      <div id="workProgress" class="work-progress" aria-live="polite">
        <div id="workProgressCircle" class="work-progress-circle">
          <div id="workProgressValue" class="work-progress-value">0%</div>
        </div>
        <div id="workProgressLabel" class="work-progress-label">Idle...</div>
      </div>
    </div>
  </div>
</div>
<select id="gameSelect" class="sr-only" aria-hidden="true" tabindex="-1"></select>

<input id="zipInput" type="file" accept=".zip,application/zip,application/x-zip-compressed" hidden>
<input id="replaceZipInput" type="file" accept=".zip,application/zip,application/x-zip-compressed" hidden>
<input id="bundleInput" type="file" accept=".zip,application/zip,application/x-zip-compressed" hidden>
<input id="gameEditImageInput" type="file" accept="image/*" hidden>
<div id="importConflictModal" class="confirm-modal" aria-hidden="true">
  <div class="confirm-dialog" role="dialog" aria-modal="true" aria-labelledby="importConflictTitle" aria-describedby="importConflictMessage">
    <h3 id="importConflictTitle">Game Already Exists</h3>
    <p id="importConflictMessage"></p>
    <div class="actions">
      <button id="importConflictCancel" type="button">Cancel</button> 
      <button id="importConflictSeparate" type="button">Import Separately</button>
      <button id="importConflictReplace" type="button" data-variant="replace">Replace Contents</button>
    </div>
  </div>
</div>
<div id="githubImportModal" class="confirm-modal" aria-hidden="true">
  <div class="confirm-dialog" role="dialog" aria-modal="true" aria-labelledby="githubImportTitle" aria-describedby="githubImportHint">
    <h3 id="githubImportTitle">Import from GitHub</h3>
    <p id="githubImportHint">Enter `owner/repo`, a GitHub repo URL, or a direct `.zip` URL.</p>
    <input id="githubImportInput" type="text" autocomplete="off" spellcheck="false" placeholder="e.g. landgreen/n-gon or https://github.com/owner/repo">
    <div class="actions">
      <button id="githubImportCancel" type="button">Cancel</button>
      <button id="githubImportSubmit" type="button" data-variant="replace">Import</button>
    </div>
  </div>
</div>
<div id="replaceTargetModal" class="confirm-modal" aria-hidden="true">
  <div class="confirm-dialog replace-target-dialog" role="dialog" aria-modal="true" aria-labelledby="replaceTargetTitle" aria-describedby="replaceTargetHint">
    <h3 id="replaceTargetTitle">Replace Game with ZIP</h3>
    <p id="replaceTargetHint">Choose which game should be replaced. Existing thumbnail and custom title are kept.</p>
    <div id="replaceTargetList" class="replace-target-list"></div>
    <div class="actions">
      <button id="replaceTargetCancel" type="button">Cancel</button>
      <button id="replaceTargetChoose" type="button" data-variant="replace">Choose Game</button>
    </div>
  </div>
</div>
<div id="updatePromptModal" class="confirm-modal" aria-hidden="true">
  <div class="confirm-dialog" role="dialog" aria-modal="true" aria-labelledby="updatePromptTitle" aria-describedby="updatePromptMessage">
    <h3 id="updatePromptTitle">Game Update Available</h3>
    <p id="updatePromptMessage"></p>
    <div class="actions">
      <button id="updatePromptStop" type="button">Stop Checking</button>
      <button id="updatePromptSkip" type="button">Skip This Game</button>
      <button id="updatePromptInstall" type="button" data-variant="replace">Update Game</button>
    </div>
  </div>
</div>
<div id="bundlePreviewModal" class="confirm-modal" aria-hidden="true">
  <div class="confirm-dialog bundle-preview-dialog" role="dialog" aria-modal="true" aria-labelledby="bundlePreviewTitle" aria-describedby="bundlePreviewSummary">
    <h3 id="bundlePreviewTitle">Bundle Import Preview</h3>
    <p id="bundlePreviewSummary" class="bundle-preview-summary"></p>
    <div class="bundle-preview-toolbar">
      <button id="bundlePreviewSelectAll" type="button">Select All</button>
      <button id="bundlePreviewSelectNone" type="button">Select None</button>
      <button id="bundlePreviewConflictMode" type="button">Conflicts: Replace Existing</button>
      <button id="bundlePreviewIndividualMode" type="button">Per-Game Actions: Off</button>
    </div>
    <div id="bundlePreviewList" class="bundle-preview-list"></div>
    <p id="bundlePreviewPlan" class="bundle-preview-plan"></p>
    <div class="actions">
      <button id="bundlePreviewCancel" type="button">Cancel</button>
      <button id="bundlePreviewImport" type="button" data-variant="replace">Import Selected</button>
    </div>
  </div>
</div>
<div id="gameEditModal" class="game-edit-modal" aria-hidden="true">
  <div class="game-edit-dialog">
    <div class="game-edit-head">
      <h3>Edit</h3>
      <button id="closeGameEditModal" class="game-edit-close" type="button">Close</button>
    </div>
    <div class="editor-shell">
      <div class="game-edit-layout">
        <div class="game-edit-name">
          <label for="gameEditName">Game name</label>
          <input id="gameEditName" type="text" maxlength="120" autocomplete="off" spellcheck="false">
        </div>
        <div id="gameEditCropWrap" class="game-edit-crop-wrap is-empty">
          <img id="gameEditCropImage" alt="Game image crop preview">
          <div class="game-edit-empty-note">No image yet</div>
        </div>
      </div>
      <div class="game-edit-side-panel">
        <article class="preview-card" aria-label="Live card preview">
          <button id="gameEditPreviewThumb" class="preview-square preview-empty" type="button" aria-label="Preview thumbnail">
            <span id="gameEditPreviewBadges" class="game-badges" aria-hidden="true"></span>
            <span class="game-edit-trigger" aria-hidden="true"></span>
          </button>
          <div class="preview-info">
            <p id="gameEditPreviewTitle" class="preview-title">Untitled game</p>
            <div class="preview-actions" aria-hidden="true">
              <button type="button">Play</button>
              <button type="button" class="danger">Delete</button>
            </div>
          </div>
        </article>
        <div class="game-edit-buttons">
          <button id="uploadGameEditImage" type="button">Choose Image</button>
          <button id="removeGameEditImage" type="button">Remove</button>
          <button id="saveGameEditChanges" type="button" data-role="save">Save Changes</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="./lib/cropper.min.js"></script>
<script>
(() => {
  "use strict";

  const DB_NAME = "cbgamesOfflineZipDB";
  const DB_VERSION = 2; // DONT CHANGE THE DB VERSION
  const STORE_GAMES = "games";
  const STORE_FILES = "files";
  const STORE_SETTINGS = "settings";
  const STORE_ERROR_LOGS = "errorLogs";
  const SETTING_SELECTED_GAME = "selectedGameId";

  const VFS_ORIGIN = "https://loader.invalid/";
  const VFS_ORIGIN_URL = new URL(VFS_ORIGIN).origin;
  const UNITY_GPU_SAFE_MODE = true;
  const UNITY_FORCE_WEBGL1 = true;
  const UNITY_CLAMP_DEVICE_PIXEL_RATIO = 1;

  const importZipButton = document.getElementById("importZip");
  const replaceZipSelectedButton = document.getElementById("replaceZipSelected");
  const openOpsModalButton = document.getElementById("openOpsModal");
  const opsModal = document.getElementById("opsModal");
  const closeOpsModalButton = document.getElementById("closeOpsModal");
  const launchButton = document.getElementById("launch");
  const deleteGameButton = document.getElementById("deleteGame");
  const gameSelect = document.getElementById("gameSelect");
  const gameSearch = document.getElementById("gameSearch");
  const gamesGrid = document.getElementById("gamesGrid");
  const emptyLibrary = document.getElementById("emptyLibrary");
  const entrySelect = document.getElementById("entryFile");
  const zipInput = document.getElementById("zipInput");
  const replaceZipInput = document.getElementById("replaceZipInput");
  const bundleInput = document.getElementById("bundleInput");
  const exportAllGamesButton = document.getElementById("exportAllGames");
  const importBundleButton = document.getElementById("importBundle");
  const importGithubButton = document.getElementById("importGithub");
  const checkGithubUpdateButton = document.getElementById("checkGithubUpdate");
  const updateScanStatus = document.getElementById("updateScanStatus");
  const exportErrorLogsButton = document.getElementById("exportErrorLogs");
  const workProgress = document.getElementById("workProgress");
  const workProgressCircle = document.getElementById("workProgressCircle");
  const workProgressValue = document.getElementById("workProgressValue");
  const workProgressLabel = document.getElementById("workProgressLabel");
  const dragDropOverlay = document.getElementById("dragDropOverlay");
  const dragDropOverlayText = document.getElementById("dragDropOverlayText");
  const importConflictModal = document.getElementById("importConflictModal");
  const importConflictMessage = document.getElementById("importConflictMessage");
  const importConflictReplaceButton = document.getElementById("importConflictReplace");
  const importConflictSeparateButton = document.getElementById("importConflictSeparate");
  const importConflictCancelButton = document.getElementById("importConflictCancel");
  const githubImportModal = document.getElementById("githubImportModal");
  const githubImportInput = document.getElementById("githubImportInput");
  const githubImportSubmitButton = document.getElementById("githubImportSubmit");
  const githubImportCancelButton = document.getElementById("githubImportCancel");
  const replaceTargetModal = document.getElementById("replaceTargetModal");
  const replaceTargetList = document.getElementById("replaceTargetList");
  const replaceTargetChooseButton = document.getElementById("replaceTargetChoose");
  const replaceTargetCancelButton = document.getElementById("replaceTargetCancel");
  const updatePromptModal = document.getElementById("updatePromptModal");
  const updatePromptMessage = document.getElementById("updatePromptMessage");
  const updatePromptInstallButton = document.getElementById("updatePromptInstall");
  const updatePromptSkipButton = document.getElementById("updatePromptSkip");
  const updatePromptStopButton = document.getElementById("updatePromptStop");
  const bundlePreviewModal = document.getElementById("bundlePreviewModal");
  const bundlePreviewSummary = document.getElementById("bundlePreviewSummary");
  const bundlePreviewList = document.getElementById("bundlePreviewList");
  const bundlePreviewPlan = document.getElementById("bundlePreviewPlan");
  const bundlePreviewSelectAllButton = document.getElementById("bundlePreviewSelectAll");
  const bundlePreviewSelectNoneButton = document.getElementById("bundlePreviewSelectNone");
  const bundlePreviewConflictModeButton = document.getElementById("bundlePreviewConflictMode");
  const bundlePreviewIndividualModeButton = document.getElementById("bundlePreviewIndividualMode");
  const bundlePreviewCancelButton = document.getElementById("bundlePreviewCancel");
  const bundlePreviewImportButton = document.getElementById("bundlePreviewImport");
  const gameEditImageInput = document.getElementById("gameEditImageInput");
  const gameEditModal = document.getElementById("gameEditModal");
  const closeGameEditModalButton = document.getElementById("closeGameEditModal");
  const gameEditNameInput = document.getElementById("gameEditName");
  const uploadGameEditImageButton = document.getElementById("uploadGameEditImage");
  const saveGameEditChangesButton = document.getElementById("saveGameEditChanges");
  const removeGameEditImageButton = document.getElementById("removeGameEditImage");
  const gameEditCropWrap = document.getElementById("gameEditCropWrap");
  const gameEditCropImage = document.getElementById("gameEditCropImage");
  const gameEditPreviewThumb = document.getElementById("gameEditPreviewThumb");
  const gameEditPreviewBadges = document.getElementById("gameEditPreviewBadges");
  const gameEditPreviewTitle = document.getElementById("gameEditPreviewTitle");

  const gameMeta = document.getElementById("gameMeta");
  const selectedSubtext = document.getElementById("selectedSubtext");
  const selectedThumb = document.getElementById("selectedThumb");
  const selectedPlayButton = document.getElementById("selectedPlayBtn");
  const selectedEditButton = document.getElementById("selectedEditBtn");
  const selectedDeleteButton = document.getElementById("selectedDeleteBtn");
  const selectedImported = document.getElementById("selectedImported");
  const selectedSize = document.getElementById("selectedSize");
  const selectedEntry = document.getElementById("selectedEntry");
  const libraryCount = document.getElementById("libraryCount");
  const libraryBytes = document.getElementById("libraryBytes");
  const quotaUsage = document.getElementById("quotaUsage");
  const storageDonut = document.getElementById("storageDonut");
  const storageUsedPct = document.getElementById("storageUsedPct");

  const statusBox = document.getElementById("status");
  const reorderAnimations = new WeakMap();
  const BADGE_RESCAN_SECRET_PARAM = "__cbgames_rebadge";

  const state = {
    db: null,
    gamesById: new Map(),
    selectedGameId: null,
    objectUrls: new Map(),
    objectUrlHost: window,
    activeEntryPath: null,
    playerWindow: null,
    dragDepth: 0,
    suppressCardClickUntil: 0,
    searchQuery: "",
    reorder: {
      active: false,
      pointerId: null,
      holdTimer: 0,
      holdMoveListener: null,
      startTarget: null,
      holdStartX: 0,
      holdStartY: 0,
      pointerX: 0,
      pointerY: 0,
      sourceGameId: "",
      sourceElement: null,
      placeholder: null,
      ghost: null,
      pointerOffsetX: 0,
      pointerOffsetY: 0
    },
    gameEditEditor: {
      gameId: null,
      image: null,
      sourceUrl: null,
      cropper: null,
      previewFrame: 0
    },
    actionInProgress: false,
    importConflictResolver: null,
    githubImportResolver: null,
    replaceTargetSelectedId: "",
    updatePromptResolver: null,
    bundlePreviewResolver: null,
    bundlePreviewDraft: null,
    badgeRescanCompleted: false
  };

  function log(message, type = "info") {
    const line = document.createElement("div");
    if (type === "error") {
      line.className = "error";
    }
    const timestamp = new Date().toLocaleTimeString();
    line.textContent = "[" + timestamp + "] " + message;
    statusBox.append(line);
    statusBox.scrollTop = statusBox.scrollHeight;
  }

  function setUpdateScanStatus(text) {
    if (!updateScanStatus) {
      return;
    }
    const message = String(text || "").trim();
    updateScanStatus.textContent = "Update status: " + (message || "Not checked yet.");
  }

  function normalizePath(path) {
    return String(path)
      .replace(/\\/g, "/")
      .replace(/^\/+/, "")
      .replace(/\/+/g, "/");
  }

  function shouldRunSecretBadgeRescan() {
    try {
      const params = new URLSearchParams(window.location.search || "");
      const raw = String(params.get(BADGE_RESCAN_SECRET_PARAM) || "").trim().toLowerCase();
      return raw === "1" || raw === "true" || raw === "yes" || raw === "on";
    } catch {
      return false;
    }
  }

  function dirnamePath(path) {
    const normalized = normalizePath(path);
    const idx = normalized.lastIndexOf("/");
    if (idx === -1) {
      return "";
    }
    return normalized.slice(0, idx);
  }

  function toVirtualUrl(path) {
    const normalized = normalizePath(path);
    const encoded = normalized.split("/").map(encodeURIComponent).join("/");
    return VFS_ORIGIN + encoded;
  }

  function formatBytes(value) {
    const bytes = Number(value) || 0;
    if (bytes === 0) {
      return "0 B";
    }
    const units = ["B", "KB", "MB", "GB", "TB"]; // if anyone has petabytes -_-
    const exponent = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
    const scaled = bytes / Math.pow(1024, exponent);
    return scaled.toFixed(scaled >= 100 || exponent === 0 ? 0 : 1) + " " + units[exponent];
  }

  function formatDate(ts) {
    if (!ts) {
      return "unknown";
    }
    return new Date(ts).toLocaleString();
  }

  function makeId() {
    if (window.crypto && typeof window.crypto.randomUUID === "function") {
      return window.crypto.randomUUID();
    }
    return "game-" + Date.now() + "-" + Math.random().toString(16).slice(2);
  }

  function deriveGameName(fileName) {
    const cleaned = String(fileName || "")
      .replace(/\.zip$/i, "")
      .replace(/[_-]+/g, " ")
      .trim();
    return cleaned || "Imported Game";
  }

  function normalizeGameIdentity(value) {
    return String(value || "")
      .replace(/\.zip$/i, "")
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "");
  }

  function detectUnityByPaths(paths) {
    for (const rawPath of paths || []) {
      const path = normalizePath(rawPath).toLowerCase();
      if (!path) {
        continue;
      }
      if (
        /(^|\/)unityloader\.js$/.test(path) ||
        /(^|\/)unityprogress\.js$/.test(path) ||
        /(^|\/)build\/.*\.(data|wasm|mem|unityweb|loader\.js|framework\.js|json)$/.test(path) ||
        /(^|\/)templatedata\//.test(path)
      ) {
        return true;
      }
    }
    return false;
  }

  function detectUnityByHtmlText(text) {
    if (typeof text !== "string" || !text) {
      return false;
    }
    return /createUnityInstance\s*\(|UnityLoader\.instantiate\s*\(|unityInstance/i.test(text);
  }

  function detectFlashByPaths(paths) {
    for (const rawPath of paths || []) {
      const path = normalizePath(rawPath).toLowerCase();
      if (/(^|\/)[^/]+\.swf$/.test(path)) {
        return true;
      }
    }
    return false;
  }

  function toHttpUrl(value) {
    if (typeof value !== "string" || !value.trim()) {
      return "";
    }
    try {
      const parsed = new URL(value.trim());
      if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
        return "";
      }
      return parsed.href;
    } catch {
      return "";
    }
  }

  function normalizeGithubSource(raw) {
    const source = raw && typeof raw === "object" ? raw : null;
    if (!source) {
      return null;
    }
    const provider = String(source.provider || "").toLowerCase();
    if (provider === "github-release") {
      const owner = String(source.owner || "").trim();
      const repo = String(source.repo || "").trim();
      const downloadUrl = toHttpUrl(source.downloadUrl || "");
      if (!owner || !repo || !downloadUrl) {
        return null;
      }
      return {
        provider,
        owner,
        repo,
        releaseTag: String(source.releaseTag || ""),
        releaseId: Number(source.releaseId) || 0,
        assetId: Number(source.assetId) || 0,
        assetName: String(source.assetName || ""),
        assetUpdatedAt: Number(source.assetUpdatedAt) || 0,
        downloadUrl,
        etag: String(source.etag || ""),
        lastModified: String(source.lastModified || ""),
        lastCheckedAt: Number(source.lastCheckedAt) || 0
      };
    }
    if (provider === "zip-url") {
      const url = toHttpUrl(source.url || "");
      if (!url) {
        return null;
      }
      return {
        provider,
        url,
        etag: String(source.etag || ""),
        lastModified: String(source.lastModified || ""),
        lastCheckedAt: Number(source.lastCheckedAt) || 0
      };
    }
    if (provider === "github-tree") {
      const owner = String(source.owner || "").trim();
      const repo = String(source.repo || "").trim();
      const branch = String(source.branch || "").trim();
      const treeSha = String(source.treeSha || "").trim();
      if (!owner || !repo || !branch || !treeSha) {
        return null;
      }
      return {
        provider,
        owner,
        repo,
        branch,
        treeSha,
        lastCheckedAt: Number(source.lastCheckedAt) || 0
      };
    }
    return null;
  }

  function parseGithubRepoRef(input) {
    const raw = String(input || "").trim();
    if (!raw) {
      return null;
    }
    if (/^[A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+$/.test(raw)) {
      const parts = raw.split("/");
      return { owner: parts[0], repo: parts[1] };
    }
    try {
      const parsed = new URL(raw);
      if (parsed.hostname !== "github.com") {
        return null;
      }
      const pathParts = parsed.pathname.split("/").filter(Boolean);
      if (pathParts.length < 2) {
        return null;
      }
      return {
        owner: pathParts[0],
        repo: pathParts[1].replace(/\.git$/i, "")
      };
    } catch {
      return null;
    }
  }

  function normalizeHttpHeaderToken(value) {
    if (typeof value !== "string") {
      return "";
    }
    return value.trim();
  }

  function extractZipFileNameFromResponse(response, fallbackUrl) {
    const disposition = response && response.headers ? response.headers.get("content-disposition") : "";
    if (typeof disposition === "string" && disposition) {
      const encoded = disposition.match(/filename\*\s*=\s*UTF-8''([^;]+)/i);
      if (encoded && encoded[1]) {
        try {
          const value = decodeURIComponent(encoded[1].replace(/^"(.*)"$/, "$1"));
          if (value) {
            return value;
          }
        } catch {
          // ignore
        }
      }
      const plain = disposition.match(/filename\s*=\s*"?([^";]+)"?/i);
      if (plain && plain[1]) {
        return plain[1];
      }
    }
    try {
      const parsed = new URL(String(fallbackUrl || response.url || ""));
      const base = parsed.pathname.split("/").pop() || "";
      if (base) {
        return decodeURIComponent(base);
      }
    } catch {
      // ignore
    }
    return "download.zip";
  }

  async function fetchLatestGithubReleaseInfo(owner, repo, preferredAssetName) {
    const apiUrl = "https://api.github.com/repos/" + encodeURIComponent(owner) + "/" + encodeURIComponent(repo) + "/releases/latest";
    const response = await fetch(apiUrl, {
      cache: "no-store",
      headers: {
        Accept: "application/vnd.github+json"
      }
    });
    if (!response.ok) {
      const extra = response.status === 404 ? " No latest release found for this repo." : "";
      throw new Error("GitHub release lookup failed (" + response.status + ")." + extra);
    }
    const release = await response.json();
    const assets = Array.isArray(release.assets) ? release.assets : [];
    const preferredName = String(preferredAssetName || "").trim();
    let asset = null;
    if (preferredName) {
      asset = assets.find((entry) => String(entry && entry.name || "") === preferredName) || null;
    }
    if (!asset) {
      asset = assets.find((entry) => /\.zip$/i.test(String(entry && entry.name || ""))) || null;
    }
    if (!asset || !asset.browser_download_url) {
      throw new Error("Latest release has no .zip asset.");
    }
    const downloadUrl = toHttpUrl(asset.browser_download_url);
    if (!downloadUrl) {
      throw new Error("Latest release ZIP URL is invalid.");
    }
    return {
      provider: "github-release",
      owner,
      repo,
      releaseTag: String(release.tag_name || ""),
      releaseId: Number(release.id) || 0,
      assetId: Number(asset.id) || 0,
      assetName: String(asset.name || ""),
      assetUpdatedAt: Number(Date.parse(asset.updated_at || "")) || 0,
      downloadUrl,
      etag: "",
      lastModified: "",
      lastCheckedAt: Date.now()
    };
  }

  async function fetchGithubRepoTreeSnapshot(owner, repo, branchHint) {
    const branchCandidate = String(branchHint || "").trim();
    let branch = branchCandidate;
    if (!branch) {
      const repoApiUrl = "https://api.github.com/repos/" + encodeURIComponent(owner) + "/" + encodeURIComponent(repo);
      const repoResponse = await fetch(repoApiUrl, {
        cache: "no-store",
        headers: {
          Accept: "application/vnd.github+json"
        }
      });
      if (!repoResponse.ok) {
        throw new Error("GitHub repo lookup failed (" + repoResponse.status + ").");
      }
      const repoInfo = await repoResponse.json();
      branch = String(repoInfo.default_branch || "").trim();
      if (!branch) {
        throw new Error("Could not determine repo default branch.");
      }
    }
    const treeApiUrl =
      "https://api.github.com/repos/" +
      encodeURIComponent(owner) + "/" +
      encodeURIComponent(repo) +
      "/git/trees/" + encodeURIComponent(branch) + "?recursive=1";
    const treeResponse = await fetch(treeApiUrl, {
      cache: "no-store",
      headers: {
        Accept: "application/vnd.github+json"
      }
    });
    if (!treeResponse.ok) {
      throw new Error("GitHub tree lookup failed (" + treeResponse.status + ").");
    }
    const tree = await treeResponse.json();
    const treeSha = String(tree.sha || "").trim();
    const rawEntries = Array.isArray(tree.tree) ? tree.tree : [];
    const fileEntries = rawEntries
      .filter((entry) => entry && entry.type === "blob" && typeof entry.path === "string" && entry.path)
      .map((entry) => ({
        path: normalizePath(entry.path),
        url: toHttpUrl(entry.url || ""),
        sha: String(entry.sha || ""),
        size: Number(entry.size) || 0
      }))
      .filter((entry) => entry.path && entry.url);
    if (!treeSha) {
      throw new Error("GitHub tree response missing SHA.");
    }
    if (!fileEntries.length) {
      throw new Error("Repository has no file blobs to import.");
    }
    return {
      owner,
      repo,
      branch,
      treeSha,
      fileEntries
    };
  }

  async function buildZipFileFromGithubTree(snapshot, labelPrefix) {
    const entries = [];
    const files = Array.isArray(snapshot && snapshot.fileEntries) ? snapshot.fileEntries : [];
    const progressLabel = String(labelPrefix || "Downloading repo files");
    const hasKnownSizes = files.every((file) => Number.isFinite(file && file.size) && Number(file.size) >= 0);
    const totalBytes = hasKnownSizes
      ? files.reduce((sum, file) => sum + (Number(file.size) || 0), 0)
      : 0;
    let downloadedBytes = 0;
    const updateProgress = () => {
      if (totalBytes > 0) {
        setWorkProgress(
          progressLabel,
          downloadedBytes,
          totalBytes,
          {
            currentText: formatBytes(downloadedBytes),
            totalText: formatBytes(totalBytes)
          }
        );
      } else {
        setWorkProgress(progressLabel + " (" + formatBytes(downloadedBytes) + ")", 0, 0);
      }
    };
    updateProgress();
    for (let i = 0; i < files.length; i += 1) {
      const fileMeta = files[i];
      const blobResponse = await fetch(fileMeta.url, {
        cache: "no-store",
        headers: {
          Accept: "application/vnd.github.raw"
        }
      });
      if (!blobResponse.ok) {
        throw new Error("GitHub blob download failed (" + blobResponse.status + ") for " + fileMeta.path + ".");
      }
      let bytes = null;
      const rawType = String(blobResponse.headers.get("content-type") || "").toLowerCase();
      if (blobResponse.body && typeof blobResponse.body.getReader === "function" && rawType.indexOf("application/json") === -1) {
        const reader = blobResponse.body.getReader();
        const chunks = [];
        let loadedForFile = 0;
        let lastProgressReported = 0;
        while (true) {
          const part = await reader.read();
          if (part.done) {
            break;
          }
          const chunk = part.value;
          if (!chunk) {
            continue;
          }
          chunks.push(chunk);
          loadedForFile += chunk.byteLength;
          downloadedBytes += chunk.byteLength;
          if (downloadedBytes - lastProgressReported >= 131072) {
            updateProgress();
            lastProgressReported = downloadedBytes;
          }
        }
        bytes = new Uint8Array(loadedForFile);
        let offset = 0;
        for (const chunk of chunks) {
          bytes.set(chunk, offset);
          offset += chunk.byteLength;
        }
        updateProgress();
      } else {
        const fallbackResponse = rawType.indexOf("application/json") !== -1
          ? blobResponse
          : await fetch(fileMeta.url, {
              cache: "no-store",
              headers: {
                Accept: "application/vnd.github+json"
              }
            });
        if (!fallbackResponse.ok) {
          throw new Error("GitHub blob fallback failed (" + fallbackResponse.status + ") for " + fileMeta.path + ".");
        }
        const blobPayload = await fallbackResponse.json();
        const encoding = String(blobPayload.encoding || "").toLowerCase();
        if (encoding !== "base64") {
          throw new Error("Unsupported blob encoding for " + fileMeta.path + ".");
        }
        const content = String(blobPayload.content || "").replace(/\s+/g, "");
        bytes = base64ToBytes(content);
        downloadedBytes += bytes.byteLength;
        updateProgress();
      }
      entries.push({
        path: fileMeta.path,
        bytes
      });
    }
    const zipBlob = createZipStoreArchive(entries);
    const fileName = String(snapshot.repo || "github-repo") + "-" + String(snapshot.branch || "branch") + ".zip";
    return new File([zipBlob], fileName, { type: "application/zip" });
  }

  async function fetchZipHeadInfo(url) {
    const normalizedUrl = toHttpUrl(url);
    if (!normalizedUrl) {
      throw new Error("Invalid ZIP URL.");
    }
    const response = await fetch(normalizedUrl, { method: "HEAD", cache: "no-store" });
    if (!response.ok) {
      throw new Error("HEAD request failed (" + response.status + ").");
    }
    return {
      url: toHttpUrl(response.url || normalizedUrl) || normalizedUrl,
      etag: normalizeHttpHeaderToken(response.headers.get("etag") || ""),
      lastModified: normalizeHttpHeaderToken(response.headers.get("last-modified") || ""),
      contentLength: Number(response.headers.get("content-length")) || 0
    };
  }

  async function downloadZipFromUrl(url, label) {
    const normalizedUrl = toHttpUrl(url);
    if (!normalizedUrl) {
      throw new Error("Invalid ZIP URL.");
    }
    let expectedTotal = 0;
    try {
      const head = await fetchZipHeadInfo(normalizedUrl);
      expectedTotal = Number(head.contentLength) || 0;
    } catch {
      expectedTotal = 0;
    }
    const response = await fetch(normalizedUrl, { cache: "no-store" });
    if (!response.ok) {
      throw new Error("Download failed (" + response.status + ").");
    }
    const contentLength = Number(response.headers.get("content-length")) || 0;
    const total = contentLength || expectedTotal;
    const reader = response.body && typeof response.body.getReader === "function"
      ? response.body.getReader()
      : null;
    if (!reader) {
      const bytes = new Uint8Array(await response.arrayBuffer());
      setWorkProgress(label || "Downloading ZIP", bytes.byteLength, bytes.byteLength || 1);
      const fileName = extractZipFileNameFromResponse(response, normalizedUrl);
      const outName = /\.zip$/i.test(fileName) ? fileName : (fileName + ".zip");
      return {
        file: new File([bytes], outName, { type: "application/zip" }),
        resolvedUrl: toHttpUrl(response.url || normalizedUrl) || normalizedUrl,
        etag: normalizeHttpHeaderToken(response.headers.get("etag") || ""),
        lastModified: normalizeHttpHeaderToken(response.headers.get("last-modified") || "")
      };
    }

    let loaded = 0;
    let lastReported = 0;
    const chunks = [];
    setWorkProgress(label || "Downloading ZIP", 0, total > 0 ? total : 0);
    while (true) {
      const part = await reader.read();
      if (part.done) {
        break;
      }
      const chunk = part.value;
      if (!chunk) {
        continue;
      }
      chunks.push(chunk);
      loaded += chunk.byteLength;
      if (loaded - lastReported >= 262144 || (total > 0 && loaded >= total)) {
        if (total > 0) {
          setWorkProgress(label || "Downloading ZIP", loaded, total);
        } else {
          setWorkProgress((label || "Downloading ZIP") + " (" + formatBytes(loaded) + ")", 0, 0);
        }
        lastReported = loaded;
      }
    }
    if (total > 0) {
      setWorkProgress(label || "Downloading ZIP", loaded, total);
    } else {
      setWorkProgress(label || "Download complete", loaded || 1, loaded || 1);
    }
    const blob = new Blob(chunks, { type: "application/zip" });
    const fileName = extractZipFileNameFromResponse(response, normalizedUrl);
    const outName = /\.zip$/i.test(fileName) ? fileName : (fileName + ".zip");
    return {
      file: new File([blob], outName, { type: "application/zip" }),
      resolvedUrl: toHttpUrl(response.url || normalizedUrl) || normalizedUrl,
      etag: normalizeHttpHeaderToken(response.headers.get("etag") || ""),
      lastModified: normalizeHttpHeaderToken(response.headers.get("last-modified") || "")
    };
  }

  function githubReleaseHasUpdate(previousSource, latestSource) {
    const prev = normalizeGithubSource(previousSource);
    const next = normalizeGithubSource(latestSource);
    if (!prev || !next || prev.provider !== "github-release" || next.provider !== "github-release") {
      return false;
    }
    if (prev.assetId && next.assetId) {
      return prev.assetId !== next.assetId;
    }
    if (prev.releaseTag && next.releaseTag) {
      return prev.releaseTag !== next.releaseTag;
    }
    if (prev.assetUpdatedAt && next.assetUpdatedAt) {
      return next.assetUpdatedAt > prev.assetUpdatedAt;
    }
    return prev.downloadUrl !== next.downloadUrl;
  }

  function zipUrlHasUpdate(previousSource, remoteHeadInfo) {
    const prev = normalizeGithubSource(previousSource);
    if (!prev || prev.provider !== "zip-url") {
      return false;
    }
    const nextEtag = normalizeHttpHeaderToken(remoteHeadInfo && remoteHeadInfo.etag ? remoteHeadInfo.etag : "");
    const nextLastModified = normalizeHttpHeaderToken(remoteHeadInfo && remoteHeadInfo.lastModified ? remoteHeadInfo.lastModified : "");
    if (prev.etag && nextEtag) {
      return prev.etag !== nextEtag;
    }
    if (prev.lastModified && nextLastModified) {
      return prev.lastModified !== nextLastModified;
    }
    return false;
  }

  function mimeFromPath(path) {
    const lower = normalizePath(path).toLowerCase();
    const ext = lower.includes(".") ? lower.slice(lower.lastIndexOf(".")) : "";
    switch (ext) {
      case ".html":
      case ".htm":
        return "text/html";
      case ".js":
      case ".mjs":
      case ".cjs":
        return "application/javascript";
      case ".css":
        return "text/css";
      case ".json":
        return "application/json";
      case ".wasm":
        return "application/wasm";
      case ".png":
        return "image/png";
      case ".jpg":
      case ".jpeg":
        return "image/jpeg";
      case ".gif":
        return "image/gif";
      case ".svg":
        return "image/svg+xml";
      case ".ico":
        return "image/x-icon";
      case ".webp":
        return "image/webp";
      case ".mp3":
        return "audio/mpeg";
      case ".ogg":
        return "audio/ogg";
      case ".wav":
        return "audio/wav";
      case ".mp4":
        return "video/mp4";
      case ".webm":
        return "video/webm";
      case ".woff":
        return "font/woff";
      case ".woff2":
        return "font/woff2";
      case ".ttf":
        return "font/ttf";
      case ".otf":
        return "font/otf";
      case ".unityweb":
      case ".data":
      case ".mem":
      case ".bin":
        return "application/octet-stream";
      default:
        return "application/octet-stream";
    }
  }

  function escapeHtml(value) {
    return String(value)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;");
  }

  function sortedGames() {
    return Array.from(state.gamesById.values()).sort((a, b) => {
      const aOrder = Number.isFinite(Number(a.sortOrder)) ? Number(a.sortOrder) : Number.MAX_SAFE_INTEGER;
      const bOrder = Number.isFinite(Number(b.sortOrder)) ? Number(b.sortOrder) : Number.MAX_SAFE_INTEGER;
      if (aOrder !== bOrder) {
        return aOrder - bOrder;
      }
      return b.importedAt - a.importedAt;
    });
  }

  function getNextSortOrder() {
    let maxOrder = -1;
    for (const game of state.gamesById.values()) {
      const value = Number(game.sortOrder);
      if (Number.isFinite(value) && value > maxOrder) {
        maxOrder = value;
      }
    }
    return maxOrder + 1;
  }

  function filteredGames() {
    const query = state.searchQuery.trim().toLowerCase();
    const games = sortedGames();
    if (!query) {
      return games;
    }
    return games.filter((game) => {
      const name = String(game.name || "").toLowerCase();
      const zipName = String(game.zipName || "").toLowerCase();
      return name.includes(query) || zipName.includes(query);
    });
  }

  function findExistingGameMatchForImport(fileName) {
    const zipName = String(fileName || "");
    const zipNorm = normalizeGameIdentity(zipName);
    const derivedNorm = normalizeGameIdentity(deriveGameName(zipName));
    for (const game of state.gamesById.values()) {
      const gameZipNorm = normalizeGameIdentity(game.zipName || "");
      const gameNameNorm = normalizeGameIdentity(game.name || "");
      if (zipNorm && (zipNorm === gameZipNorm || zipNorm === gameNameNorm)) {
        return game;
      }
      if (derivedNorm && derivedNorm === gameNameNorm) {
        return game;
      }
    }
    return null;
  }

  function closeImportConflictModal() {
    importConflictModal.classList.remove("open");
    importConflictModal.setAttribute("aria-hidden", "true");
    const resolver = state.importConflictResolver;
    state.importConflictResolver = null;
    return resolver;
  }

  function askImportConflictDecision(existingGame, incomingFileName) {
    return new Promise((resolve) => {
      const existingName = existingGame && existingGame.name ? String(existingGame.name) : "this game";
      const incoming = String(incomingFileName || "this ZIP");
      importConflictMessage.textContent =
        "\"" + existingName + "\" is already in your library. Do you want to replace the existing copy or import \"" +
        incoming +
        "\" as a separate game?";
      state.importConflictResolver = resolve;
      importConflictModal.classList.add("open");
      importConflictModal.setAttribute("aria-hidden", "false");
      importConflictReplaceButton.focus();
    });
  }

  function closeGithubImportModal() {
    githubImportModal.classList.remove("open");
    githubImportModal.setAttribute("aria-hidden", "true");
    const resolver = state.githubImportResolver;
    state.githubImportResolver = null;
    return resolver;
  }

  function askGithubImportSource() {
    return new Promise((resolve) => {
      githubImportInput.value = "";
      state.githubImportResolver = resolve;
      githubImportModal.classList.add("open");
      githubImportModal.setAttribute("aria-hidden", "false");
      githubImportInput.focus();
    });
  }

  function closeReplaceTargetModal() {
    replaceTargetModal.classList.remove("open");
    replaceTargetModal.setAttribute("aria-hidden", "true");
    state.replaceTargetSelectedId = "";
  }

  function renderReplaceTargetList() {
    const games = sortedGames();
    replaceTargetList.innerHTML = "";
    if (!games.length) {
      const empty = document.createElement("p");
      empty.className = "hint";
      empty.textContent = "No games available to replace yet.";
      replaceTargetList.append(empty);
      replaceTargetChooseButton.disabled = true;
      return;
    }
    const selectedId = state.replaceTargetSelectedId && state.gamesById.has(state.replaceTargetSelectedId)
      ? state.replaceTargetSelectedId
      : games[0].id;
    state.replaceTargetSelectedId = selectedId;
    replaceTargetChooseButton.disabled = false;
    for (const game of games) {
      const selectedClass = game.id === selectedId ? " is-selected" : "";
      const hasThumb = typeof game.thumbnailDataUrl === "string" && game.thumbnailDataUrl.length > 0;
      const thumbClass = hasThumb ? "square-button" : "square-button no-thumb";
      const thumbStyle = hasThumb
        ? " style=\"background-image:url('" + escapeHtml(game.thumbnailDataUrl) + "');\""
        : "";
      const badgeItems = buildGameBadgeItemsMarkup(game, false);
      const badges = badgeItems
        ? "<span class=\"game-badges\" aria-hidden=\"true\">" + badgeItems + "</span>"
        : "";
      const card = document.createElement("div");
      card.className = "game-item replace-target-card" + selectedClass;
      card.dataset.gameId = game.id;
      card.innerHTML =
        "<button class=\"" + thumbClass + "\" type=\"button\"" + thumbStyle + " data-action=\"choose-replace\" data-game-id=\"" + escapeHtml(game.id) + "\">" +
          badges +
        "</button>" +
        "<div class=\"game-info\">" +
          "<p class=\"game-title\">" + escapeHtml(game.name || "Untitled game") + "</p>" +
        "</div>";
      replaceTargetList.append(card);
    }
  }

  function openReplaceTargetGameModal() {
    state.replaceTargetSelectedId = state.selectedGameId && state.gamesById.has(state.selectedGameId)
      ? state.selectedGameId
      : "";
    renderReplaceTargetList();
    replaceTargetModal.classList.add("open");
    replaceTargetModal.setAttribute("aria-hidden", "false");
    replaceTargetChooseButton.focus();
  }

  function closeUpdatePromptModal() {
    updatePromptModal.classList.remove("open");
    updatePromptModal.setAttribute("aria-hidden", "true");
    const resolver = state.updatePromptResolver;
    state.updatePromptResolver = null;
    return resolver;
  }

  function askUpdateInstallDecision(gameName, sourceLabel, progressLabel) {
    return new Promise((resolve) => {
      updatePromptMessage.textContent =
        String(progressLabel || "") +
        "\n\n\"" + String(gameName || "Selected game") + "\" has an available update.\n" +
        "Source: " + String(sourceLabel || "unknown") + "\n\n" +
        "Do you want to update this game now?";
      state.updatePromptResolver = resolve;
      updatePromptModal.classList.add("open");
      updatePromptModal.setAttribute("aria-hidden", "false");
      updatePromptInstallButton.focus();
    });
  }

  function getBundleNameConflicts(name) {
    const normalized = normalizeGameIdentity(name);
    if (!normalized) {
      return [];
    }
    const matches = [];
    for (const game of state.gamesById.values()) {
      if (normalizeGameIdentity(game.name || "") === normalized) {
        matches.push(game);
      }
    }
    return matches;
  }

  function chooseUniqueGameId(candidateId, reservedIds) {
    const fallbackBase = typeof candidateId === "string" && candidateId ? candidateId : makeId();
    if (!reservedIds.has(fallbackBase)) {
      reservedIds.add(fallbackBase);
      return fallbackBase;
    }
    let nextId = fallbackBase + "-imported";
    let counter = 2;
    while (reservedIds.has(nextId)) {
      nextId = fallbackBase + "-imported-" + counter;
      counter += 1;
    }
    reservedIds.add(nextId);
    return nextId;
  }

  function chooseUniqueGameName(baseName, usedNameKeys) {
    const base = String(baseName || "").trim() || "Imported Game";
    const baseKey = normalizeGameIdentity(base);
    if (!baseKey || !usedNameKeys.has(baseKey)) {
      if (baseKey) {
        usedNameKeys.add(baseKey);
      }
      return base;
    }
    let index = 2;
    while (index < 10000) {
      const candidate = base + " (" + index + ")";
      const key = normalizeGameIdentity(candidate);
      if (!usedNameKeys.has(key)) {
        usedNameKeys.add(key);
        return candidate;
      }
      index += 1;
    }
    const fallback = base + "-" + Date.now();
    const fallbackKey = normalizeGameIdentity(fallback);
    if (fallbackKey) {
      usedNameKeys.add(fallbackKey);
    }
    return fallback;
  }

  function closeBundlePreviewModal() {
    bundlePreviewModal.classList.remove("open");
    bundlePreviewModal.setAttribute("aria-hidden", "true");
    const resolver = state.bundlePreviewResolver;
    state.bundlePreviewResolver = null;
    state.bundlePreviewDraft = null;
    return resolver;
  }

  function cycleGlobalConflictMode(mode) {
    if (mode === "replace") {
      return "rename";
    }
    if (mode === "rename") {
      return "skip";
    }
    return "replace";
  }

  function globalConflictModeLabel(mode) {
    if (mode === "replace") {
      return "Replace Existing";
    }
    if (mode === "rename") {
      return "Import Separately";
    }
    return "Skip Conflicts";
  }

  function applyGlobalConflictModeToDraft() {
    const draft = state.bundlePreviewDraft;
    if (!draft || !Array.isArray(draft.games)) {
      return;
    }
    const globalMode = String(draft.globalConflictMode || "replace");
    for (const game of draft.games) {
      if (!game || !game.hasConflict || game.isInvalid) {
        continue;
      }
      if (!game.selected) {
        continue;
      }
      game.mode = globalMode;
      if (globalMode === "skip") {
        game.selected = false;
      }
    }
  }

  function buildBundlePreviewPlanSummary() {
    const draft = state.bundlePreviewDraft;
    if (!draft || !Array.isArray(draft.games)) {
      return {
        selectedGames: 0,
        importCount: 0,
        replaceCount: 0,
        renameCount: 0,
        skippedCount: 0,
        invalidCount: 0,
        selectedFiles: 0,
        selectedBytes: 0
      };
    }
    const summary = {
      selectedGames: 0,
      importCount: 0,
      replaceCount: 0,
      renameCount: 0,
      skippedCount: 0,
      invalidCount: 0,
      selectedFiles: 0,
      selectedBytes: 0
    };
    for (const game of draft.games) {
      const selected = Boolean(game.selected);
      const mode = game.mode || "skip";
      const isInvalid = Boolean(game.isInvalid);
      if (isInvalid) {
        summary.invalidCount += 1;
      }
      if (!selected || mode === "skip" || isInvalid) {
        summary.skippedCount += 1;
        continue;
      }
      summary.selectedGames += 1;
      summary.selectedFiles += game.fileCount || 0;
      summary.selectedBytes += game.totalBytes || 0;
      if (mode === "replace") {
        summary.replaceCount += 1;
      } else if (mode === "rename") {
        summary.renameCount += 1;
      } else {
        summary.importCount += 1;
      }
    }
    return summary;
  }

  function renderBundlePreviewModal() {
    const draft = state.bundlePreviewDraft;
    if (!draft || !Array.isArray(draft.games)) {
      return;
    }
    const individualMode = Boolean(draft.individualConflictControl);
    const globalConflictMode = String(draft.globalConflictMode || "replace");
    bundlePreviewConflictModeButton.textContent = "Conflicts: " + globalConflictModeLabel(globalConflictMode);
    bundlePreviewIndividualModeButton.textContent = "Per-Game Actions: " + (individualMode ? "On" : "Off");

    bundlePreviewSummary.textContent =
      String(draft.fileName || "bundle.zip") +
      " contains " + draft.games.length +
      " game(s), " + draft.totalFiles + " file(s), " + formatBytes(draft.totalBytes) + ".";

    const rows = [];
    for (const game of draft.games) {
      const statusClass = game.isInvalid ? "bundle-preview-status error" : "bundle-preview-status";
      const rowClass = game.isInvalid ? "bundle-preview-row is-invalid" : "bundle-preview-row";
      const conflictText = game.conflictName
        ? ("Conflicts with \"" + game.conflictName + "\".")
        : "No conflicts detected.";
      const statusText = game.isInvalid
        ? ("Missing payload files: " + game.missingPayloadCount + ".")
        : conflictText;
      const thumbClass = game.thumbnailDataUrl ? "bundle-preview-thumb" : "bundle-preview-thumb no-thumb";
      const thumbStyle = game.thumbnailDataUrl
        ? " style=\"background-image:url('" + escapeHtml(game.thumbnailDataUrl) + "');\""
        : "";
      const modeControl = individualMode
        ? (
            "<select data-action=\"change-mode\" data-index=\"" + game.index + "\"" + (game.isInvalid ? " disabled" : "") + ">" +
              "<option value=\"import\"" + (game.mode === "import" ? " selected" : "") + ">Import</option>" +
              "<option value=\"replace\"" + (game.mode === "replace" ? " selected" : "") + (game.canReplace ? "" : " disabled") + ">Replace Existing</option>" +
              "<option value=\"rename\"" + (game.mode === "rename" ? " selected" : "") + ">Import Separately</option>" +
              "<option value=\"skip\"" + (game.mode === "skip" ? " selected" : "") + ">Skip</option>" +
            "</select>"
          )
        : (
            "<p class=\"bundle-preview-controls-hint\">" +
              (game.hasConflict
                ? ("Global: " + escapeHtml(globalConflictModeLabel(globalConflictMode)))
                : "Auto") +
            "</p>"
          );
      rows.push(
        "<div class=\"" + rowClass + "\">" +
          "<input type=\"checkbox\" data-action=\"toggle-select\" data-index=\"" + game.index + "\"" + (game.selected ? " checked" : "") + (game.isInvalid ? " disabled" : "") + ">" +
          "<div class=\"" + thumbClass + "\"" + thumbStyle + "></div>" +
          "<div class=\"bundle-preview-main\">" +
            "<p class=\"bundle-preview-title\">" + escapeHtml(game.name || "Imported Game") + "</p>" +
            "<p class=\"bundle-preview-meta\">" +
              formatBytes(game.totalBytes) + " â€¢ " + String(game.fileCount || 0) + " files â€¢ Startup: " + escapeHtml(game.entryPath || "-") +
            "</p>" +
            "<p class=\"" + statusClass + "\">" + escapeHtml(statusText) + "</p>" +
          "</div>" +
          "<div class=\"bundle-preview-controls\">" +
            modeControl +
          "</div>" +
        "</div>"
      );
    }
    bundlePreviewList.innerHTML = rows.join("");

    const summary = buildBundlePreviewPlanSummary();
    bundlePreviewPlan.textContent =
      "Planned: " + summary.selectedGames + " game(s), " +
      summary.selectedFiles + " file(s), " +
      formatBytes(summary.selectedBytes) + ". " +
      summary.importCount + " import, " +
      summary.replaceCount + " replace, " +
      summary.renameCount + " import separately, " +
      summary.skippedCount + " skipped.";
    bundlePreviewImportButton.disabled = summary.selectedGames === 0;
  }

  function openBundlePreviewModal(preview) {
    return new Promise((resolve) => {
      const defaultGlobalConflictMode = preview.games.some((game) => game.canReplace) ? "replace" : "rename";
      state.bundlePreviewDraft = {
        fileName: preview.fileName,
        totalFiles: preview.totalFiles,
        totalBytes: preview.totalBytes,
        globalConflictMode: defaultGlobalConflictMode,
        individualConflictControl: false,
        games: preview.games.map((game) => ({
          index: game.index,
          sourceId: game.sourceId,
          name: game.normalizedGame ? game.normalizedGame.name : "Imported Game",
          entryPath: game.normalizedGame ? game.normalizedGame.entryPath : "",
          fileCount: game.fileCount,
          totalBytes: game.totalBytes,
          thumbnailDataUrl: game.thumbnailDataUrl || "",
          conflictName: game.conflictGame ? String(game.conflictGame.name || game.conflictGame.id || "") : "",
          canReplace: Boolean(game.conflictGame),
          hasConflict: Boolean(game.conflictGame),
          isInvalid: Boolean(game.missingPayloadCount),
          missingPayloadCount: game.missingPayloadCount,
          mode: game.defaultMode,
          selected: !game.missingPayloadCount && game.defaultMode !== "skip"
        }))
      };
      applyGlobalConflictModeToDraft();
      state.bundlePreviewResolver = resolve;
      renderBundlePreviewModal();
      bundlePreviewModal.classList.add("open");
      bundlePreviewModal.setAttribute("aria-hidden", "false");
      bundlePreviewImportButton.focus();
    });
  }

  function renderGameCards() {
    const games = filteredGames();
    gamesGrid.innerHTML = "";
    emptyLibrary.classList.toggle("visible", games.length === 0);

    for (const game of games) {
      const selectedClass = game.id === state.selectedGameId ? " is-selected" : "";
      const hasThumb = typeof game.thumbnailDataUrl === "string" && game.thumbnailDataUrl.length > 0;
      const thumbClass = hasThumb ? "square-button" : "square-button no-thumb";
      const thumbStyle = hasThumb
        ? " style=\"background-image:url('" + escapeHtml(game.thumbnailDataUrl) + "');\""
        : "";
      const badgeItems = buildGameBadgeItemsMarkup(game, true);
      const badges = badgeItems
        ? "<span class=\"game-badges\" aria-hidden=\"true\">" + badgeItems + "</span>"
        : "";
      const card = document.createElement("div");
      card.className = "game-item" + selectedClass;
      card.dataset.gameId = game.id;
      card.innerHTML =
        "<button class=\"" + thumbClass + "\" data-action=\"select\" data-game-id=\"" + escapeHtml(game.id) + "\" type=\"button\"" + thumbStyle + ">" +
          badges +
          "<span class=\"game-edit-trigger\" data-action=\"edit-game\" data-game-id=\"" + escapeHtml(game.id) + "\" title=\"Edit game\" aria-label=\"Edit game\"></span>" +
        "</button>" +
        "<div class=\"game-info\">" +
          "<p class=\"game-title\">" + escapeHtml(game.name || "Untitled game") + "</p>" +
          "<div class=\"game-buttons\">" +
            "<button data-action=\"launch\" data-game-id=\"" + escapeHtml(game.id) + "\" type=\"button\">Play</button>" +
            "<button class=\"danger\" data-action=\"delete\" data-game-id=\"" + escapeHtml(game.id) + "\" type=\"button\">Delete</button>" +
          "</div>" +
        "</div>";
      gamesGrid.append(card);
    }
  }

  function closeGameEditModal() {
    gameEditModal.classList.remove("open");
    gameEditModal.setAttribute("aria-hidden", "true");
    if (state.gameEditEditor.cropper) {
      state.gameEditEditor.cropper.destroy();
      state.gameEditEditor.cropper = null;
    }
    if (state.gameEditEditor.previewFrame) {
      cancelAnimationFrame(state.gameEditEditor.previewFrame);
      state.gameEditEditor.previewFrame = 0;
    }
    if (state.gameEditEditor.sourceUrl) {
      URL.revokeObjectURL(state.gameEditEditor.sourceUrl);
    }
    state.gameEditEditor.gameId = null;
    state.gameEditEditor.image = null;
    state.gameEditEditor.sourceUrl = null;
    gameEditCropWrap.classList.add("is-empty");
    gameEditCropImage.removeAttribute("src");
    gameEditNameInput.value = "";
    gameEditPreviewTitle.textContent = "Untitled game";
    if (gameEditPreviewBadges) {
      gameEditPreviewBadges.innerHTML = "";
    }
    gameEditPreviewThumb.style.backgroundImage = "";
    gameEditPreviewThumb.classList.add("preview-empty");
    gameEditImageInput.value = "";
  }

  function buildGameBadgeItemsMarkup(game, withTitles) {
    const titleAttr = (text) => withTitles ? " title=\"" + escapeHtml(text) + "\"" : "";
    const githubBadge = game && game.githubSource
      ? "<span class=\"game-github-badge\" aria-hidden=\"true\"" + titleAttr("Imported from GitHub") + "></span>"
      : "";
    const unityBadge = game && game.unityDetected
      ? "<span class=\"game-unity-badge\" aria-hidden=\"true\"" + titleAttr("Unity game") + "></span>"
      : "";
    const flashBadge = game && game.flashDetected
      ? "<span class=\"game-flash-badge\" aria-hidden=\"true\"" + titleAttr("Adobe Flash game") + "></span>"
      : "";
    return githubBadge + unityBadge + flashBadge;
  }

  function updateGameEditPreviewThumbFromSource() {
    const src = String(gameEditCropImage.getAttribute("src") || "").trim();
    if (!src) {
      gameEditPreviewThumb.style.backgroundImage = "";
      gameEditPreviewThumb.classList.add("preview-empty");
      return;
    }
    gameEditPreviewThumb.style.backgroundImage = "url('" + src.replace(/'/g, "\\'") + "')";
    gameEditPreviewThumb.classList.remove("preview-empty");
  }

  function updateGameEditPreviewFromCrop() {
    const cropper = state.gameEditEditor.cropper;
    if (!cropper) {
      updateGameEditPreviewThumbFromSource();
      return;
    }
    const cropped = cropper.getCroppedCanvas({
      width: 320,
      height: 320,
      imageSmoothingEnabled: true,
      imageSmoothingQuality: "high"
    });
    if (!cropped) {
      updateGameEditPreviewThumbFromSource();
      return;
    }
    gameEditPreviewThumb.style.backgroundImage = "url('" + cropped.toDataURL("image/jpeg", 0.9) + "')";
    gameEditPreviewThumb.classList.remove("preview-empty");
  }

  function scheduleGameEditPreviewFromCrop() {
    if (state.gameEditEditor.previewFrame) {
      cancelAnimationFrame(state.gameEditEditor.previewFrame);
    }
    state.gameEditEditor.previewFrame = requestAnimationFrame(() => {
      state.gameEditEditor.previewFrame = 0;
      updateGameEditPreviewFromCrop();
    });
  }

  function initGameEditCropper() {
    if (!window.Cropper) {
      log("Game image cropper failed to load.", "error");
      return;
    }
    if (state.gameEditEditor.cropper) {
      state.gameEditEditor.cropper.destroy();
    }
    state.gameEditEditor.cropper = new Cropper(gameEditCropImage, {
      aspectRatio: 1,
      viewMode: 1,
      dragMode: "move",
      autoCropArea: 1,
      responsive: true,
      background: false,
      zoomable: true,
      movable: true,
      rotatable: false,
      scalable: false,
      guides: true,
      crop() {
        scheduleGameEditPreviewFromCrop();
      },
      ready() {
        const cropper = state.gameEditEditor.cropper;
        if (!cropper) {
          return;
        }
        cropper.reset();
        scheduleGameEditPreviewFromCrop();
      }
    });
  }

  function setGameEditCropSource(sourceUrl) {
    if (!sourceUrl) {
      if (state.gameEditEditor.cropper) {
        state.gameEditEditor.cropper.destroy();
        state.gameEditEditor.cropper = null;
      }
      gameEditCropWrap.classList.add("is-empty");
      gameEditCropImage.removeAttribute("src");
      updateGameEditPreviewThumbFromSource();
      return;
    }
    gameEditCropWrap.classList.remove("is-empty");
    gameEditCropImage.onload = () => initGameEditCropper();
    gameEditCropImage.src = sourceUrl;
    updateGameEditPreviewThumbFromSource();
  }

  async function saveGameEditChanges() {
    if (!(await saveGameEditName({ silent: true }))) {
      return;
    }
    const gameId = state.gameEditEditor.gameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game) {
      log("Select a game before saving changes.", "error");
      return;
    }

    const cropper = state.gameEditEditor.cropper;
    if (cropper) {
      const cropped = cropper.getCroppedCanvas({
        width: 1024,
        height: 1024,
        imageSmoothingEnabled: true,
        imageSmoothingQuality: "high"
      });
      if (!cropped) {
        log("Could not crop this image.", "error");
        return;
      }
      game.thumbnailDataUrl = cropped.toDataURL("image/jpeg", 0.9);
      state.gamesById.set(game.id, game);
      await putGame(game);
    }

    renderGameCards();
    closeGameEditModal();
    log("Saved changes for " + game.name + ".");
  }

  async function removeGameEditImage() {
    if (!(await saveGameEditName({ silent: true }))) {
      return;
    }
    const gameId = state.gameEditEditor.gameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game) {
      return;
    }
    game.thumbnailDataUrl = "";
    state.gamesById.set(game.id, game);
    await putGame(game);
    renderGameCards();
    closeGameEditModal();
    log("Removed game image for " + game.name + ".");
  }

  function openGameEditModal(gameId) {
    if (!gameId || !state.gamesById.has(gameId)) {
      return;
    }
    hideOpsModal(true);
    const game = state.gamesById.get(gameId);
    state.gameEditEditor.gameId = gameId;
    if (state.gameEditEditor.cropper) {
      state.gameEditEditor.cropper.destroy();
      state.gameEditEditor.cropper = null;
    }
    state.gameEditEditor.image = null;
    if (state.gameEditEditor.sourceUrl) {
      URL.revokeObjectURL(state.gameEditEditor.sourceUrl);
    }
    state.gameEditEditor.sourceUrl = null;
    if (game && typeof game.thumbnailDataUrl === "string" && game.thumbnailDataUrl) {
      setGameEditCropSource(game.thumbnailDataUrl);
    } else {
      setGameEditCropSource("");
    }
    gameEditNameInput.value = String(game.name || "");
    gameEditPreviewTitle.textContent = String(game.name || "Untitled game");
    if (gameEditPreviewBadges) {
      gameEditPreviewBadges.innerHTML = buildGameBadgeItemsMarkup(game, true);
    }
    gameEditModal.classList.add("open");
    gameEditModal.setAttribute("aria-hidden", "false");
  }

  async function saveGameEditName(options = {}) {
    const silent = Boolean(options.silent);
    const gameId = state.gameEditEditor.gameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game) {
      if (!silent) {
        log("Select a game before renaming.", "error");
      }
      return false;
    }

    const nextName = String(gameEditNameInput.value || "").trim();
    if (!nextName) {
      log("Game name cannot be empty.", "error");
      gameEditNameInput.focus();
      return false;
    }
    if (nextName === String(game.name || "")) {
      return true;
    }

    game.name = nextName;
    state.gamesById.set(game.id, game);

    try {
      await putGame(game);
      renderGameOptions(game.id);
      updateSelectedGameInfo(game);
      if (!silent) {
        log("Renamed game to " + game.name + ".");
      }
      return true;
    } catch (error) {
      console.error(error);
      log("Could not save game name.", "error");
      return false;
    }
  }

  function loadGameEditImageSource(file) {
    if (!file || !file.type.startsWith("image/")) {
      log("Please choose an image file for the game image.", "error");
      return;
    }
    if (state.gameEditEditor.sourceUrl) {
      URL.revokeObjectURL(state.gameEditEditor.sourceUrl);
    }
    const objectUrl = URL.createObjectURL(file);
    state.gameEditEditor.sourceUrl = objectUrl;
    setGameEditCropSource(objectUrl);
  }

  async function selectGameById(nextId) {
    const selectedId = nextId && state.gamesById.has(nextId) ? nextId : null;
    state.selectedGameId = selectedId;
    gameSelect.value = selectedId || "";
    await putSetting(SETTING_SELECTED_GAME, selectedId || "");
    updateSelectedGameInfo(selectedId ? state.gamesById.get(selectedId) : null);
    renderGameCards();
  }

  function setSelectedGameImmediate(gameId, options = {}) {
    const persist = options.persist !== false;
    const updateCardStyles = options.updateCardStyles !== false;
    if (!gameId || !state.gamesById.has(gameId)) {
      return;
    }
    if (state.selectedGameId === gameId) {
      return;
    }
    state.selectedGameId = gameId;
    gameSelect.value = gameId;
    updateSelectedGameInfo(state.gamesById.get(gameId) || null);
    if (updateCardStyles) {
      for (const el of getGridReorderElements()) {
        const id = String(el.dataset.gameId || "");
        el.classList.toggle("is-selected", id === gameId);
      }
    }
    if (persist) {
      putSetting(SETTING_SELECTED_GAME, gameId).catch((error) => {
        console.error(error);
        log("Could not persist selected game.", "error");
      });
    }
  }

  function normalizeResolverBase(baseHref) {
    if (typeof baseHref === "string" && baseHref) {
      try {
        const parsed = new URL(baseHref);
        if (parsed.origin === VFS_ORIGIN_URL) {
          return parsed.href;
        }
      } catch {
        // fall through
      }
    }
    if (state.activeEntryPath) {
      return toVirtualUrl(state.activeEntryPath);
    }
    return VFS_ORIGIN;
  }

  function resolveToPath(rawValue, baseHref) {
    if (typeof rawValue !== "string") {
      return null;
    }
    const value = rawValue.trim();
    if (!value || value.startsWith("#")) {
      return null;
    }
    const lower = value.toLowerCase();
    if (
      lower.startsWith("data:") ||
      lower.startsWith("blob:") ||
      lower.startsWith("javascript:") ||
      lower.startsWith("mailto:") ||
      lower.startsWith("tel:")
    ) {
      return null;
    }
    let resolved;
    try {
      resolved = new URL(value, baseHref || VFS_ORIGIN);
    } catch {
      return null;
    }
    if (resolved.origin !== VFS_ORIGIN_URL) {
      return null;
    }
    const decoded = decodeURIComponent(resolved.pathname.slice(1));
    const normalized = normalizePath(decoded);
    return normalized || null;
  }

  function resolveMediaSchemePath(rawValue) {
    if (typeof rawValue !== "string") {
      return null;
    }
    const value = rawValue.trim();
    if (!value || !/^media:/i.test(value)) {
      return null;
    }
    try {
      const parsed = new URL(value);
      if (parsed.protocol !== "media:") {
        return null;
      }
      const host = normalizePath(parsed.hostname || "");
      const pathname = normalizePath((parsed.pathname || "").replace(/^\/+/, ""));
      const combined = normalizePath([host, pathname].filter(Boolean).join("/"));
      return combined || null;
    } catch {
      return null;
    }
  }

  function buildAssetFallbackCandidates(path) {
    const normalized = normalizePath(path);
    if (!normalized) {
      return [];
    }

    const out = [normalized];
    const push = (candidate) => {
      const next = normalizePath(candidate);
      if (next && !out.includes(next)) {
        out.push(next);
      }
    };

    const mediaTrimmed = normalized.replace(/^media\/+/i, "");
    const baseAsset = mediaTrimmed || normalized;
    if (!/^static\/blocks-media\//i.test(baseAsset)) {
      push("static/blocks-media/default/" + baseAsset);
      push("static/blocks-media/high-contrast/" + baseAsset);
    }

    const fileNameOnly = baseAsset.split("/").pop() || "";
    if (fileNameOnly && fileNameOnly !== baseAsset) {
      push(fileNameOnly);
      push("static/blocks-media/default/" + fileNameOnly);
      push("static/blocks-media/high-contrast/" + fileNameOnly);
    }

    return out;
  }

  function requestToObjectUrl(rawValue, baseHref) {
    const raw = String(rawValue);
    const resolvedBase = normalizeResolverBase(baseHref);
    const path = resolveToPath(raw, resolvedBase) || resolveMediaSchemePath(raw);
    if (!path) {
      return null;
    }

    const directCandidates = buildAssetFallbackCandidates(path);
    for (const candidate of directCandidates) {
      const mapped = state.objectUrls.get(candidate);
      if (mapped) {
        return mapped;
      }
    }

    // Some bundles include an extra top-level folder (e.g. "Turbowarp/...").
    // If direct lookup misses, progressively strip leading segments and retry.
    const pathParts = path.split("/").filter(Boolean);
    if (pathParts.length > 1) {
      for (let i = 1; i < pathParts.length; i += 1) {
        const trimmedPath = pathParts.slice(i).join("/");
        const trimmedCandidates = buildAssetFallbackCandidates(trimmedPath);
        for (const trimmedCandidate of trimmedCandidates) {
          const mapped = state.objectUrls.get(trimmedCandidate);
          if (mapped) {
            return mapped;
          }
        }
      }
    }

    const trimmed = raw.trim();
    const isRootLike =
      trimmed.startsWith("/") ||
      trimmed.startsWith(VFS_ORIGIN) ||
      trimmed.startsWith(VFS_ORIGIN_URL + "/");
    if (!isRootLike) {
      return null;
    }

    let probeDir = "";
    const basePath = resolveToPath(resolvedBase, VFS_ORIGIN);
    if (basePath) {
      probeDir = dirnamePath(basePath);
    } else if (state.activeEntryPath) {
      probeDir = dirnamePath(state.activeEntryPath);
    }

    while (probeDir) {
      const candidate = normalizePath(probeDir + "/" + path);
      const nestedCandidates = buildAssetFallbackCandidates(candidate);
      for (const nestedCandidate of nestedCandidates) {
        const mapped = state.objectUrls.get(nestedCandidate);
        if (mapped) {
          return mapped;
        }
      }
      probeDir = dirnamePath(probeDir);
    }
    return null;
  }

  window.__loaderResolve = requestToObjectUrl;

  function txDone(tx) {
    return new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error || new Error("Transaction failed"));
      tx.onabort = () => reject(tx.error || new Error("Transaction aborted"));
    });
  }

  function openDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onupgradeneeded = (event) => {
        const db = event.target.result;

        if (!db.objectStoreNames.contains(STORE_GAMES)) {
          db.createObjectStore(STORE_GAMES, { keyPath: "id" });
        }
        if (!db.objectStoreNames.contains(STORE_FILES)) {
          const filesStore = db.createObjectStore(STORE_FILES, { keyPath: ["gameId", "path"] });
          filesStore.createIndex("gameId", "gameId", { unique: false });
        }
        if (!db.objectStoreNames.contains(STORE_SETTINGS)) {
          db.createObjectStore(STORE_SETTINGS);
        }
        if (!db.objectStoreNames.contains(STORE_ERROR_LOGS)) {
          const errorLogsStore = db.createObjectStore(STORE_ERROR_LOGS, { keyPath: "id" });
          errorLogsStore.createIndex("timestamp", "timestamp", { unique: false });
          errorLogsStore.createIndex("gameId", "gameId", { unique: false });
        }
      };
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async function reopenDatabaseConnection() {
    if (state.db) {
      try {
        state.db.close();
      } catch {
        // ignore close errors
      }
    }
    state.db = await openDatabase();
  }

  function putSetting(key, value) {
    const tx = state.db.transaction(STORE_SETTINGS, "readwrite");
    tx.objectStore(STORE_SETTINGS).put(value, key);
    return txDone(tx);
  }

  function getSetting(key) {
    return new Promise((resolve, reject) => {
      const tx = state.db.transaction(STORE_SETTINGS, "readonly");
      const request = tx.objectStore(STORE_SETTINGS).get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  function putGame(gameRecord) {
    const tx = state.db.transaction(STORE_GAMES, "readwrite");
    tx.objectStore(STORE_GAMES).put(gameRecord);
    return txDone(tx);
  }

  function deleteGameRecord(gameId) {
    const tx = state.db.transaction(STORE_GAMES, "readwrite");
    tx.objectStore(STORE_GAMES).delete(gameId);
    return txDone(tx);
  }

  function getAllGames() {
    return new Promise((resolve, reject) => {
      const tx = state.db.transaction(STORE_GAMES, "readonly");
      const request = tx.objectStore(STORE_GAMES).getAll();
      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(request.error);
    });
  }

  function putFileRecord(record) {
    const tx = state.db.transaction(STORE_FILES, "readwrite");
    tx.objectStore(STORE_FILES).put(record);
    return txDone(tx);
  }

  function putErrorLogRecord(record) {
    const tx = state.db.transaction(STORE_ERROR_LOGS, "readwrite");
    tx.objectStore(STORE_ERROR_LOGS).put(record);
    return txDone(tx);
  }

  function getAllErrorLogRecords() {
    return new Promise((resolve, reject) => {
      const tx = state.db.transaction(STORE_ERROR_LOGS, "readonly");
      const request = tx.objectStore(STORE_ERROR_LOGS).getAll();
      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(request.error);
    });
  }

  function getAllFilesForGame(gameId) {
    return new Promise((resolve, reject) => {
      const out = [];
      const tx = state.db.transaction(STORE_FILES, "readonly");
      const index = tx.objectStore(STORE_FILES).index("gameId");
      const request = index.openCursor(IDBKeyRange.only(gameId));
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (!cursor) {
          return;
        }
        out.push(cursor.value);
        cursor.continue();
      };
      request.onerror = () => reject(request.error);
      tx.oncomplete = () => resolve(out);
      tx.onabort = () => reject(tx.error || new Error("Failed to read files"));
    });
  }

  function detectFlashFromStoredFiles(gameId) {
    return new Promise((resolve, reject) => {
      const tx = state.db.transaction(STORE_FILES, "readonly");
      const index = tx.objectStore(STORE_FILES).index("gameId");
      const request = index.openCursor(IDBKeyRange.only(gameId));
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (!cursor) {
          resolve(false);
          return;
        }
        const primaryKey = cursor.primaryKey;
        const pathFromKey = Array.isArray(primaryKey) ? primaryKey[1] : "";
        const path = normalizePath(pathFromKey || (cursor.value && cursor.value.path ? cursor.value.path : ""));
        if (/(^|\/)[^/]+\.swf$/i.test(path)) {
          resolve(true);
          return;
        }
        cursor.continue();
      };
      request.onerror = () => reject(request.error);
    });
  }

  async function detectUnityFromStoredFiles(gameId) {
    const files = await getAllFilesForGame(gameId);
    const paths = files.map((file) => normalizePath(file.path || ""));
    if (detectUnityByPaths(paths)) {
      return true;
    }
    for (const file of files) {
      const path = normalizePath(file.path || "");
      if (!/\.html?$/i.test(path)) {
        continue;
      }
      try {
        const htmlText = await file.blob.text();
        if (detectUnityByHtmlText(htmlText)) {
          return true;
        }
      } catch {
        // ignore parse errors
      }
    }
    return false;
  }

  function deleteFilesByGameId(gameId) {
    return new Promise((resolve, reject) => {
      const tx = state.db.transaction(STORE_FILES, "readwrite");
      const index = tx.objectStore(STORE_FILES).index("gameId");
      const request = index.openCursor(IDBKeyRange.only(gameId));
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (!cursor) {
          return;
        }
        cursor.delete();
        cursor.continue();
      };
      request.onerror = () => reject(request.error);
      tx.oncomplete = () => resolve();
      tx.onabort = () => reject(tx.error || new Error("Failed to delete files"));
    });
  }

  function findEocdOffset(bytes) {
    const minEocdLength = 22;
    const maxCommentLength = 65535;
    const start = Math.max(0, bytes.length - minEocdLength - maxCommentLength);
    for (let i = bytes.length - minEocdLength; i >= start; i -= 1) {
      if (
        bytes[i] === 0x50 &&
        bytes[i + 1] === 0x4b &&
        bytes[i + 2] === 0x05 &&
        bytes[i + 3] === 0x06
      ) {
        return i;
      }
    }
    return -1;
  }

  const CRC32_TABLE = (() => {
    const table = new Uint32Array(256);
    for (let i = 0; i < 256; i += 1) {
      let c = i;
      for (let j = 0; j < 8; j += 1) {
        c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[i] = c >>> 0;
    }
    return table;
  })();

  function crc32(bytes) {
    let c = 0xffffffff;
    for (let i = 0; i < bytes.length; i += 1) {
      c = CRC32_TABLE[(c ^ bytes[i]) & 0xff] ^ (c >>> 8);
    }
    return (c ^ 0xffffffff) >>> 0;
  }

  function createZipStoreArchive(entries) {
    const encoder = new TextEncoder();
    const localParts = [];
    const centralParts = [];
    let localOffset = 0;
    let centralSize = 0;

    for (const entry of entries) {
      const name = normalizePath(entry.path || "");
      const data = entry.bytes instanceof Uint8Array ? entry.bytes : new Uint8Array(entry.bytes || []);
      const nameBytes = encoder.encode(name);
      const checksum = crc32(data);

      const localHeader = new Uint8Array(30 + nameBytes.length);
      const localView = new DataView(localHeader.buffer);
      localView.setUint32(0, 0x04034b50, true);
      localView.setUint16(4, 20, true);
      localView.setUint16(6, 0, true);
      localView.setUint16(8, 0, true); // store
      localView.setUint16(10, 0, true);
      localView.setUint16(12, 0, true);
      localView.setUint32(14, checksum, true);
      localView.setUint32(18, data.length, true);
      localView.setUint32(22, data.length, true);
      localView.setUint16(26, nameBytes.length, true);
      localView.setUint16(28, 0, true);
      localHeader.set(nameBytes, 30);
      localParts.push(localHeader, data);

      const centralHeader = new Uint8Array(46 + nameBytes.length);
      const centralView = new DataView(centralHeader.buffer);
      centralView.setUint32(0, 0x02014b50, true);
      centralView.setUint16(4, 20, true);
      centralView.setUint16(6, 20, true);
      centralView.setUint16(8, 0, true);
      centralView.setUint16(10, 0, true);
      centralView.setUint16(12, 0, true);
      centralView.setUint16(14, 0, true);
      centralView.setUint32(16, checksum, true);
      centralView.setUint32(20, data.length, true);
      centralView.setUint32(24, data.length, true);
      centralView.setUint16(28, nameBytes.length, true);
      centralView.setUint16(30, 0, true);
      centralView.setUint16(32, 0, true);
      centralView.setUint16(34, 0, true);
      centralView.setUint16(36, 0, true);
      centralView.setUint32(38, 0, true);
      centralView.setUint32(42, localOffset, true);
      centralHeader.set(nameBytes, 46);
      centralParts.push(centralHeader);
      centralSize += centralHeader.length;

      localOffset += localHeader.length + data.length;
    }

    const centralOffset = localOffset;
    const eocd = new Uint8Array(22);
    const eocdView = new DataView(eocd.buffer);
    eocdView.setUint32(0, 0x06054b50, true);
    eocdView.setUint16(4, 0, true);
    eocdView.setUint16(6, 0, true);
    eocdView.setUint16(8, entries.length, true);
    eocdView.setUint16(10, entries.length, true);
    eocdView.setUint32(12, centralSize, true);
    eocdView.setUint32(16, centralOffset, true);
    eocdView.setUint16(20, 0, true);

    return new Blob([...localParts, ...centralParts, eocd], { type: "application/zip" });
  }

  function parseZipArchive(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    const view = new DataView(arrayBuffer);
    const eocdOffset = findEocdOffset(bytes);
    if (eocdOffset === -1) {
      throw new Error("Invalid ZIP: end-of-central-directory record not found.");
    }

    const totalEntries = view.getUint16(eocdOffset + 10, true);
    const centralDirectorySize = view.getUint32(eocdOffset + 12, true);
    const centralDirectoryOffset = view.getUint32(eocdOffset + 16, true);

    if (
      totalEntries === 0xffff ||
      centralDirectorySize === 0xffffffff ||
      centralDirectoryOffset === 0xffffffff
    ) {
      throw new Error("ZIP64 archives are not supported yet.");
    }

    const end = centralDirectoryOffset + centralDirectorySize;
    if (end > bytes.length) {
      throw new Error("Invalid ZIP: central directory outside file bounds.");
    }

    const decoder = new TextDecoder("utf-8");
    const entries = [];
    let offset = centralDirectoryOffset;

    for (let i = 0; i < totalEntries; i += 1) {
      if (view.getUint32(offset, true) !== 0x02014b50) {
        throw new Error("Invalid ZIP: bad central directory header.");
      }

      const flags = view.getUint16(offset + 8, true);
      const compressionMethod = view.getUint16(offset + 10, true);
      const compressedSize = view.getUint32(offset + 20, true);
      const uncompressedSize = view.getUint32(offset + 24, true);
      const fileNameLength = view.getUint16(offset + 28, true);
      const extraLength = view.getUint16(offset + 30, true);
      const commentLength = view.getUint16(offset + 32, true);
      const localHeaderOffset = view.getUint32(offset + 42, true);

      const nameStart = offset + 46;
      const nameEnd = nameStart + fileNameLength;
      const nameBytes = bytes.subarray(nameStart, nameEnd);
      const path = normalizePath(decoder.decode(nameBytes));

      offset = nameEnd + extraLength + commentLength;

      if (!path || path.endsWith("/")) {
        continue;
      }

      entries.push({
        path,
        flags,
        compressionMethod,
        compressedSize,
        uncompressedSize,
        localHeaderOffset
      });
    }

    return { bytes, view, entries };
  }

  function getCompressedEntrySlice(zip, entry) {
    const localOffset = entry.localHeaderOffset;
    if (zip.view.getUint32(localOffset, true) !== 0x04034b50) {
      throw new Error("Invalid ZIP: bad local header for " + entry.path);
    }

    const fileNameLength = zip.view.getUint16(localOffset + 26, true);
    const extraLength = zip.view.getUint16(localOffset + 28, true);
    const dataOffset = localOffset + 30 + fileNameLength + extraLength;
    const dataEnd = dataOffset + entry.compressedSize;

    if (dataEnd > zip.bytes.length) {
      throw new Error("Invalid ZIP: data overflow for " + entry.path);
    }

    return zip.bytes.subarray(dataOffset, dataEnd);
  }

  async function inflateDeflateRaw(data) {
    if (!("DecompressionStream" in window)) {
      throw new Error("This browser does not support ZIP extraction in file:// mode (missing DecompressionStream).");
    }
    const stream = new Blob([data]).stream().pipeThrough(new DecompressionStream("deflate-raw"));
    const buffer = await new Response(stream).arrayBuffer();
    return new Uint8Array(buffer);
  }

  async function extractEntryBytes(zip, entry) {
    if (entry.flags & 0x1) {
      throw new Error("Encrypted ZIP entries are not supported: " + entry.path);
    }

    const compressed = getCompressedEntrySlice(zip, entry);

    if (entry.compressionMethod === 0) {
      return compressed.slice();
    }
    if (entry.compressionMethod === 8) {
      const decompressed = await inflateDeflateRaw(compressed);
      return decompressed;
    }

    throw new Error(
      "Unsupported ZIP compression method " + entry.compressionMethod + " for " + entry.path
    );
  }

  function entryDepth(path) {
    return normalizePath(path).split("/").length - 1;
  }

  function scoreEntryPath(path) {
    const normalized = normalizePath(path).toLowerCase();
    const base = normalized.split("/").pop() || normalized;
    let score = 0;

    if (base === "play.html") {
      score += 340;
    } else if (base === "index.html") {
      score += 320;
    } else if (base === "game.html") {
      score += 260;
    } else if (base === "main.html") {
      score += 230;
    } else if (base === "start.html") {
      score += 220;
    } else if (base === "launch.html") {
      score += 200;
    } else {
      score += 120;
    }

    if (normalized === "play.html" || normalized === "index.html") {
      score += 70;
    }

    if (/\/(assets|scripts|js|vendor|lib|dist|build|docs|examples|tests)\//.test(normalized)) {
      score -= 95;
    }
    if (/(loader|preload|preloader|unityloader|template|embed|frame|privacy|terms)/.test(base)) {
      score -= 120;
    }

    score -= entryDepth(normalized) * 3;
    return score;
  }

  function chooseBestEntryPath(entries, preferredPath) {
    if (preferredPath && entries.includes(preferredPath)) {
      return preferredPath;
    }
    const sorted = entries.slice().sort((a, b) => {
      const scoreDiff = scoreEntryPath(b) - scoreEntryPath(a);
      if (scoreDiff !== 0) {
        return scoreDiff;
      }
      const depthDiff = entryDepth(a) - entryDepth(b);
      if (depthDiff !== 0) {
        return depthDiff;
      }
      return a.localeCompare(b);
    });
    return sorted[0] || "";
  }

  function setEmptyEntryState(message) {
    entrySelect.innerHTML = "";
    const option = document.createElement("option");
    option.value = "";
    option.textContent = message;
    entrySelect.append(option);
    entrySelect.disabled = true;
  }

  function populateEntryOptions(entryPaths, preferredPath) {
    const entries = (entryPaths || []).slice().sort((a, b) => a.localeCompare(b));
    if (!entries.length) {
      setEmptyEntryState("No .html startup file found");
      return "";
    }

    entrySelect.disabled = false;
    entrySelect.innerHTML = "";
    for (const path of entries) {
      const option = document.createElement("option");
      option.value = path;
      option.textContent = path;
      entrySelect.append(option);
    }

    const selected = chooseBestEntryPath(entries, preferredPath);
    entrySelect.value = selected;
    return selected;
  }

  function renderGameOptions(selectedId) {
    gameSelect.innerHTML = "";
    const games = sortedGames();

    if (!games.length) {
      const option = document.createElement("option");
      option.value = "";
      option.textContent = "No saved games yet";
      gameSelect.append(option);
      gameSelect.disabled = true;
      renderGameCards();
      return "";
    }

    gameSelect.disabled = false;
    for (const game of games) {
      const option = document.createElement("option");
      option.value = game.id;
      option.textContent = game.name;
      gameSelect.append(option);
    }

    const chosen = selectedId && state.gamesById.has(selectedId)
      ? selectedId
      : games[0].id;
    gameSelect.value = chosen;
    renderGameCards();
    return chosen;
  }

  async function refreshStorageSummary() {
    const games = Array.from(state.gamesById.values());
    const totalBytes = games.reduce((sum, game) => sum + (Number(game.totalBytes) || 0), 0);

    libraryCount.textContent = String(games.length);
    libraryBytes.textContent = formatBytes(totalBytes);

    const setDonut = (pct) => {
      const clamped = Math.max(0, Math.min(100, Number(pct) || 0));
      if (storageDonut) {
        storageDonut.style.setProperty("--used-pct", clamped.toFixed(1));
      }
      if (storageUsedPct) {
        storageUsedPct.textContent = Math.round(clamped) + "%";
      }
    };

    if (navigator.storage && navigator.storage.estimate) {
      try {
        const estimate = await navigator.storage.estimate();
        const hasUsage = estimate && typeof estimate.usage === "number";
        const hasQuota = estimate && typeof estimate.quota === "number";
        if (hasUsage && hasQuota) {
          quotaUsage.textContent = formatBytes(estimate.usage) + " / " + formatBytes(estimate.quota);
          setDonut((estimate.usage / Math.max(1, estimate.quota)) * 100);
        } else {
          quotaUsage.textContent = "Unavailable";
          setDonut(0);
        }
      } catch {
        quotaUsage.textContent = "Unavailable";
        setDonut(0);
      }
    } else {
      quotaUsage.textContent = "Unsupported";
      setDonut(0);
    }
  }

  function updateSelectedGameInfo(game) {
    if (!game) {
      gameMeta.textContent = "No saved game selected.";
      selectedSubtext.textContent = "Pick a game and press Play.";
      selectedThumb.classList.add("no-thumb");
      selectedThumb.style.backgroundImage = "";
      selectedImported.textContent = "-";
      selectedSize.textContent = "-";
      selectedEntry.textContent = "-";
      selectedPlayButton.disabled = true;
      selectedEditButton.disabled = true;
      selectedDeleteButton.disabled = true;
      setEmptyEntryState("Select a saved game");
      return;
    }

    gameMeta.textContent = game.name || "Selected game";
    selectedSubtext.textContent = "Ready to launch";
    if (typeof game.thumbnailDataUrl === "string" && game.thumbnailDataUrl) {
      selectedThumb.classList.remove("no-thumb");
      selectedThumb.style.backgroundImage = "url('" + game.thumbnailDataUrl + "')";
    } else {
      selectedThumb.classList.add("no-thumb");
      selectedThumb.style.backgroundImage = "";
    }
    selectedImported.textContent = formatDate(game.importedAt);
    selectedSize.textContent = formatBytes(game.totalBytes || 0);
    selectedPlayButton.disabled = false;
    selectedEditButton.disabled = false;
    selectedDeleteButton.disabled = false;

    const chosenEntry = populateEntryOptions(game.htmlEntries || [], game.entryPath || "");
    selectedEntry.textContent = chosenEntry || game.entryPath || "-";
    if (chosenEntry && chosenEntry !== game.entryPath) {
      game.entryPath = chosenEntry;
      state.gamesById.set(game.id, game);
      putGame(game).catch((error) => {
        console.error(error);
        log("Could not persist startup file for " + game.name + ".", "error");
      });
    }
  }

  async function loadLibrary(preferredGameId) {
    const storedGames = await getAllGames();
    const games = storedGames.map((game) => ({
      ...game,
      githubSource: normalizeGithubSource(game.githubSource),
      unityDetected: Boolean(game.unityDetected),
      flashDetected: typeof game.flashDetected === "boolean" ? game.flashDetected : false
    }));

    // One-time backfill for older saves that predate flashDetected.
    for (let i = 0; i < games.length; i += 1) {
      const raw = storedGames[i];
      const normalized = games[i];
      if (typeof raw.flashDetected === "boolean") {
        continue;
      }
      try {
        const hasFlash = await detectFlashFromStoredFiles(normalized.id);
        normalized.flashDetected = hasFlash;
        raw.flashDetected = hasFlash;
        await putGame(raw);
      } catch (error) {
        console.error(error);
        log("Could not detect Flash files for " + (normalized.name || normalized.id) + ".", "error");
      }
    }

    const forceBadgeRescan = shouldRunSecretBadgeRescan() && !state.badgeRescanCompleted;
    if (forceBadgeRescan) {
      log("Secret badge rescan enabled. Re-checking all saved games...");
      for (let i = 0; i < games.length; i += 1) {
        const raw = storedGames[i];
        const normalized = games[i];
        try {
          const [hasUnity, hasFlash] = await Promise.all([
            detectUnityFromStoredFiles(normalized.id),
            detectFlashFromStoredFiles(normalized.id)
          ]);
          const unityChanged = Boolean(raw.unityDetected) !== hasUnity;
          const flashChanged = Boolean(raw.flashDetected) !== hasFlash;
          if (unityChanged || flashChanged) {
            raw.unityDetected = hasUnity;
            raw.flashDetected = hasFlash;
            normalized.unityDetected = hasUnity;
            normalized.flashDetected = hasFlash;
            await putGame(raw);
          }
        } catch (error) {
          console.error(error);
          log("Badge rescan failed for " + (normalized.name || normalized.id) + ".", "error");
        }
      }
      state.badgeRescanCompleted = true;
      log("Badge rescan complete.");
    }

    state.gamesById = new Map(games.map((game) => [game.id, game]));
    let nextOrder = 0;
    let changedOrder = false;
    for (const game of sortedGames()) {
      if (Number(game.sortOrder) !== nextOrder) {
        game.sortOrder = nextOrder;
        state.gamesById.set(game.id, game);
        changedOrder = true;
      }
      nextOrder += 1;
    }
    if (changedOrder) {
      for (const game of sortedGames()) {
        await putGame(game);
      }
    }

    const selectedId = renderGameOptions(preferredGameId || state.selectedGameId);
    state.selectedGameId = selectedId || null;

    if (state.selectedGameId) {
      await putSetting(SETTING_SELECTED_GAME, state.selectedGameId);
    }

    updateSelectedGameInfo(state.selectedGameId ? state.gamesById.get(state.selectedGameId) : null);
    await refreshStorageSummary();
  }

  async function pickZipFile() {
    if (window.showOpenFilePicker) {
      try {
        const handles = await window.showOpenFilePicker({
          multiple: false,
          excludeAcceptAllOption: false,
          types: [
            {
              description: "ZIP archives",
              accept: {
                "application/zip": [".zip"],
                "application/x-zip-compressed": [".zip"]
              }
            }
          ]
        });
        if (!handles.length) {
          return;
        }
        const file = await handles[0].getFile();
        await importZipFile(file);
      } catch (error) {
        if (error && error.name === "AbortError") {
          log("ZIP import canceled.");
          return;
        }
        console.error(error);
        log("Import failed: " + (error.message || String(error)), "error");
      }
      return;
    }

    zipInput.value = "";
    zipInput.click();
  }

  async function pickReplaceZipForGameId(gameId) {
    const selected = gameId ? state.gamesById.get(gameId) : null;
    if (!selected) {
      log("Choose a valid game to replace.", "error");
      return;
    }

    const importSelectedFile = async (file) => {
      if (!file) {
        return;
      }
      await importZipFile(file, {
        importMode: "replace",
        replaceGameId: selected.id
      });
    };

    if (window.showOpenFilePicker) {
      try {
        const handles = await window.showOpenFilePicker({
          multiple: false,
          excludeAcceptAllOption: false,
          types: [
            {
              description: "ZIP archives",
              accept: {
                "application/zip": [".zip"],
                "application/x-zip-compressed": [".zip"]
              }
            }
          ]
        });
        if (!handles.length) {
          return;
        }
        const file = await handles[0].getFile();
        await importSelectedFile(file);
      } catch (error) {
        if (error && error.name === "AbortError") {
          log("Replace import canceled.");
          return;
        }
        console.error(error);
        log("Replace import failed: " + (error.message || String(error)), "error");
      }
      return;
    }

    replaceZipInput.value = "";
    replaceZipInput.dataset.replaceGameId = selected.id;
    replaceZipInput.click();
  }

  function replaceGameWithZipFlow() {
    if (!state.gamesById.size) {
      log("No games available to replace yet.", "error");
      return;
    }
    openReplaceTargetGameModal();
  }

  async function importZipFile(file, options) {
    const opts = options && typeof options === "object" ? options : {};
    const requestedMode = opts.importMode === "replace" || opts.importMode === "separate"
      ? opts.importMode
      : "";
    const replaceGameId = typeof opts.replaceGameId === "string" ? opts.replaceGameId : "";
    const incomingGithubSource = normalizeGithubSource(opts.githubSource);
    const manageUi = opts.manageUi !== false;
    if (!file) {
      return;
    }
    if (!/\.zip$/i.test(file.name)) {
      log("Please choose a .zip file.", "error");
      return;
    }
    const existingGame = replaceGameId && state.gamesById.has(replaceGameId)
      ? state.gamesById.get(replaceGameId)
      : findExistingGameMatchForImport(file.name);
    let importMode = "separate";
    if (requestedMode) {
      importMode = requestedMode === "replace" && existingGame ? "replace" : "separate";
    } else if (existingGame) {
      importMode = await askImportConflictDecision(existingGame, file.name);
      if (!importMode || importMode === "cancel") {
        log("Import canceled.");
        return;
      }
    }
    if (manageUi) {
      setActionButtonsDisabled(true);
    }
    const gameId = importMode === "replace" && existingGame ? existingGame.id : makeId();
    const preservedThumbnail = importMode === "replace" && existingGame
      ? (typeof existingGame.thumbnailDataUrl === "string" ? existingGame.thumbnailDataUrl : "")
      : "";
    const preservedName = importMode === "replace" && existingGame
      ? String(existingGame.name || deriveGameName(file.name))
      : deriveGameName(file.name);
    const preservedSortOrder = importMode === "replace" && existingGame
      ? Number(existingGame.sortOrder)
      : Number.MAX_SAFE_INTEGER;
    const resolvedGithubSource = incomingGithubSource || (
      importMode === "replace" && existingGame ? normalizeGithubSource(existingGame.githubSource) : null
    );

    try {
      setWorkProgress("Reading ZIP", 0, 0);
      log("Reading ZIP: " + file.name);
      const zipBuffer = await file.arrayBuffer();
      const zip = parseZipArchive(zipBuffer);

      if (!zip.entries.length) {
        throw new Error("ZIP contains no importable files.");
      }

      const htmlEntries = zip.entries
        .map((entry) => entry.path)
        .filter((path) => /\.html?$/i.test(path))
        .sort((a, b) => a.localeCompare(b));

      const gameRecord = {
        id: gameId,
        name: preservedName,
        zipName: file.name,
        importedAt: Date.now(),
        sortOrder: Number.isFinite(preservedSortOrder) ? preservedSortOrder : getNextSortOrder(),
        fileCount: zip.entries.length,
        totalBytes: 0,
        htmlEntries,
        entryPath: chooseBestEntryPath(htmlEntries, ""),
        thumbnailDataUrl: preservedThumbnail,
        githubSource: resolvedGithubSource,
        unityDetected: detectUnityByPaths(zip.entries.map((entry) => entry.path)),
        flashDetected: detectFlashByPaths(zip.entries.map((entry) => entry.path))
      };
      if (importMode === "replace" && existingGame) {
        await deleteFilesByGameId(existingGame.id);
        log("Replacing existing game: " + (existingGame.name || existingGame.id));
      }

      let processed = 0;
      let totalBytes = 0;
      setWorkProgress("Importing game files", 0, zip.entries.length);

      for (const entry of zip.entries) {
        const entryBytes = await extractEntryBytes(zip, entry);
        const blob = new Blob([entryBytes], { type: mimeFromPath(entry.path) });
        totalBytes += blob.size;

        await putFileRecord({
          gameId,
          path: entry.path,
          size: blob.size,
          type: blob.type,
          blob
        });

        if (!gameRecord.unityDetected && /\.html?$/i.test(entry.path)) {
          try {
            const htmlText = decodeUtf8(entryBytes);
            if (detectUnityByHtmlText(htmlText)) {
              gameRecord.unityDetected = true;
            }
          } catch {
            // ignore decode errors
          }
        }

        processed += 1;
        if (processed % 20 === 0 || processed === zip.entries.length) {
          setWorkProgress("Importing game files", processed, zip.entries.length);
        }
        if (processed % 40 === 0 || processed === zip.entries.length) {
          log("Imported " + processed + "/" + zip.entries.length + " files...");
        }
      }

      gameRecord.totalBytes = totalBytes;
      await putGame(gameRecord);
      state.selectedGameId = gameId;
      await putSetting(SETTING_SELECTED_GAME, gameId);

      await loadLibrary(gameId);
      if (importMode === "replace" && existingGame) {
        log("Replaced game \"" + (existingGame.name || gameRecord.name) + "\" (" + formatBytes(totalBytes) + ")");
      } else {
        log("Saved game \"" + gameRecord.name + "\" (" + formatBytes(totalBytes) + ")");
        openGameEditModal(gameId);
      }
    } catch (error) {
      console.error(error);
      log("Import failed: " + (error.message || String(error)), "error");
      try {
        if (importMode !== "replace") {
          await deleteFilesByGameId(gameId);
          await deleteGameRecord(gameId);
        }
      } catch {
        // best effort cleanup
      }
    } finally {
      if (manageUi) {
        setActionButtonsDisabled(false);
        clearWorkProgress();
      }
    }
  }

  async function importFromGithub() {
    const input = await askGithubImportSource();
    if (!input) {
      log("GitHub import canceled.");
      return;
    }
    const repoRef = parseGithubRepoRef(input);
    const directUrl = toHttpUrl(input);
    setActionButtonsDisabled(true);
    try {
      let sourceMeta = null;
      let downloadUrl = "";
      if (repoRef) {
        setWorkProgress("Checking GitHub release", 0, 0);
        try {
          sourceMeta = await fetchLatestGithubReleaseInfo(repoRef.owner, repoRef.repo, "");
          downloadUrl = sourceMeta.downloadUrl;
        } catch (error) {
          const message = String(error && error.message ? error.message : error);
          const noRelease = /No latest release found|\/releases\/latest|no \.zip asset/i.test(message);
          if (!noRelease) {
            throw error;
          }
          setWorkProgress("No release found, reading repo tree", 0, 0);
          const snapshot = await fetchGithubRepoTreeSnapshot(repoRef.owner, repoRef.repo, "");
          const repoZipFile = await buildZipFileFromGithubTree(snapshot, "Downloading repo files");
          sourceMeta = {
            provider: "github-tree",
            owner: snapshot.owner,
            repo: snapshot.repo,
            branch: snapshot.branch,
            treeSha: snapshot.treeSha,
            lastCheckedAt: Date.now()
          };
          await importZipFile(repoZipFile, {
            githubSource: sourceMeta,
            manageUi: false
          });
          log("Imported from GitHub source.");
          return;
        }
      } else if (directUrl && /\.zip(?:$|[?#])/i.test(directUrl)) {
        sourceMeta = {
          provider: "zip-url",
          url: directUrl,
          etag: "",
          lastModified: "",
          lastCheckedAt: Date.now()
        };
        downloadUrl = directUrl;
      } else {
        throw new Error("Input must be a GitHub repo or a .zip URL.");
      }
      const download = await downloadZipFromUrl(downloadUrl, "Downloading ZIP");
      if (sourceMeta.provider === "github-release") {
        sourceMeta.etag = download.etag;
        sourceMeta.lastModified = download.lastModified;
      } else {
        sourceMeta.url = download.resolvedUrl || sourceMeta.url;
        sourceMeta.etag = download.etag;
        sourceMeta.lastModified = download.lastModified;
      }
      sourceMeta.lastCheckedAt = Date.now();
      await importZipFile(download.file, {
        githubSource: sourceMeta,
        manageUi: false
      });
      log("Imported from GitHub source.");
    } finally {
      setActionButtonsDisabled(false);
      clearWorkProgress();
    }
  }

  async function checkAllGithubUpdates() {
    const candidates = sortedGames().filter((game) => normalizeGithubSource(game.githubSource));
    if (!candidates.length) {
      log("No GitHub-linked games found in your library.", "error");
      setUpdateScanStatus("No GitHub-linked games found.");
      return;
    }

    let updatedCount = 0;
    let availableCount = 0;
    let noUpdateCount = 0;
    let stoppedByUser = false;

    setActionButtonsDisabled(true);
    try {
      setUpdateScanStatus("Checking " + candidates.length + " GitHub-linked game(s)...");
      for (let i = 0; i < candidates.length; i += 1) {
        const selected = candidates[i];
        const source = normalizeGithubSource(selected.githubSource);
        if (!source) {
          continue;
        }

        setWorkProgress("Checking updates (" + (i + 1) + "/" + candidates.length + ")", i + 1, candidates.length);

        let updateAvailable = false;
        let nextSource = source;
        let sourceLabel = "";

        if (source.provider === "github-release") {
          const latest = await fetchLatestGithubReleaseInfo(source.owner, source.repo, source.assetName);
          latest.etag = source.etag || "";
          latest.lastModified = source.lastModified || "";
          updateAvailable = githubReleaseHasUpdate(source, latest);
          nextSource = latest;
          sourceLabel = latest.releaseTag || latest.assetName || "latest release";
        } else if (source.provider === "zip-url") {
          let headInfo = null;
          try {
            headInfo = await fetchZipHeadInfo(source.url);
          } catch {
            headInfo = null;
          }
          if (headInfo) {
            updateAvailable = zipUrlHasUpdate(source, headInfo);
            nextSource = normalizeGithubSource({
              ...source,
              url: headInfo.url || source.url,
              etag: headInfo.etag || source.etag,
              lastModified: headInfo.lastModified || source.lastModified,
              lastCheckedAt: Date.now()
            }) || source;
          }
          sourceLabel = source.url;
        } else if (source.provider === "github-tree") {
          const latestTree = await fetchGithubRepoTreeSnapshot(source.owner, source.repo, source.branch);
          updateAvailable = latestTree.treeSha !== source.treeSha;
          nextSource = normalizeGithubSource({
            provider: "github-tree",
            owner: latestTree.owner,
            repo: latestTree.repo,
            branch: latestTree.branch,
            treeSha: latestTree.treeSha,
            lastCheckedAt: Date.now()
          }) || source;
          sourceLabel = source.owner + "/" + source.repo + "@" + latestTree.branch;
        }

        if (!updateAvailable) {
          noUpdateCount += 1;
          nextSource.lastCheckedAt = Date.now();
          selected.githubSource = nextSource;
          state.gamesById.set(selected.id, selected);
          await putGame(selected);
          continue;
        }

        availableCount += 1;
        const decision = await askUpdateInstallDecision(
          selected.name || "Selected game",
          sourceLabel,
          "Update " + (availableCount) + " found while checking " + (i + 1) + "/" + candidates.length + " games."
        );
        if (decision === "stop") {
          stoppedByUser = true;
          break;
        }
        if (decision !== "update") {
          log("Skipped update for \"" + (selected.name || selected.id) + "\".");
          continue;
        }

        if (source.provider === "github-tree") {
          const latestTree = await fetchGithubRepoTreeSnapshot(source.owner, source.repo, source.branch);
          const repoZipFile = await buildZipFileFromGithubTree(latestTree, "Downloading repo files");
          const mergedSource = normalizeGithubSource({
            provider: "github-tree",
            owner: latestTree.owner,
            repo: latestTree.repo,
            branch: latestTree.branch,
            treeSha: latestTree.treeSha,
            lastCheckedAt: Date.now()
          });
          await importZipFile(repoZipFile, {
            importMode: "replace",
            replaceGameId: selected.id,
            githubSource: mergedSource,
            manageUi: false
          });
        } else {
          const downloadUrl = source.provider === "github-release"
            ? String(nextSource.downloadUrl || source.downloadUrl || "")
            : String(source.url || "");
          const download = await downloadZipFromUrl(downloadUrl, "Downloading update");
          const mergedSource = normalizeGithubSource(
            source.provider === "github-release"
              ? {
                  ...nextSource,
                  etag: download.etag || nextSource.etag,
                  lastModified: download.lastModified || nextSource.lastModified,
                  lastCheckedAt: Date.now()
                }
              : {
                  ...nextSource,
                  url: download.resolvedUrl || source.url,
                  etag: download.etag || nextSource.etag,
                  lastModified: download.lastModified || nextSource.lastModified,
                  lastCheckedAt: Date.now()
                }
          );
          await importZipFile(download.file, {
            importMode: "replace",
            replaceGameId: selected.id,
            githubSource: mergedSource,
            manageUi: false
          });
        }
        updatedCount += 1;
        log("Updated \"" + (selected.name || selected.id) + "\".");
      }

      log(
        "GitHub update check complete. " +
        updatedCount + " updated, " +
        noUpdateCount + " already up to date, " +
        Math.max(0, availableCount - updatedCount) + " updates skipped." +
        (stoppedByUser ? " Stopped early." : "")
      );
      if (availableCount === 0) {
        setUpdateScanStatus("All checked games are already up to date.");
      } else {
        setUpdateScanStatus(
          updatedCount + " updated, " +
          Math.max(0, availableCount - updatedCount) + " skipped, " +
          noUpdateCount + " already up to date" +
          (stoppedByUser ? " (stopped early)." : ".")
        );
      }
    } finally {
      const updateResolver = closeUpdatePromptModal();
      if (updateResolver) {
        updateResolver("stop");
      }
      setActionButtonsDisabled(false);
      clearWorkProgress();
    }
  }

  function isZipLikeFile(file) {
    if (!file) {
      return false;
    }
    const name = String(file.name || "");
    const type = String(file.type || "").toLowerCase();
    return (
      /\.zip$/i.test(name) ||
      type === "application/zip" ||
      type === "application/x-zip-compressed"
    );
  }

  function hasDragFiles(event) {
    const types = event && event.dataTransfer && event.dataTransfer.types
      ? Array.from(event.dataTransfer.types)
      : [];
    return types.includes("Files");
  }

  function setDragDropOverlay(visible, label) {
    if (!dragDropOverlay) {
      return;
    }
    dragDropOverlay.classList.toggle("open", Boolean(visible));
    dragDropOverlay.setAttribute("aria-hidden", visible ? "false" : "true");
    if (dragDropOverlayText && typeof label === "string" && label.trim()) {
      dragDropOverlayText.textContent = label;
    } else if (dragDropOverlayText) {
      dragDropOverlayText.textContent = "Drop ZIP files to import";
    }
  }

  async function detectDroppedZipKind(file) {
    if (!isZipLikeFile(file)) {
      return "not-zip";
    }

    let parsedZip;
    try {
      const buffer = await file.arrayBuffer();
      parsedZip = parseZipArchive(buffer);
    } catch {
      return "invalid-zip";
    }

    const entryByPath = new Map(parsedZip.entries.map((entry) => [normalizePath(entry.path), entry]));
    const manifestEntry = entryByPath.get("bundle.json");
    if (!manifestEntry) {
      return "game";
    }

    try {
      const bytes = await extractEntryBytes(parsedZip, manifestEntry);
      const parsed = JSON.parse(decodeUtf8(bytes));
      if (parsed && parsed.format === "cbgames-zip-v2" && Array.isArray(parsed.games)) {
        return "bundle";
      }
    } catch {
      // treat malformed bundle marker as regular game ZIP
    }

    return "game";
  }

  async function handleDroppedZipFiles(fileList) {
    const files = Array.from(fileList || []);
    const zipFiles = files.filter((file) => isZipLikeFile(file));
    if (!zipFiles.length) {
      log("Drop one or more .zip files.", "error");
      return;
    }

    for (const file of zipFiles) {
      try {
        setDragDropOverlay(true, "Inspecting " + file.name + "...");
        const kind = await detectDroppedZipKind(file);
        setDragDropOverlay(false);

        if (kind === "not-zip") {
          log("Skipped non-zip file: " + file.name, "error");
          continue;
        }
        if (kind === "invalid-zip") {
          log("Could not read ZIP: " + file.name, "error");
          continue;
        }

        if (kind === "bundle") {
          log("Detected bundle ZIP: " + file.name);
          await importBundleFile(file);
        } else {
          log("Detected game ZIP: " + file.name);
          await importZipFile(file);
        }
      } catch (error) {
        console.error(error);
        log("Drop import failed for " + file.name + ": " + (error.message || String(error)), "error");
      } finally {
        setDragDropOverlay(false);
      }
    }
  }

  function clearObjectUrls() {
    let host = window;
    try {
      if (
        state.objectUrlHost &&
        state.objectUrlHost.URL &&
        typeof state.objectUrlHost.URL.createObjectURL === "function" &&
        typeof state.objectUrlHost.URL.revokeObjectURL === "function"
      ) {
        host = state.objectUrlHost;
      }
    } catch {
      host = window;
    }
    for (const url of state.objectUrls.values()) {
      try {
        host.URL.revokeObjectURL(url);
      } catch {
        URL.revokeObjectURL(url);
      }
    }
    state.objectUrls.clear();
    state.objectUrlHost = window;
  }

  function rewriteCssText(cssText, cssPath) {
    if (typeof cssText !== "string" || !cssText) {
      return cssText;
    }
    const baseHref = toVirtualUrl(cssPath);
    return cssText.replace(/url\(\s*(['"]?)([^"')]+)\1\s*\)/gi, (full, quote, urlPath) => {
      const raw = String(urlPath || "").trim();
      if (!raw) {
        return full;
      }
      const lower = raw.toLowerCase();
      if (
        lower.startsWith("data:") ||
        lower.startsWith("blob:") ||
        lower.startsWith("about:")
      ) {
        return full;
      }
      const mapped = requestToObjectUrl(raw, baseHref);
      if (!mapped) {
        return full;
      }
      const wrapped = quote || "\"";
      return "url(" + wrapped + mapped + wrapped + ")";
    });
  }

  function bytesToBase64(bytes) {
    if (!(bytes instanceof Uint8Array)) {
      return "";
    }
    const chunkSize = 0x8000;
    let out = "";
    for (let offset = 0; offset < bytes.length; offset += chunkSize) {
      const slice = bytes.subarray(offset, Math.min(offset + chunkSize, bytes.length));
      out += String.fromCharCode.apply(null, slice);
    }
    return btoa(out);
  }

  function textToBase64(text) {
    return btoa(unescape(encodeURIComponent(String(text || ""))));
  }

  function base64ToBytes(base64Text) {
    const base64 = String(base64Text || "");
    const binary = atob(base64);
    const out = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i += 1) {
      out[i] = binary.charCodeAt(i);
    }
    return out;
  }

  function encodeUtf8(text) {
    return new TextEncoder().encode(String(text || ""));
  }

  function decodeUtf8(bytes) {
    return new TextDecoder("utf-8").decode(bytes);
  }

  function concatUint8Arrays(chunks) {
    let totalLength = 0;
    for (const chunk of chunks) {
      totalLength += chunk.length;
    }
    const out = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      out.set(chunk, offset);
      offset += chunk.length;
    }
    return out;
  }

  function extensionFromMime(mime) {
    const type = String(mime || "").toLowerCase();
    if (type === "image/png") return ".png";
    if (type === "image/jpeg") return ".jpg";
    if (type === "image/webp") return ".webp";
    if (type === "image/gif") return ".gif";
    return "";
  }

  function parseDataUrlToBytes(dataUrl) {
    const text = String(dataUrl || "");
    const match = text.match(/^data:([^;,]+)?(?:;charset=[^;,]+)?(?:;(base64))?,([\s\S]*)$/i);
    if (!match) {
      return null;
    }
    const mime = (match[1] || "application/octet-stream").toLowerCase();
    const isBase64 = Boolean(match[2]);
    const payload = match[3] || "";
    if (isBase64) {
      return {
        mime,
        bytes: base64ToBytes(payload)
      };
    }
    const decoded = decodeURIComponent(payload);
    const out = new Uint8Array(decoded.length);
    for (let i = 0; i < decoded.length; i += 1) {
      out[i] = decoded.charCodeAt(i);
    }
    return { mime, bytes: out };
  }

  function setActionButtonsDisabled(disabled) {
    const value = Boolean(disabled);
    state.actionInProgress = value;
    importZipButton.disabled = value;
    replaceZipSelectedButton.disabled = value;
    openOpsModalButton.disabled = value;
    launchButton.disabled = value;
    deleteGameButton.disabled = value;
    exportAllGamesButton.disabled = value;
    importBundleButton.disabled = value;
    importGithubButton.disabled = value;
    checkGithubUpdateButton.disabled = value;
    exportErrorLogsButton.disabled = value;
    closeOpsModalButton.disabled = value;
  }

  function showOpsModal() {
    if (!opsModal) {
      return;
    }
    opsModal.classList.add("open");
    opsModal.setAttribute("aria-hidden", "false");
    if (!state.actionInProgress && importZipButton) {
      importZipButton.focus();
    }
  }

  function hideOpsModal(force) {
    if (!opsModal) {
      return false;
    }
    if (state.actionInProgress && !force) {
      return false;
    }
    opsModal.classList.remove("open");
    opsModal.setAttribute("aria-hidden", "true");
    if (openOpsModalButton && !openOpsModalButton.disabled) {
      openOpsModalButton.focus();
    }
    return true;
  }

  function getGridReorderElements() {
    return Array.from(gamesGrid.querySelectorAll(".game-item[data-game-id]"));
  }

  function cleanupReorderHoldTimer() {
    if (state.reorder.holdTimer) {
      clearTimeout(state.reorder.holdTimer);
      state.reorder.holdTimer = 0;
    }
    if (state.reorder.holdMoveListener) {
      window.removeEventListener("pointermove", state.reorder.holdMoveListener, true);
      state.reorder.holdMoveListener = null;
    }
  }

  function applyGridShiftAnimation(beforeRects) {
    const elements = getGridReorderElements().concat(
      state.reorder.placeholder ? [state.reorder.placeholder] : []
    );
    for (const el of elements) {
      const key = el.dataset.gameId ? "game:" + el.dataset.gameId : "gap";
      const prev = beforeRects.get(key);
      if (!prev) {
        continue;
      }
      const next = el.getBoundingClientRect();
      const dx = prev.left - next.left;
      const dy = prev.top - next.top;
      if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) {
        continue;
      }
      const existingAnimation = reorderAnimations.get(el);
      if (existingAnimation) {
        try {
          existingAnimation.cancel();
        } catch {
          // ignore cancel issues
        }
      }
      if (typeof el.animate !== "function") {
        continue;
      }
      const animation = el.animate(
        [
          { transform: "translate(" + dx + "px," + dy + "px)" },
          { transform: "translate(0px,0px)" }
        ],
        {
          duration: 180,
          easing: "cubic-bezier(0.2, 0.8, 0.2, 1)",
          fill: "none"
        }
      );
      reorderAnimations.set(el, animation);
    }
  }

  function moveReorderPlaceholderBefore(targetNode) {
    const placeholder = state.reorder.placeholder;
    if (!placeholder || !targetNode || placeholder === targetNode || placeholder.nextSibling === targetNode) {
      return;
    }
    const beforeRects = new Map();
    for (const el of getGridReorderElements()) {
      beforeRects.set("game:" + el.dataset.gameId, el.getBoundingClientRect());
    }
    beforeRects.set("gap", placeholder.getBoundingClientRect());
    gamesGrid.insertBefore(placeholder, targetNode);
    applyGridShiftAnimation(beforeRects);
  }

  function moveReorderPlaceholderToEnd() {
    const placeholder = state.reorder.placeholder;
    if (!placeholder || gamesGrid.lastElementChild === placeholder) {
      return;
    }
    const beforeRects = new Map();
    for (const el of getGridReorderElements()) {
      beforeRects.set("game:" + el.dataset.gameId, el.getBoundingClientRect());
    }
    beforeRects.set("gap", placeholder.getBoundingClientRect());
    gamesGrid.append(placeholder);
    applyGridShiftAnimation(beforeRects);
  }

  function updateReorderGhostPosition(clientX, clientY) {
    const ghost = state.reorder.ghost;
    if (!ghost) {
      return;
    }
    ghost.style.left = Math.round(clientX - state.reorder.pointerOffsetX) + "px";
    ghost.style.top = Math.round(clientY - state.reorder.pointerOffsetY) + "px";
  }

  function reorderPointerMove(event) {
    if (!state.reorder.active) {
      return;
    }
    if (event.pointerId !== state.reorder.pointerId) {
      return;
    }
    event.preventDefault();
    updateReorderGhostPosition(event.clientX, event.clientY);
    const hovered = document.elementFromPoint(event.clientX, event.clientY);
    const item = hovered instanceof Element ? hovered.closest(".game-item") : null;
    if (!item || !item.dataset || !item.dataset.gameId || item === state.reorder.sourceElement) {
      return;
    }
    const rect = item.getBoundingClientRect();
    const insertAfter = event.clientX > rect.left + rect.width / 2;
    if (insertAfter) {
      if (!item.nextSibling) {
        moveReorderPlaceholderToEnd();
        return;
      }
      moveReorderPlaceholderBefore(item.nextSibling);
    } else {
      moveReorderPlaceholderBefore(item);
    }
  }

  async function persistGridOrderFromDom() {
    const ids = getGridReorderElements()
      .map((el) => String(el.dataset.gameId || ""))
      .filter((id) => id && state.gamesById.has(id));
    let changed = false;
    for (let i = 0; i < ids.length; i += 1) {
      const game = state.gamesById.get(ids[i]);
      if (!game) {
        continue;
      }
      if (Number(game.sortOrder) !== i) {
        game.sortOrder = i;
        state.gamesById.set(game.id, game);
        changed = true;
      }
    }
    if (!changed) {
      return;
    }
    for (const game of sortedGames()) {
      await putGame(game);
    }
  }

  async function finishCardReorder() {
    if (!state.reorder.active) {
      return;
    }
    const { sourceElement, placeholder, ghost } = state.reorder;
    try {
      if (sourceElement && placeholder && placeholder.parentElement === gamesGrid) {
        gamesGrid.insertBefore(sourceElement, placeholder);
      }
      if (placeholder && placeholder.parentElement) {
        placeholder.remove();
      }
      if (ghost && ghost.parentElement) {
        ghost.remove();
      }
      if (sourceElement) {
        sourceElement.classList.remove("is-drag-source");
      }
      await persistGridOrderFromDom();
      renderGameOptions(state.selectedGameId);
      updateSelectedGameInfo(state.selectedGameId ? state.gamesById.get(state.selectedGameId) : null);
      state.suppressCardClickUntil = Date.now() + 250;
    } finally {
      state.reorder.active = false;
      state.reorder.pointerId = null;
      state.reorder.sourceGameId = "";
      state.reorder.sourceElement = null;
      state.reorder.placeholder = null;
      state.reorder.ghost = null;
      state.reorder.pointerOffsetX = 0;
      state.reorder.pointerOffsetY = 0;
      window.removeEventListener("pointermove", reorderPointerMove);
      window.removeEventListener("pointerup", reorderPointerUp, true);
      window.removeEventListener("pointercancel", reorderPointerUp, true);
    }
  }

  function reorderPointerUp(event) {
    if (state.reorder.active && event.pointerId === state.reorder.pointerId) {
      event.preventDefault();
      finishCardReorder().catch((error) => {
        console.error(error);
        log("Could not save card order.", "error");
      });
    }
    cleanupReorderHoldTimer();
    state.reorder.pointerId = null;
    state.reorder.startTarget = null;
  }

  function startCardReorder(gameId, sourceElement, pointerEvent) {
    if (!sourceElement || !gameId || !state.gamesById.has(gameId)) {
      return;
    }
    setSelectedGameImmediate(gameId, { persist: true, updateCardStyles: false });
    state.reorder.active = true;
    cleanupReorderHoldTimer();
    state.reorder.sourceGameId = gameId;
    state.reorder.sourceElement = sourceElement;

    const rect = sourceElement.getBoundingClientRect();
    const placeholder = document.createElement("div");
    placeholder.className = "drag-gap";
    placeholder.style.height = Math.max(88, rect.height) + "px";
    placeholder.style.minHeight = Math.max(88, rect.height) + "px";
    state.reorder.placeholder = placeholder;

    const ghost = sourceElement.cloneNode(true);
    ghost.classList.add("reorder-ghost");
    ghost.style.width = Math.round(rect.width) + "px";
    ghost.style.left = Math.round(rect.left) + "px";
    ghost.style.top = Math.round(rect.top) + "px";
    state.reorder.ghost = ghost;

    state.reorder.pointerOffsetX = rect.width / 2;
    state.reorder.pointerOffsetY = rect.height / 2;

    sourceElement.classList.add("is-drag-source");
    gamesGrid.insertBefore(placeholder, sourceElement);
    sourceElement.remove();
    document.body.append(ghost);
    updateReorderGhostPosition(pointerEvent.clientX, pointerEvent.clientY);

    window.addEventListener("pointermove", reorderPointerMove, { passive: false });
    window.addEventListener("pointerup", reorderPointerUp, true);
    window.addEventListener("pointercancel", reorderPointerUp, true);
  }

  function normalizeErrorText(value, maxLength = 4000) {
    const text = String(value == null ? "" : value).replace(/\s+/g, " ").trim();
    if (!text) {
      return "";
    }
    if (text.length <= maxLength) {
      return text;
    }
    return text.slice(0, Math.max(0, maxLength - 3)) + "...";
  }

  async function persistPlayerError(payload) {
    if (!payload || typeof payload !== "object") {
      return;
    }
    const incomingGameId = typeof payload.gameId === "string" ? payload.gameId : "";
    const resolvedGame = incomingGameId ? state.gamesById.get(incomingGameId) : null;
    const gameId = resolvedGame ? resolvedGame.id : incomingGameId;
    const gameName = resolvedGame
      ? (resolvedGame.name || "")
      : (typeof payload.gameName === "string" ? payload.gameName : "");
    const record = {
      id: makeId(),
      timestamp: Number(payload.timestamp) || Date.now(),
      level: normalizeErrorText(payload.level || "error", 16) || "error",
      kind: normalizeErrorText(payload.kind || "runtime", 80) || "runtime",
      message: normalizeErrorText(payload.message || "Unknown error"),
      source: normalizeErrorText(payload.source || "", 1000),
      lineno: Number(payload.lineno) || 0,
      colno: Number(payload.colno) || 0,
      stack: normalizeErrorText(payload.stack || "", 20000),
      gameId,
      gameName: normalizeErrorText(gameName, 300),
      entryPath: normalizePath(payload.entryPath || "")
    };
    await putErrorLogRecord(record);
    log("[Game Error] " + (record.gameName || record.gameId || "Unknown game") + ": " + record.message, "error");
  }

  async function downloadErrorLogs() {
    setActionButtonsDisabled(true);
    try {
      setWorkProgress("Preparing error log export", 0, 0);
      const logs = await getAllErrorLogRecords();
      if (!logs.length) {
        throw new Error("No saved game error logs to export.");
      }
      logs.sort((a, b) => (Number(a.timestamp) || 0) - (Number(b.timestamp) || 0));
      const payload = {
        format: "cbgames-error-logs-v1",
        exportedAt: Date.now(),
        totalLogs: logs.length,
        logs
      };
      const json = JSON.stringify(payload, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const stamp = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = "cbgames-error-logs-" + stamp + ".json";
      const url = URL.createObjectURL(blob);
      try {
        const anchor = document.createElement("a");
        anchor.href = url;
        anchor.download = filename;
        document.body.append(anchor);
        anchor.click();
        anchor.remove();
      } finally {
        URL.revokeObjectURL(url);
      }
      log("Exported " + logs.length + " error log(s) to " + filename + ".");
    } finally {
      setActionButtonsDisabled(false);
      clearWorkProgress();
    }
  }

  function setWorkProgress(label, current, total, displayValues) {
    if (!workProgress || !workProgressLabel || !workProgressCircle || !workProgressValue) {
      return;
    }
    const text = String(label || "Working...");
    const hasTotal = Number.isFinite(total) && total > 0;
    const safeCurrent = Number.isFinite(current) ? Math.max(0, current) : 0;
    const safeTotal = hasTotal ? Math.max(1, total) : 0;
    if (hasTotal) {
      const pct = Math.max(0, Math.min(100, (safeCurrent / safeTotal) * 100));
      const hasDisplayValues = displayValues && typeof displayValues === "object";
      const currentText = hasDisplayValues && typeof displayValues.currentText === "string"
        ? displayValues.currentText
        : String(Math.min(safeCurrent, safeTotal));
      const totalText = hasDisplayValues && typeof displayValues.totalText === "string"
        ? displayValues.totalText
        : String(safeTotal);
      workProgress.classList.remove("indeterminate");
      workProgressLabel.textContent = text + " (" + currentText + "/" + totalText + ")";
      workProgressCircle.style.setProperty("--progress-pct", pct.toFixed(1));
      workProgressValue.textContent = Math.round(pct) + "%";
      return;
    }
    workProgress.classList.add("indeterminate");
    workProgressLabel.textContent = text;
    workProgressCircle.style.setProperty("--progress-pct", "25");
    workProgressValue.textContent = "...";
  }

  function clearWorkProgress() {
    if (!workProgress || !workProgressLabel || !workProgressCircle || !workProgressValue) {
      return;
    }
    workProgress.classList.remove("indeterminate");
    workProgressLabel.textContent = "Idle...";
    workProgressCircle.style.setProperty("--progress-pct", "0");
    workProgressValue.textContent = "0%";
  }
  function findReferencedWasmPath(scriptText, scriptPath, recordsByPath) {
    if (typeof scriptText !== "string" || !scriptText) {
      return null;
    }
    const baseHref = toVirtualUrl(scriptPath);
    const candidates = [];
    const refMatches = scriptText.matchAll(/(["'])([^"'\\]*?\.wasm(?:\.[^"'\\\/?#]+)?)\1/g);
    for (const match of refMatches) {
      const rawRef = match[2];
      if (rawRef) {
        candidates.push(rawRef);
      }
    }
    candidates.push(scriptPath.replace(/\.wasm\.js$/i, ".wasm.wasm"));
    candidates.push(scriptPath.replace(/\.js$/i, ".wasm"));
    candidates.push(scriptPath.replace(/\.js$/i, ".wasm.wasm"));

    for (const rawRef of candidates) {
      const resolvedFromBase = resolveToPath(rawRef, baseHref);
      if (resolvedFromBase && recordsByPath.has(resolvedFromBase)) {
        return { rawRef, path: resolvedFromBase };
      }
      const resolvedFromRoot = resolveToPath(rawRef, VFS_ORIGIN);
      if (resolvedFromRoot && recordsByPath.has(resolvedFromRoot)) {
        return { rawRef, path: resolvedFromRoot };
      }
      if (resolvedFromRoot) {
        const basePath = resolveToPath(baseHref, VFS_ORIGIN);
        let probeDir = basePath ? dirnamePath(basePath) : "";
        while (probeDir) {
          const candidate = normalizePath(probeDir + "/" + resolvedFromRoot);
          if (recordsByPath.has(candidate)) {
            return { rawRef, path: candidate };
          }
          probeDir = dirnamePath(probeDir);
        }
      }
    }
    return null;
  }

  function replaceFirstWasmRef(scriptText, rawRef, dataUrl) {
    if (typeof scriptText !== "string") {
      return scriptText;
    }
    const replacement = JSON.stringify(dataUrl);
    const doubleQuoted = JSON.stringify(rawRef);
    if (scriptText.includes(doubleQuoted)) {
      return scriptText.replace(doubleQuoted, replacement);
    }
    const singleQuoted = "'" + String(rawRef).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
    if (scriptText.includes(singleQuoted)) {
      return scriptText.replace(singleQuoted, replacement);
    }
    return scriptText;
  }

  function shouldInlineWasmForScript(scriptPath, scriptText) {
    const path = String(scriptPath || "");
    const text = String(scriptText || "");
    return /(?:^|\/)ammo\.wasm\.js$/i.test(path) || /ammo\.wasm\.wasm/i.test(text);
  }

  async function patchEmscriptenWasmScriptText(scriptText, scriptPath, recordsByPath, dataUrlCache) {
    if (typeof scriptText !== "string" || !scriptText || !scriptPath) {
      return scriptText;
    }
    if (!shouldInlineWasmForScript(scriptPath, scriptText)) {
      return scriptText;
    }
    const wasmRef = findReferencedWasmPath(scriptText, scriptPath, recordsByPath);
    if (!wasmRef) {
      return scriptText;
    }

    const wasmPath = wasmRef.path;
    const wasmRecord = recordsByPath.get(wasmPath);
    if (!wasmRecord) {
      return scriptText;
    }

    let wasmDataUrl = dataUrlCache.get(wasmPath) || "";
    if (!wasmDataUrl) {
      const wasmBytes = new Uint8Array(await wasmRecord.blob.arrayBuffer());
      wasmDataUrl = "data:application/wasm;base64," + bytesToBase64(wasmBytes);
      dataUrlCache.set(wasmPath, wasmDataUrl);
    }

    const wasmRefRaw = String(wasmRef.rawRef || "");
    const marker = "if(!F(O=" + JSON.stringify(wasmRefRaw) + ")){var L=O;O=n.locateFile?n.locateFile(L,u):u+L}";
    const forcedWasmAssign = "O=" + JSON.stringify(wasmDataUrl) + ";";
    if (scriptText.includes(marker)) {
      return scriptText.replace(marker, forcedWasmAssign);
    }
    return replaceFirstWasmRef(scriptText, wasmRefRaw, wasmDataUrl);
  }

  async function buildEmscriptenInlineDataUrl(scriptPath, recordsByPath, dataUrlCache) {
    if (!scriptPath) {
      return null;
    }
    const scriptRecord = recordsByPath.get(scriptPath);
    if (!scriptRecord) {
      return null;
    }

    const scriptText = await scriptRecord.blob.text();
    if (!shouldInlineWasmForScript(scriptPath, scriptText)) {
      return null;
    }
    const wasmRef = findReferencedWasmPath(scriptText, scriptPath, recordsByPath);
    if (!wasmRef) {
      return null;
    }

    const wasmPath = wasmRef.path;
    const wasmRecord = recordsByPath.get(wasmPath);
    if (!wasmRecord) {
      return null;
    }

    const cacheKey = "__ems_inline__:" + scriptPath + ":" + wasmPath;
    if (dataUrlCache.has(cacheKey)) {
      return dataUrlCache.get(cacheKey);
    }

    let wasmDataUrl = dataUrlCache.get(wasmPath) || "";
    if (!wasmDataUrl) {
      const wasmBytes = new Uint8Array(await wasmRecord.blob.arrayBuffer());
      wasmDataUrl = "data:application/wasm;base64," + bytesToBase64(wasmBytes);
      dataUrlCache.set(wasmPath, wasmDataUrl);
    }

    const wasmRefRaw = String(wasmRef.rawRef || "");
    const patchedScriptText = await patchEmscriptenWasmScriptText(
      scriptText,
      scriptPath,
      recordsByPath,
      dataUrlCache
    );

    const wasmBasename = String(wasmPath).split("/").pop() || "";
    const loaderKeys = [wasmRefRaw, wasmBasename].filter((value, index, arr) => value && arr.indexOf(value) === index);
    const prelude =
      "(function(){var __loaderWasmUrl=" + JSON.stringify(wasmDataUrl) + ";" +
      "var __loaderWasmKeys=" + JSON.stringify(loaderKeys) + ";" +
      "function __isLoaderWasmPath(path){if(typeof path!=='string'){return false;}for(var i=0;i<__loaderWasmKeys.length;i++){if(path===__loaderWasmKeys[i]){return true;}}return false;}" +
      "self.Module=self.Module||{};" +
      "var __prevLocate=self.Module.locateFile;" +
      "self.Module.locateFile=function(path,prefix){" +
      "if(__isLoaderWasmPath(path)){return __loaderWasmUrl;}" +
      "if(typeof __prevLocate==='function'){return __prevLocate(path,prefix);}" +
      "return (prefix||'')+path;};" +
      "if(typeof self.fetch==='function'){var __prevFetch=self.fetch.bind(self);self.fetch=function(input,init){if(__isLoaderWasmPath(input)){input=__loaderWasmUrl;}return __prevFetch(input,init);};}" +
      "if(typeof XMLHttpRequest==='function'){var __prevOpen=XMLHttpRequest.prototype.open;XMLHttpRequest.prototype.open=function(method,url){if(__isLoaderWasmPath(url)){url=__loaderWasmUrl;}return __prevOpen.apply(this,[method,url].concat(Array.prototype.slice.call(arguments,2)));};}" +
      "})();\n";
    const dataUrl = "data:application/javascript;base64," + textToBase64(prelude + patchedScriptText);
    dataUrlCache.set(cacheKey, dataUrl);
    return dataUrl;
  }

  async function buildInlineScriptDataUrl(scriptPath, recordsByPath, dataUrlCache) {
    if (!scriptPath) {
      return null;
    }
    const cacheKey = "__js_inline__:" + scriptPath;
    if (dataUrlCache.has(cacheKey)) {
      return dataUrlCache.get(cacheKey);
    }
    const scriptRecord = recordsByPath.get(scriptPath);
    if (!scriptRecord) {
      return null;
    }
    const scriptText = await scriptRecord.blob.text();
    const dataUrl = "data:application/javascript;base64," + textToBase64(scriptText);
    dataUrlCache.set(cacheKey, dataUrl);
    return dataUrl;
  }

  async function rewriteImportScriptsText(scriptText, scriptPath, recordsByPath, dataUrlCache) {
    if (typeof scriptText !== "string" || !scriptText) {
      return scriptText;
    }
    const baseHref = toVirtualUrl(scriptPath);
    const matches = Array.from(scriptText.matchAll(/importScripts\(([^)]*)\)/g));
    if (!matches.length) {
      return scriptText;
    }

    let rewritten = "";
    let cursor = 0;
    for (const match of matches) {
      const full = match[0];
      const argsText = match[1];
      const start = match.index || 0;
      const end = start + full.length;
      rewritten += scriptText.slice(cursor, start);
      if (!argsText || typeof argsText !== "string") {
        rewritten += full;
        cursor = end;
        continue;
      }

      let argsOut = "";
      let argCursor = 0;
      const argMatches = Array.from(argsText.matchAll(/(['"])([^"'\\]+)\1/g));
      for (const argMatch of argMatches) {
        const segment = argMatch[0];
        const quote = argMatch[1];
        const rawPath = argMatch[2];
        const segStart = argMatch.index || 0;
        const segEnd = segStart + segment.length;
        argsOut += argsText.slice(argCursor, segStart);

        const resolvedPath = resolveToPath(rawPath, baseHref);
        let mapped = requestToObjectUrl(rawPath, baseHref);
        if (resolvedPath && /\.(?:js|mjs|cjs)$/i.test(resolvedPath)) {
          const emscriptenInlineUrl = await buildEmscriptenInlineDataUrl(
            resolvedPath,
            recordsByPath,
            dataUrlCache
          );
          if (emscriptenInlineUrl) {
            mapped = emscriptenInlineUrl;
          } else {
            const inlineScriptUrl = await buildInlineScriptDataUrl(
              resolvedPath,
              recordsByPath,
              dataUrlCache
            );
            if (inlineScriptUrl) {
              mapped = inlineScriptUrl;
            }
          }
        }

        if (!mapped) {
          argsOut += segment;
        } else {
          argsOut += quote + mapped + quote;
        }
        argCursor = segEnd;
      }
      argsOut += argsText.slice(argCursor);
      rewritten += "importScripts(" + argsOut + ")";
      cursor = end;
    }
    rewritten += scriptText.slice(cursor);
    return rewritten;
  }

  function isUnityWebConfigObject(value) {
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      return false;
    }
    if (typeof value.dataUrl !== "string") {
      return false;
    }
    return (
      typeof value.asmCodeUrl === "string" ||
      typeof value.wasmCodeUrl === "string" ||
      typeof value.asmFrameworkUrl === "string" ||
      typeof value.frameworkUrl === "string"
    );
  }

  function rewriteUnityWebConfigText(jsonText, path) {
    if (!UNITY_GPU_SAFE_MODE || typeof jsonText !== "string" || !/\.json$/i.test(path)) {
      return { text: jsonText, changed: false };
    }

    let config;
    try {
      config = JSON.parse(jsonText);
    } catch {
      return { text: jsonText, changed: false };
    }

    if (!isUnityWebConfigObject(config)) {
      return { text: jsonText, changed: false };
    }

    let changed = false;
    if (UNITY_FORCE_WEBGL1) {
      const currentApis = Array.isArray(config.graphicsAPI)
        ? config.graphicsAPI.map((api) => String(api))
        : [];
      const supportsWebGL1 = currentApis.some((api) => api === "WebGL 1.0");
      if (supportsWebGL1 || !currentApis.length) {
        const nextApis = ["WebGL 1.0"];
        if (
          currentApis.length !== nextApis.length ||
          currentApis.some((api, index) => api !== nextApis[index])
        ) {
          config.graphicsAPI = nextApis;
          changed = true;
        }
      }
    }

    const nextContextAttrs = {
      ...(config.webglContextAttributes && typeof config.webglContextAttributes === "object"
        ? config.webglContextAttributes
        : {})
    };
    const requiredAttrs = {
      antialias: false,
      alpha: false,
      stencil: false,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false,
      desynchronized: true,
      powerPreference: "low-power"
    };
    for (const [key, value] of Object.entries(requiredAttrs)) {
      if (nextContextAttrs[key] !== value) {
        nextContextAttrs[key] = value;
        changed = true;
      }
    }
    config.webglContextAttributes = nextContextAttrs;

    const forcedDpr = Number(UNITY_CLAMP_DEVICE_PIXEL_RATIO);
    if (forcedDpr > 0 && Number(config.devicePixelRatio) !== forcedDpr) {
      config.devicePixelRatio = forcedDpr;
      changed = true;
    }

    if (!changed) {
      return { text: jsonText, changed: false };
    }

    return {
      text: JSON.stringify(config),
      changed: true
    };
  }

  async function buildObjectUrlCacheFromRecords(records, hostWindow) {
    let host = window;
    try {
      if (
        hostWindow &&
        hostWindow.URL &&
        typeof hostWindow.URL.createObjectURL === "function" &&
        typeof hostWindow.URL.revokeObjectURL === "function"
      ) {
        host = hostWindow;
      }
    } catch {
      host = window;
    }
    clearObjectUrls();
    state.objectUrlHost = host;
    const recordsByPath = new Map(records.map((record) => [record.path, record]));
    const dataUrlCache = new Map();

    for (const record of records) {
      state.objectUrls.set(record.path, host.URL.createObjectURL(record.blob));
    }

    let rewrittenCssCount = 0;
    let rewrittenUnityConfigCount = 0;
    for (const record of records) {
      try {
        let rewrittenText = "";
        let rewrittenMime = "";

        if (/\.css$/i.test(record.path)) {
          const originalText = await record.blob.text();
          rewrittenText = rewriteCssText(originalText, record.path);
          if (rewrittenText === originalText) {
            continue;
          }
          rewrittenMime = "text/css";
          rewrittenCssCount += 1;
        } else if (/\.json$/i.test(record.path)) {
          const originalText = await record.blob.text();
          const rewrite = rewriteUnityWebConfigText(originalText, record.path);
          if (!rewrite.changed) {
            continue;
          }
          rewrittenText = rewrite.text;
          rewrittenMime = "application/json";
          rewrittenUnityConfigCount += 1;
        } else if (/\.(?:js|mjs|cjs)$/i.test(record.path)) {
          const originalText = await record.blob.text();
          const emsPatchedText = await patchEmscriptenWasmScriptText(
            originalText,
            record.path,
            recordsByPath,
            dataUrlCache
          );
          rewrittenText = await rewriteImportScriptsText(
            emsPatchedText,
            record.path,
            recordsByPath,
            dataUrlCache
          );
          if (rewrittenText === originalText) {
            continue;
          }
          rewrittenMime = "application/javascript";
        } else {
          continue;
        }

        const oldUrl = state.objectUrls.get(record.path);
        const rewrittenBlob = new Blob([rewrittenText], {
          type: rewrittenMime || record.type || mimeFromPath(record.path)
        });
        record.blob = rewrittenBlob;
        record.size = rewrittenBlob.size;
        record.type = rewrittenBlob.type;
        const rewrittenUrl = host.URL.createObjectURL(rewrittenBlob);
        state.objectUrls.set(record.path, rewrittenUrl);
        if (oldUrl) {
          host.URL.revokeObjectURL(oldUrl);
        }
      } catch (error) {
        console.error(error);
        log("Failed to rewrite asset " + record.path + ".", "error");
      }
    }

    if (rewrittenCssCount > 0) {
      log("Rewrote " + rewrittenCssCount + " stylesheet(s) for local asset URLs.");
    }
    if (rewrittenUnityConfigCount > 0) {
      log("Applied Unity GPU-safe config to " + rewrittenUnityConfigCount + " Web config file(s).");
    }
  }

  function rewriteSrcSet(value, baseHref) {
    if (typeof value !== "string") {
      return value;
    }
    let changed = false;
    const items = value.split(",");
    const rewritten = items.map((item) => {
      const trimmed = item.trim();
      if (!trimmed) {
        return trimmed;
      }
      const match = trimmed.match(/^(\S+)(\s+.*)?$/);
      if (!match) {
        return trimmed;
      }
      const mapped = requestToObjectUrl(match[1], baseHref);
      if (!mapped) {
        return trimmed;
      }
      changed = true;
      return mapped + (match[2] || "");
    });
    return changed ? rewritten.join(", ") : value;
  }

  function injectRuntimeBridge(documentNode, options = {}) {
    const bridgeMeta = {
      gameId: typeof options.gameId === "string" ? options.gameId : "",
      gameName: typeof options.gameName === "string" ? options.gameName : "",
      entryPath: typeof options.entryPath === "string" ? normalizePath(options.entryPath) : ""
    };
    const script = documentNode.createElement("script");
    script.textContent = `
(function () {
  var __launcherBridgeMeta = ${JSON.stringify(bridgeMeta)};
  var __errorArgToString = function (value) {
    if (value == null) return String(value);
    if (value instanceof Error) {
      return String(value.name || "Error") + ": " + String(value.message || "") + (value.stack ? " | " + String(value.stack) : "");
    }
    if (typeof value === "object") {
      try {
        return JSON.stringify(value);
      } catch (_error) {
        return Object.prototype.toString.call(value);
      }
    }
    return String(value);
  };

  var __getLauncherHost = function () {
    try {
      if (window.parent && window.parent !== window && typeof window.parent.postMessage === "function") {
        return window.parent;
      }
    } catch (_error) {
      // continue
    }
    try {
      if (window.opener && !window.opener.closed && typeof window.opener.postMessage === "function") {
        return window.opener;
      }
    } catch (_error) {
      // no host
    }
    return null;
  };

  var __reportLauncherError = function (details) {
    var host = __getLauncherHost();
    if (!host) {
      return;
    }
    var payload = Object.assign(
      {
        __cbgamesPlayerLog: true,
        level: "error",
        timestamp: Date.now(),
        gameId: __launcherBridgeMeta.gameId || "",
        gameName: __launcherBridgeMeta.gameName || "",
        entryPath: __launcherBridgeMeta.entryPath || ""
      },
      details || {}
    );
    try {
      host.postMessage(payload, "*");
    } catch (_error) {
      // ignore report failure
    }
  };

  var getResolverHost = function () {
    try {
      if (window.parent && window.parent !== window && typeof window.parent.__loaderResolve === "function") {
        return window.parent;
      }
    } catch (_error) {
      // continue to opener fallback
    }
    try {
      if (window.opener && !window.opener.closed && typeof window.opener.__loaderResolve === "function") {
        return window.opener;
      }
    } catch (_error) {
      // no resolver host available
    }
    return null;
  };

  var getBaseHref = function () {
    var baseEl = document.querySelector("base[href]");
    if (baseEl && baseEl.href) {
      return baseEl.href;
    }
    return document.baseURI;
  };

  var resolver = function (value) {
    try {
      var host = getResolverHost();
      if (!host) return null;
      return host.__loaderResolve(String(value), getBaseHref());
    } catch (_error) {
      return null;
    }
  };

  var normalizeVirtualDataUrl = function (value) {
    var text = String(value || "");
    var marker = "data:application/";
    var markerIndex = text.indexOf(marker);
    if (markerIndex > 0) {
      return text.slice(markerIndex);
    }
    return value;
  };

  var mapValue = function (value) {
    var normalized = normalizeVirtualDataUrl(value);
    var mapped = resolver(normalized);
    return mapped || normalized;
  };

  var isMappedAttributeName = function (name) {
    var attr = String(name || "").toLowerCase();
    return (
      attr === "srcset" ||
      attr === "src" ||
      attr === "href" ||
      attr === "xlink:href" ||
      attr.endsWith(":href") ||
      attr === "data" ||
      attr === "poster" ||
      attr === "action"
    );
  };

  var UNITY_GPU_SAFE_MODE = true;
  var UNITY_FORCE_WEBGL1 = false;
  var UNITY_CLAMP_DEVICE_PIXEL_RATIO = 1;

  var mapSrcSet = function (value) {
    if (typeof value !== "string") return value;
    var changed = false;
    var rewritten = value.split(",").map(function (item) {
      var trimmed = item.trim();
      if (!trimmed) return trimmed;
      var match = trimmed.match(/^(\\S+)(\\s+.*)?$/);
      if (!match) return trimmed;
      var mapped = resolver(match[1]);
      if (!mapped) return trimmed;
      changed = true;
      return mapped + (match[2] || "");
    });
    return changed ? rewritten.join(", ") : value;
  };

  var rewriteCssRuntime = function (value) {
    if (typeof value !== "string" || !value) return value;
    return value.replace(
      /url\\(\\s*(['"]?)([^"')]+)\\1\\s*\\)/gi,
      function (full, quote, urlPath) {
        var mapped = resolver(urlPath);
        if (!mapped) return full;
        var wrapped = quote || '"';
        return "url(" + wrapped + mapped + wrapped + ")";
      }
    );
  };

  var remapElementTree = function (root) {
    if (!root) return;
    var targetAttrs = [
      "src",
      "href",
      "xlink:href",
      "data",
      "poster",
      "action"
    ];
    var all = [];
    if (root.nodeType === 1) {
      all.push(root);
    }
    if (root.querySelectorAll) {
      var nested = root.querySelectorAll("*");
      for (var n = 0; n < nested.length; n++) {
        all.push(nested[n]);
      }
    }
    for (var i = 0; i < all.length; i++) {
      var el = all[i];
      for (var a = 0; a < targetAttrs.length; a++) {
        var attr = targetAttrs[a];
        if (!el.hasAttribute(attr)) continue;
        var current = el.getAttribute(attr);
        var mapped = mapValue(current);
        if (mapped !== current) {
          el.setAttribute(attr, mapped);
        }
      }
      if (el.hasAttribute("srcset")) {
        var currentSrcSet = el.getAttribute("srcset");
        var mappedSrcSet = mapSrcSet(currentSrcSet);
        if (mappedSrcSet !== currentSrcSet) {
          el.setAttribute("srcset", mappedSrcSet);
        }
      }
      if (el.tagName === "STYLE") {
        var cssText = el.textContent || "";
        var cssMapped = rewriteCssRuntime(cssText);
        if (cssMapped !== cssText) {
          el.textContent = cssMapped;
        }
      }
    }
  };

  var patchProperty = function (ctor, prop, mapper) {
    if (!ctor || !ctor.prototype) return;
    var desc = Object.getOwnPropertyDescriptor(ctor.prototype, prop);
    if (!desc || typeof desc.get !== "function" || typeof desc.set !== "function") return;
    var convert = mapper || mapValue;
    Object.defineProperty(ctor.prototype, prop, {
      configurable: desc.configurable,
      enumerable: desc.enumerable,
      get: function () {
        return desc.get.call(this);
      },
      set: function (value) {
        desc.set.call(this, convert(value));
      }
    });
  };

  var nativeSetAttribute = Element.prototype.setAttribute;
  Element.prototype.setAttribute = function (name, value) {
    var attr = String(name || "").toLowerCase();
    if (attr === "srcset") {
      value = mapSrcSet(value);
    } else if (isMappedAttributeName(attr)) {
      value = mapValue(value);
    }
    return nativeSetAttribute.call(this, name, value);
  };

  if (Element.prototype.setAttributeNS) {
    var nativeSetAttributeNS = Element.prototype.setAttributeNS;
    Element.prototype.setAttributeNS = function (namespace, name, value) {
      var attr = String(name || "").toLowerCase();
      if (attr === "srcset") {
        value = mapSrcSet(value);
      } else if (isMappedAttributeName(attr)) {
        value = mapValue(value);
      }
      return nativeSetAttributeNS.call(this, namespace, name, value);
    };
  }

  patchProperty(HTMLScriptElement, "src");
  patchProperty(HTMLLinkElement, "href");
  patchProperty(HTMLImageElement, "src");
  patchProperty(HTMLImageElement, "srcset", mapSrcSet);
  patchProperty(HTMLIFrameElement, "src");
  patchProperty(HTMLObjectElement, "data");
  patchProperty(HTMLEmbedElement, "src");
  patchProperty(HTMLAnchorElement, "href");
  patchProperty(HTMLFormElement, "action");
  patchProperty(HTMLSourceElement, "src");
  patchProperty(HTMLTrackElement, "src");
  patchProperty(HTMLInputElement, "src");
  if (window.HTMLMediaElement) {
    patchProperty(HTMLMediaElement, "src");
  }

  var nativeFetch = window.fetch.bind(window);
  window.fetch = function (input, init) {
    if (typeof input === "string" || input instanceof URL) {
      var originalInput = input;
      var mappedInput = mapValue(input);
      if (mappedInput === originalInput) {
        return nativeFetch(originalInput, init);
      }
      return nativeFetch(mappedInput, init).catch(function () {
        return nativeFetch(originalInput, init);
      });
    }
    if (input instanceof Request) {
      var mapped = resolver(input.url);
      if (mapped) {
        try {
          return nativeFetch(new Request(mapped, input), init).catch(function () {
            return nativeFetch(input, init);
          });
        } catch (_error) {
          return nativeFetch(input, init);
        }
      }
    }
    return nativeFetch(input, init);
  };

  var nativeOpen = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function (method, url) {
    var rest = Array.prototype.slice.call(arguments, 2);
    return nativeOpen.apply(this, [method, mapValue(url)].concat(rest));
  };

  if (window.Worker) {
    var NativeWorker = window.Worker;
    window.Worker = function (url, options) {
      return new NativeWorker(mapValue(url), options);
    };
    window.Worker.prototype = NativeWorker.prototype;
  }

  if (window.SharedWorker) {
    var NativeSharedWorker = window.SharedWorker;
    window.SharedWorker = function (url, options) {
      return new NativeSharedWorker(mapValue(url), options);
    };
    window.SharedWorker.prototype = NativeSharedWorker.prototype;
  }

  if (window.FontFace) {
    var NativeFontFace = window.FontFace;
    window.FontFace = function (family, source, descriptors) {
      var nextSource = source;
      if (typeof source === "string") {
        nextSource = source.replace(
          /url\\(\\s*(['"]?)([^"')]+)\\1\\s*\\)/gi,
          function (full, quote, urlPath) {
            var mapped = resolver(urlPath);
            if (!mapped) {
              return full;
            }
            var wrapped = quote || '"';
            return "url(" + wrapped + mapped + wrapped + ")";
          }
        );
      }
      return new NativeFontFace(family, nextSource, descriptors);
    };
    window.FontFace.prototype = NativeFontFace.prototype;
  }

  var innerHtmlDesc = Object.getOwnPropertyDescriptor(Element.prototype, "innerHTML");
  if (innerHtmlDesc && typeof innerHtmlDesc.get === "function" && typeof innerHtmlDesc.set === "function") {
    Object.defineProperty(Element.prototype, "innerHTML", {
      configurable: innerHtmlDesc.configurable,
      enumerable: innerHtmlDesc.enumerable,
      get: function () {
        return innerHtmlDesc.get.call(this);
      },
      set: function (value) {
        innerHtmlDesc.set.call(this, value);
        remapElementTree(this);
      }
    });
  }

  if (window.CSSStyleSheet && CSSStyleSheet.prototype) {
    var nativeInsertRule = CSSStyleSheet.prototype.insertRule;
    if (typeof nativeInsertRule === "function") {
      CSSStyleSheet.prototype.insertRule = function (rule, index) {
        return nativeInsertRule.call(this, rewriteCssRuntime(String(rule || "")), index);
      };
    }
  }

  if (window.MutationObserver) {
    var observer = new MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) {
        var mutation = mutations[i];
        if (mutation.type === "attributes" && mutation.target) {
          remapElementTree(mutation.target);
          continue;
        }
        if (mutation.type === "childList") {
          for (var j = 0; j < mutation.addedNodes.length; j++) {
            var node = mutation.addedNodes[j];
            if (node && node.nodeType === 1) {
              remapElementTree(node);
            }
          }
        }
      }
    });
    observer.observe(document.documentElement || document, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["src", "href", "xlink:href", "data", "poster", "action", "srcset"]
    });
  }

  var installWebGLSafetyPatch = function () {
    if (!UNITY_GPU_SAFE_MODE || !window.HTMLCanvasElement || !HTMLCanvasElement.prototype) {
      return;
    }
    if (window.__loaderWebglSafetyInstalled) {
      return;
    }
    window.__loaderWebglSafetyInstalled = true;

    var forcedDpr = Number(UNITY_CLAMP_DEVICE_PIXEL_RATIO) || 0;
    if (forcedDpr > 0) {
      try {
        Object.defineProperty(window, "devicePixelRatio", {
          configurable: true,
          get: function () {
            return forcedDpr;
          }
        });
      } catch (_error) {
        // read-only in some environments
      }
    }

    var nativeGetContext = HTMLCanvasElement.prototype.getContext;
    if (typeof nativeGetContext !== "function") {
      return;
    }

    var isLikelyUnityPage = function () {
      try {
        if (typeof window.createUnityInstance === "function" || typeof window.UnityLoader !== "undefined") {
          return true;
        }
      } catch (_error) {
        // ignore and continue to DOM checks
      }
      try {
        return !!document.querySelector(
          'script[src*="UnityLoader"], script[src*="unityloader"], script[src*="/Build/"], script[src*="framework"]'
        );
      } catch (_error) {
        return false;
      }
    };

    HTMLCanvasElement.prototype.getContext = function (type, attrs) {
      var kind = String(type || "").toLowerCase();
      if (UNITY_FORCE_WEBGL1 && kind === "webgl2" && isLikelyUnityPage()) {
        return null;
      }

      if (
        kind === "webgl" ||
        kind === "experimental-webgl" ||
        kind === "webgl2"
      ) {
        var nextAttrs = Object.assign({}, attrs || {}, {
          antialias: false,
          alpha: false,
          stencil: false,
          premultipliedAlpha: false,
          preserveDrawingBuffer: false,
          desynchronized: true,
          powerPreference: "low-power"
        });
        return nativeGetContext.call(this, type, nextAttrs);
      }

      return nativeGetContext.call(this, type, attrs);
    };

    console.log("[GPU Safe] WebGL safety mode active (low-memory attrs; WebGL1 fallback for Unity pages).");
  };
  installWebGLSafetyPatch();

  var ensureVisibleSurface = function () {
    if (!document.documentElement || !document.body) {
      return;
    }
    if (!document.documentElement.style.height) {
      document.documentElement.style.height = "100%";
    }
    if (!document.body.style.height) {
      document.body.style.height = "100%";
    }
    if (!document.body.style.margin || document.body.style.margin === "8px") {
      document.body.style.margin = "0";
    }

    var fixBox = function (element) {
      if (!element || !element.getBoundingClientRect) return;
      var rect = element.getBoundingClientRect();
      var isCanvas = element.tagName === "CANVAS";
      if (rect.width > 0 && rect.height > 0 && (!isCanvas || (element.width > 0 && element.height > 0))) {
        return;
      }

      var widthStyle = element.style.width || "";
      var heightStyle = element.style.height || "";
      if (!widthStyle || widthStyle === "100%" || widthStyle === "0px") {
        element.style.width = "100vw";
      }
      if (!heightStyle || heightStyle === "100%" || heightStyle === "0px") {
        element.style.height = "100vh";
      }
      if (!element.style.display) {
        element.style.display = "block";
      }
      if (!element.style.position || element.style.position === "static") {
        element.style.position = "relative";
      }

      if (isCanvas) {
        var viewportWidth = Math.max(window.innerWidth || 0, 1);
        var viewportHeight = Math.max(window.innerHeight || 0, 1);
        if (!element.width || element.width === 0) {
          element.width = viewportWidth;
        }
        if (!element.height || element.height === 0) {
          element.height = viewportHeight;
        }
      }
    };

    var roots = [
      document.getElementById("gameContainer"),
      document.getElementById("unityContainer"),
      document.getElementById("unity-canvas"),
      document.querySelector(".webgl-content"),
      document.querySelector("#canvas")
    ];

    for (var i = 0; i < roots.length; i++) {
      fixBox(roots[i]);
    }

    var canvases = document.querySelectorAll("canvas");
    for (var c = 0; c < canvases.length; c++) {
      var canvas = canvases[c];
      fixBox(canvas);
      if (canvas.parentElement) {
        fixBox(canvas.parentElement);
      }
    }
  };

  window.addEventListener("load", function () {
    ensureVisibleSurface();
    try {
      window.dispatchEvent(new Event("resize"));
    } catch (_error) {
      // ignore
    }
  });
  window.addEventListener("resize", ensureVisibleSurface);
  document.addEventListener("DOMContentLoaded", ensureVisibleSurface);
  var surfaceTries = 0;
  var surfaceTimer = setInterval(function () {
    ensureVisibleSurface();
    surfaceTries += 1;
    if (surfaceTries >= 40) {
      clearInterval(surfaceTimer);
    }
  }, 250);

  window.addEventListener(
    "error",
    function (event) {
      var target = event && event.target;
      if (!target || target === window) return;
      var badUrl = target.src || target.href || target.data || "";
      if (typeof badUrl === "string" && badUrl.indexOf("https://loader.invalid/") === 0) {
        console.error("Unresolved asset URL:", badUrl);
      }
    },
    true
  );

  window.addEventListener(
    "error",
    function (event) {
      var errorObj = event && event.error;
      __reportLauncherError({
        kind: "error-event",
        message: (event && event.message) ? String(event.message) : (errorObj && errorObj.message ? String(errorObj.message) : "Script error"),
        source: event && event.filename ? String(event.filename) : "",
        lineno: event && event.lineno ? Number(event.lineno) : 0,
        colno: event && event.colno ? Number(event.colno) : 0,
        stack: errorObj && errorObj.stack ? String(errorObj.stack) : ""
      });
    },
    true
  );

  window.addEventListener("unhandledrejection", function (event) {
    var reason = event ? event.reason : null;
    var message = reason && reason.message ? String(reason.message) : __errorArgToString(reason || "Unhandled promise rejection");
    __reportLauncherError({
      kind: "unhandledrejection",
      message: message,
      stack: reason && reason.stack ? String(reason.stack) : ""
    });
  });

  if (window.console && typeof window.console.error === "function") {
    var __nativeConsoleError = window.console.error.bind(window.console);
    window.console.error = function () {
      var parts = [];
      for (var i = 0; i < arguments.length; i++) {
        parts.push(__errorArgToString(arguments[i]));
      }
      __reportLauncherError({
        kind: "console.error",
        message: parts.join(" | ")
      });
      return __nativeConsoleError.apply(window.console, arguments);
    };
  }

  // Suppress popups that mention file:// from bundled games.
  (function () {
    var originalAlert = window.alert;
    var originalConfirm = window.confirm;
    var originalPrompt = window.prompt;
    var shouldSuppress = function (message) {
      var text = String(message || "");
      return /file:/i.test(text);
    };
    if (typeof originalAlert === "function") {
      window.alert = function (message) {
        if (shouldSuppress(message)) {
          console.warn("Suppressed popup containing file://:", String(message || ""));
          return;
        }
        return originalAlert.call(window, message);
      };
    }
    if (typeof originalConfirm === "function") {
      window.confirm = function (message) {
        if (shouldSuppress(message)) {
          console.warn("Suppressed popup containing file://:", String(message || ""));
          return true;
        }
        return originalConfirm.call(window, message);
      };
    }
    if (typeof originalPrompt === "function") {
      window.prompt = function (message, defaultValue) {
        if (shouldSuppress(message)) {
          console.warn("Suppressed popup containing file://:", String(message || ""));
          return defaultValue == null ? "" : String(defaultValue);
        }
        return originalPrompt.call(window, message, defaultValue);
      };
    }
  })();
})();
`;
    const base = documentNode.head.querySelector("base");
    if (base && base.nextSibling) {
      documentNode.head.insertBefore(script, base.nextSibling);
      return;
    }
    if (base) {
      documentNode.head.append(script);
      return;
    }
    documentNode.head.prepend(script);
  }

  function rewriteDocumentHtml(htmlText, entryPath, runtimeBridgeOptions = {}) {
    const parser = new DOMParser();
    const documentNode = parser.parseFromString(htmlText, "text/html");
    const baseHref = toVirtualUrl(entryPath);

    let baseElement = documentNode.querySelector("base");
    if (!baseElement) {
      baseElement = documentNode.createElement("base");
      documentNode.head.prepend(baseElement);
    }
    baseElement.setAttribute("href", baseHref);

    for (const manifestLink of documentNode.querySelectorAll('link[rel="manifest"]')) {
      manifestLink.remove();
    }

    const targets = [
      ["script", "src"],
      ["link", "href"],
      ["img", "src"],
      ["audio", "src"],
      ["video", "src"],
      ["source", "src"],
      ["track", "src"],
      ["object", "data"],
      ["embed", "src"],
      ["iframe", "src"]
    ];

    for (const [selector, attribute] of targets) {
      const elements = documentNode.querySelectorAll(selector + "[" + attribute + "]");
      for (const element of elements) {
        const original = element.getAttribute(attribute);
        const mapped = requestToObjectUrl(original, baseHref);
        if (mapped) {
          element.setAttribute(attribute, mapped);
        }
      }
    }

    for (const element of documentNode.querySelectorAll("[srcset]")) {
      const rewritten = rewriteSrcSet(element.getAttribute("srcset"), baseHref);
      element.setAttribute("srcset", rewritten);
    }

    injectRuntimeBridge(documentNode, runtimeBridgeOptions);
    return "<!DOCTYPE html>\n" + documentNode.documentElement.outerHTML;
  }

  function canAccessPlayerWindow(win) {
    if (!win || win.closed) {
      return false;
    }
    try {
      void win.document;
      return true;
    } catch {
      return false;
    }
  }

  function openPlayerWindow() {
    const reused = window.open("about:blank", "cbgamesOfflinePlayer");
    if (canAccessPlayerWindow(reused)) {
      return reused;
    }
    // Fallback: request a fresh unnamed window if named context is unavailable.
    const fresh = window.open("about:blank");
    if (canAccessPlayerWindow(fresh)) {
      return fresh;
    }
    return null;
  }

  async function launchSelectedGame() {
    const gameId = state.selectedGameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game) {
      log("Choose a saved game first.", "error");
      return;
    }

    const chosenEntry = entrySelect.value || game.entryPath || chooseBestEntryPath(game.htmlEntries || [], "");
    if (!chosenEntry) {
      log("No startup HTML file was found for this game.", "error");
      return;
    }

    launchButton.disabled = true;
    deleteGameButton.disabled = true;

    try {
      setWorkProgress("Loading game data", 0, 4);
      log("Loading \"" + game.name + "\" from IndexedDB...");
      if (!canAccessPlayerWindow(state.playerWindow)) {
        state.playerWindow = openPlayerWindow();
      }
      if (!state.playerWindow) {
        throw new Error("Popup blocked. Allow popups for this file page.");
      }

      const files = await getAllFilesForGame(game.id);
      setWorkProgress("Preparing game assets", 1, 4);
      if (!files.length) {
        throw new Error("No files were found for this game in IndexedDB.");
      }

      await buildObjectUrlCacheFromRecords(files, state.playerWindow);
      setWorkProgress("Preparing game assets", 2, 4);
      state.activeEntryPath = chosenEntry;

      const fileMap = new Map(files.map((record) => [record.path, record]));
      let entryPath = chosenEntry;
      let entryRecord = fileMap.get(entryPath);

      if (!entryRecord) {
        const htmlEntries = files
          .map((record) => record.path)
          .filter((path) => /\.html?$/i.test(path));
        entryPath = chooseBestEntryPath(htmlEntries, game.entryPath || "");
        entryRecord = fileMap.get(entryPath);
      }

      if (!entryRecord) {
        throw new Error("Startup file is missing from saved data.");
      }

      const htmlText = await entryRecord.blob.text();
      const rewrittenHtml = rewriteDocumentHtml(htmlText, entryPath, {
        gameId: game.id,
        gameName: game.name || "",
        entryPath
      });
      setWorkProgress("Opening player window", 3, 4);

      if (!canAccessPlayerWindow(state.playerWindow)) {
        state.playerWindow = openPlayerWindow();
      }
      if (!state.playerWindow) {
        throw new Error("Could not access the player window. Reopen and launch again.");
      }

      state.playerWindow.document.open();
      state.playerWindow.document.write(rewrittenHtml);
      state.playerWindow.document.close();
      state.playerWindow.focus();

      if (game.entryPath !== entryPath) {
        game.entryPath = entryPath;
        state.gamesById.set(game.id, game);
        await putGame(game);
        updateSelectedGameInfo(game);
      }

      setWorkProgress("Launch complete", 4, 4);
      log("Launched: " + game.name + " (" + entryPath + ")");
    } catch (error) {
      console.error(error);
      log("Launch failed: " + (error.message || String(error)), "error");
    } finally {
      launchButton.disabled = false;
      deleteGameButton.disabled = false;
      setTimeout(clearWorkProgress, 350);
    }
  }

  async function deleteSelectedGame() {
    const gameId = state.selectedGameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game) {
      log("Choose a saved game to delete.", "error");
      return;
    }

    const ok = window.confirm("Delete \"" + game.name + "\" from IndexedDB? This cannot be undone.");
    if (!ok) {
      return;
    }

    setActionButtonsDisabled(true);

    try {
      await deleteFilesByGameId(game.id);
      await deleteGameRecord(game.id);
      state.gamesById.delete(game.id);

      if (state.selectedGameId === game.id) {
        state.selectedGameId = null;
      }

      clearObjectUrls();
      state.activeEntryPath = null;

      if (state.playerWindow && !state.playerWindow.closed) {
        state.playerWindow.close();
      }
      state.playerWindow = null;

      // Recycling the DB connection helps some browsers update storage estimates
      // sooner after large IndexedDB deletions.
      await reopenDatabaseConnection();
      await putSetting(SETTING_SELECTED_GAME, "");
      await loadLibrary();
      log("Deleted game: " + game.name);
    } catch (error) {
      console.error(error);
      log("Delete failed: " + (error.message || String(error)), "error");
    } finally {
      setActionButtonsDisabled(false);
    }
  }

  function normalizeBundleGameRecord(record) {
    const source = record && typeof record === "object" ? record : {};
    const explicitHtmlEntries = Array.isArray(source.htmlEntries)
      ? source.htmlEntries.map((v) => normalizePath(v)).filter(Boolean)
      : [];
    const derivedHtmlEntries = Array.isArray(source.files)
      ? source.files
          .map((item) => normalizePath(item && item.path ? item.path : ""))
          .filter((path) => /\.html?$/i.test(path))
      : [];
    const htmlEntries = explicitHtmlEntries.length ? explicitHtmlEntries : derivedHtmlEntries;
    const normalized = {
      id: typeof source.id === "string" && source.id ? source.id : makeId(),
      name: typeof source.name === "string" && source.name ? source.name : "Imported Game",
      zipName: typeof source.zipName === "string" && source.zipName ? source.zipName : "Imported Bundle",
      importedAt: Number(source.importedAt) || Date.now(),
      sortOrder: Number.isFinite(Number(source.sortOrder)) ? Number(source.sortOrder) : Number.MAX_SAFE_INTEGER,
      fileCount: Number(source.fileCount) || 0,
      totalBytes: Number(source.totalBytes) || 0,
      htmlEntries,
      entryPath: typeof source.entryPath === "string" ? normalizePath(source.entryPath) : "",
      thumbnailDataUrl: typeof source.thumbnailDataUrl === "string" ? source.thumbnailDataUrl : "",
      githubSource: normalizeGithubSource(source.githubSource),
      unityDetected: Boolean(source.unityDetected) || detectUnityByPaths(
        Array.isArray(source.files) ? source.files.map((item) => normalizePath(item && item.path ? item.path : "")) : []
      ),
      flashDetected: Boolean(source.flashDetected) || detectFlashByPaths(
        Array.isArray(source.files) ? source.files.map((item) => normalizePath(item && item.path ? item.path : "")) : []
      )
    };
    normalized.entryPath = chooseBestEntryPath(normalized.htmlEntries, normalized.entryPath);
    return normalized;
  }

  async function exportAllGamesBundle(progressCallback) {
    const games = await getAllGames();
    if (!games.length) {
      throw new Error("No saved games to export.");
    }
    const zipEntries = [];
    const manifest = {
      format: "cbgames-zip-v2",
      createdAt: Date.now(),
      games: []
    };
    let processedGames = 0;
    for (const game of games) {
      const files = await getAllFilesForGame(game.id);
      const gameFolder = "games/" + encodeURIComponent(game.id);
      const manifestGame = {
        id: game.id,
        name: game.name,
        zipName: game.zipName,
        importedAt: game.importedAt,
        sortOrder: Number.isFinite(Number(game.sortOrder)) ? Number(game.sortOrder) : Number.MAX_SAFE_INTEGER,
        fileCount: game.fileCount,
        totalBytes: game.totalBytes,
        htmlEntries: Array.isArray(game.htmlEntries) ? game.htmlEntries : [],
        entryPath: game.entryPath || "",
        githubSource: normalizeGithubSource(game.githubSource),
        unityDetected: Boolean(game.unityDetected),
        flashDetected: Boolean(game.flashDetected),
        files: []
      };
      if (typeof game.thumbnailDataUrl === "string" && game.thumbnailDataUrl) {
        const thumb = parseDataUrlToBytes(game.thumbnailDataUrl);
        if (thumb && thumb.bytes.length) {
          const thumbPath = gameFolder + "/thumbnail" + extensionFromMime(thumb.mime);
          zipEntries.push({
            path: thumbPath,
            bytes: thumb.bytes
          });
          manifestGame.thumbnail = {
            path: thumbPath,
            type: thumb.mime
          };
        }
      }
      for (const file of files) {
        const bytes = new Uint8Array(await file.blob.arrayBuffer());
        const zipPath = gameFolder + "/files/" + normalizePath(file.path);
        zipEntries.push({
          path: zipPath,
          bytes
        });
        manifestGame.files.push({
          path: normalizePath(file.path),
          type: file.type || mimeFromPath(file.path),
          size: Number(file.size) || bytes.byteLength,
          zipPath
        });
      }
      manifest.games.push(manifestGame);
      processedGames += 1;
      if (typeof progressCallback === "function") {
        progressCallback(processedGames, games.length);
      }
    }

    const manifestBytes = encodeUtf8(JSON.stringify(manifest));
    zipEntries.unshift({
      path: "bundle.json",
      bytes: manifestBytes
    });

    return createZipStoreArchive(zipEntries);
  }

  async function downloadAllGamesBundle() {
    setActionButtonsDisabled(true);
    try {
      setWorkProgress("Preparing game bundle", 0, 0);
      log("Preparing game bundle...");
      const bundleZip = await exportAllGamesBundle((current, total) => {
        setWorkProgress("Reading saved games", current, total);
      });
      setWorkProgress("Writing bundle file", 1, 1);
      const filename = "cbgames-bundle.zip";
      const url = URL.createObjectURL(bundleZip);
      try {
        const anchor = document.createElement("a");
        anchor.href = url;
        anchor.download = filename;
        document.body.append(anchor);
        anchor.click();
        anchor.remove();
      } finally {
        URL.revokeObjectURL(url);
      }
      log("Exported games to " + filename + ".");
    } finally {
      setActionButtonsDisabled(false);
      clearWorkProgress();
    }
  }

  async function pickBundleFile() {
    if (window.showOpenFilePicker) {
      try {
        const handles = await window.showOpenFilePicker({
          multiple: false,
          excludeAcceptAllOption: false,
          types: [
            {
              description: "CBGames bundle",
              accept: {
                "application/zip": [".zip"],
                "application/x-zip-compressed": [".zip"]
              }
            }
          ]
        });
        if (!handles.length) {
          return;
        }
        const file = await handles[0].getFile();
        await importBundleFile(file);
      } catch (error) {
        if (error && error.name === "AbortError") {
          log("Bundle import canceled.");
          return;
        }
        console.error(error);
        log("Bundle import failed: " + (error.message || String(error)), "error");
      }
      return;
    }

    bundleInput.value = "";
    bundleInput.click();
  }

  async function parseBundlePreviewData(file) {
    setWorkProgress("Reading bundle", 0, 0);
    log("Reading bundle: " + file.name);
    const buffer = await file.arrayBuffer();
    let parsedZip;
    try {
      parsedZip = parseZipArchive(buffer);
    } catch {
      throw new Error("Bundle import only supports .zip files.");
    }
    const entryByPath = new Map(parsedZip.entries.map((entry) => [normalizePath(entry.path), entry]));
    const manifestEntry = entryByPath.get("bundle.json");
    if (!manifestEntry) {
      throw new Error("Bundle ZIP missing bundle.json.");
    }
    const manifestBytes = await extractEntryBytes(parsedZip, manifestEntry);
    let bundle;
    try {
      bundle = JSON.parse(decodeUtf8(manifestBytes));
    } catch {
      throw new Error("Invalid bundle JSON inside ZIP.");
    }
    if (!bundle || bundle.format !== "cbgames-zip-v2" || !Array.isArray(bundle.games)) {
      throw new Error("Unsupported backup format.");
    }

    const previewGames = [];
    let totalFiles = 0;
    let totalBytes = 0;
    for (let index = 0; index < bundle.games.length; index += 1) {
      const rawGame = bundle.games[index];
      const normalizedGame = normalizeBundleGameRecord({
        ...rawGame,
        thumbnailDataUrl: ""
      });
      const fileList = Array.isArray(rawGame && rawGame.files) ? rawGame.files : [];
      let missingPayloadCount = 0;
      let computedBytes = 0;
      for (const fileInfo of fileList) {
        if (!fileInfo || typeof fileInfo !== "object") {
          continue;
        }
        const zipPath = normalizePath(fileInfo.zipPath || "");
        if (!zipPath || !entryByPath.has(zipPath)) {
          missingPayloadCount += 1;
        }
        const rawSize = Number(fileInfo.size);
        if (Number.isFinite(rawSize) && rawSize > 0) {
          computedBytes += rawSize;
        }
      }
      const fileCount = fileList.length;
      const totalGameBytes = computedBytes || Number(normalizedGame.totalBytes) || 0;
      totalFiles += fileCount;
      totalBytes += totalGameBytes;

      const existingById = normalizedGame.id ? state.gamesById.get(normalizedGame.id) : null;
      const nameConflicts = getBundleNameConflicts(normalizedGame.name || "");
      const conflictGame = existingById || nameConflicts[0] || null;
      let thumbnailDataUrl = "";
      if (rawGame && rawGame.thumbnail && typeof rawGame.thumbnail.path === "string") {
        const thumbPath = normalizePath(rawGame.thumbnail.path);
        const thumbEntry = entryByPath.get(thumbPath);
        if (thumbEntry) {
          try {
            const thumbBytes = await extractEntryBytes(parsedZip, thumbEntry);
            const thumbMime = typeof rawGame.thumbnail.type === "string" && rawGame.thumbnail.type
              ? rawGame.thumbnail.type
              : mimeFromPath(thumbPath);
            thumbnailDataUrl = "data:" + thumbMime + ";base64," + bytesToBase64(thumbBytes);
          } catch {
            thumbnailDataUrl = "";
          }
        }
      }
      let defaultMode = "import";
      if (missingPayloadCount > 0) {
        defaultMode = "skip";
      } else if (existingById) {
        defaultMode = "replace";
      } else if (nameConflicts.length) {
        defaultMode = "rename";
      }

      previewGames.push({
        index,
        sourceId: typeof rawGame.id === "string" ? rawGame.id : "",
        rawGame,
        normalizedGame,
        fileCount,
        totalBytes: totalGameBytes,
        missingPayloadCount,
        conflictGame,
        canReplace: Boolean(conflictGame),
        thumbnailDataUrl,
        defaultMode
      });
    }

    return {
      fileName: file.name,
      parsedZip,
      entryByPath,
      games: previewGames,
      totalFiles,
      totalBytes
    };
  }

  async function executeBundleImportPlan(previewData, planGames) {
    const selected = planGames.filter((item) =>
      item &&
      item.selected &&
      item.mode !== "skip" &&
      item.preview &&
      !item.preview.missingPayloadCount
    );
    if (!selected.length) {
      throw new Error("No games were selected to import.");
    }

    const usedNameKeys = new Set(
      Array.from(state.gamesById.values())
        .map((game) => normalizeGameIdentity(game.name || ""))
        .filter(Boolean)
    );
    const reservedIds = new Set(Array.from(state.gamesById.keys()));
    const metadataOut = [];
    const totalFiles = selected.reduce((sum, item) => sum + (item.preview.fileCount || 0), 0);

    let metadataImported = 0;
    setWorkProgress("Importing game metadata", 0, selected.length || 1);
    for (const item of selected) {
      const preview = item.preview;
      const rawGame = preview.rawGame;
      const incoming = normalizeBundleGameRecord({
        ...rawGame,
        thumbnailDataUrl: ""
      });
      const mode = item.mode;
      const replaceTarget = mode === "replace" ? preview.conflictGame : null;

      if (replaceTarget) {
        await deleteFilesByGameId(replaceTarget.id);
        incoming.id = replaceTarget.id;
        incoming.sortOrder = Number.isFinite(Number(replaceTarget.sortOrder))
          ? Number(replaceTarget.sortOrder)
          : getNextSortOrder();
        incoming.name = String(replaceTarget.name || incoming.name || "Imported Game");
      } else {
        incoming.id = chooseUniqueGameId(incoming.id, reservedIds);
        incoming.sortOrder = Number.isFinite(Number(incoming.sortOrder))
          ? Number(incoming.sortOrder)
          : getNextSortOrder();
        if (mode === "rename") {
          incoming.name = chooseUniqueGameName(incoming.name, usedNameKeys);
        } else {
          incoming.name = chooseUniqueGameName(incoming.name, usedNameKeys);
        }
      }

      if (rawGame && rawGame.thumbnail && typeof rawGame.thumbnail.path === "string") {
        const thumbPath = normalizePath(rawGame.thumbnail.path);
        const thumbEntry = previewData.entryByPath.get(thumbPath);
        if (thumbEntry) {
          const thumbBytes = await extractEntryBytes(previewData.parsedZip, thumbEntry);
          const thumbMime = typeof rawGame.thumbnail.type === "string" && rawGame.thumbnail.type
            ? rawGame.thumbnail.type
            : mimeFromPath(thumbPath);
          incoming.thumbnailDataUrl = "data:" + thumbMime + ";base64," + bytesToBase64(thumbBytes);
        } else if (replaceTarget && typeof replaceTarget.thumbnailDataUrl === "string") {
          incoming.thumbnailDataUrl = replaceTarget.thumbnailDataUrl;
        }
      } else if (replaceTarget && typeof replaceTarget.thumbnailDataUrl === "string") {
        incoming.thumbnailDataUrl = replaceTarget.thumbnailDataUrl;
      }

      await putGame(incoming);
      state.gamesById.set(incoming.id, incoming);

      metadataOut.push({
        preview,
        gameId: incoming.id
      });

      metadataImported += 1;
      if (metadataImported % 5 === 0 || metadataImported === selected.length) {
        setWorkProgress("Importing game metadata", metadataImported, selected.length || 1);
      }
    }

    let importedFiles = 0;
    setWorkProgress("Importing game files", 0, totalFiles || 1);
    for (const item of metadataOut) {
      const rawGame = item.preview.rawGame;
      const fileList = Array.isArray(rawGame && rawGame.files) ? rawGame.files : [];
      for (const fileInfo of fileList) {
        if (!fileInfo || typeof fileInfo !== "object") {
          continue;
        }
        const sourcePath = normalizePath(fileInfo.path || "");
        const zipPath = normalizePath(fileInfo.zipPath || "");
        if (!sourcePath || !zipPath) {
          continue;
        }
        const zipEntry = previewData.entryByPath.get(zipPath);
        if (!zipEntry) {
          throw new Error("Bundle missing file payload: " + zipPath);
        }
        const fileBytes = await extractEntryBytes(previewData.parsedZip, zipEntry);
        const type = typeof fileInfo.type === "string" && fileInfo.type ? fileInfo.type : mimeFromPath(sourcePath);
        const blob = new Blob([fileBytes], { type });
        await putFileRecord({
          gameId: item.gameId,
          path: sourcePath,
          size: blob.size,
          type: blob.type,
          blob
        });
        importedFiles += 1;
        if (importedFiles % 25 === 0 || importedFiles === totalFiles) {
          setWorkProgress("Importing game files", importedFiles, totalFiles || 1);
        }
      }
    }

    const selectedFirst = metadataOut.length ? metadataOut[0].gameId : "";
    const preferredSelected = state.selectedGameId && state.gamesById.has(state.selectedGameId)
      ? state.selectedGameId
      : selectedFirst;

    setWorkProgress("Refreshing library", 0, 0);
    await loadLibrary(preferredSelected);
    if (preferredSelected) {
      await putSetting(SETTING_SELECTED_GAME, preferredSelected);
    }

    const skippedCount = planGames.length - selected.length;
    log(
      "Imported bundle: " +
      metadataOut.length +
      " games and " +
      importedFiles +
      " files. Skipped " +
      skippedCount +
      " games."
    );
  }

  async function importBundleFile(file) {
    if (!file) {
      return;
    }

    let previewData;
    setActionButtonsDisabled(true);
    try {
      previewData = await parseBundlePreviewData(file);
      log("Bundle preview ready: " + previewData.games.length + " games.");
    } catch (error) {
      console.error(error);
      log("Bundle import failed: " + (error.message || String(error)), "error");
      return;
    } finally {
      setActionButtonsDisabled(false);
      clearWorkProgress();
    }

    const plan = await openBundlePreviewModal(previewData);
    if (!plan || !Array.isArray(plan.games)) {
      log("Bundle import canceled.");
      return;
    }

    const planByIndex = new Map(plan.games.map((entry) => [entry.index, entry]));
    const planGames = previewData.games.map((preview) => {
      const selectedPlan = planByIndex.get(preview.index) || null;
      return {
        preview,
        selected: selectedPlan ? Boolean(selectedPlan.selected) : false,
        mode: selectedPlan ? String(selectedPlan.mode || "skip") : "skip"
      };
    });

    setActionButtonsDisabled(true);
    try {
      await executeBundleImportPlan(previewData, planGames);
    } catch (error) {
      console.error(error);
      log("Bundle import failed: " + (error.message || String(error)), "error");
    } finally {
      setActionButtonsDisabled(false);
      clearWorkProgress();
    }
  }

  gameSelect.addEventListener("change", async () => {
    const nextId = gameSelect.value || null;
    await selectGameById(nextId);
  });

  entrySelect.addEventListener("change", async () => {
    const gameId = state.selectedGameId;
    const game = gameId ? state.gamesById.get(gameId) : null;
    if (!game || !entrySelect.value) {
      return;
    }
    game.entryPath = entrySelect.value;
    state.gamesById.set(game.id, game);
    try {
      await putGame(game);
      selectedEntry.textContent = game.entryPath;
      log("Startup file set to " + game.entryPath);
    } catch (error) {
      console.error(error);
      log("Could not save startup file selection.", "error");
    }
  });

  importZipButton.addEventListener("click", pickZipFile);
  selectedPlayButton.addEventListener("click", async () => {
    await launchSelectedGame();
  });
  selectedEditButton.addEventListener("click", () => {
    if (!state.selectedGameId) {
      return;
    }
    openGameEditModal(state.selectedGameId);
  });
  selectedDeleteButton.addEventListener("click", async () => {
    await deleteSelectedGame();
  });
  replaceZipSelectedButton.addEventListener("click", async () => {
    try {
      await replaceGameWithZipFlow();
    } catch (error) {
      console.error(error);
      log("Replace import failed: " + (error.message || String(error)), "error");
    }
  });
  openOpsModalButton.addEventListener("click", showOpsModal);
  closeOpsModalButton.addEventListener("click", () => {
    hideOpsModal(false);
  });
  opsModal.addEventListener("click", (event) => {
    if (event.target === opsModal) {
      hideOpsModal(false);
    }
  });
  importGithubButton.addEventListener("click", async () => {
    try {
      await importFromGithub();
    } catch (error) {
      console.error(error);
      log("GitHub import failed: " + (error.message || String(error)), "error");
    }
  });
  checkGithubUpdateButton.addEventListener("click", async () => {
    try {
      await checkAllGithubUpdates();
    } catch (error) {
      console.error(error);
      log("GitHub update check failed: " + (error.message || String(error)), "error");
    }
  });
  exportAllGamesButton.addEventListener("click", async () => {
    try {
      await downloadAllGamesBundle();
    } catch (error) {
      console.error(error);
      log("Bundle export failed: " + (error.message || String(error)), "error");
    }
  });
  importBundleButton.addEventListener("click", pickBundleFile);
  exportErrorLogsButton.addEventListener("click", async () => {
    try {
      await downloadErrorLogs();
    } catch (error) {
      console.error(error);
      log("Error log export failed: " + (error.message || String(error)), "error");
    }
  });
  launchButton.addEventListener("click", launchSelectedGame);
  deleteGameButton.addEventListener("click", deleteSelectedGame);
  gameSearch.addEventListener("input", () => {
    state.searchQuery = gameSearch.value || "";
    renderGameCards();
  });

  gamesGrid.addEventListener("click", async (event) => {
    if (Date.now() < state.suppressCardClickUntil) {
      event.preventDefault();
      return;
    }
    const target = event.target;
    if (!(target instanceof HTMLElement)) {
      return;
    }
    const action = target.dataset.action || "";
    const gameId = target.dataset.gameId || target.closest("[data-game-id]")?.dataset.gameId || "";
    if (!gameId || !state.gamesById.has(gameId)) {
      return;
    }

    if (action === "edit-game") {
      await selectGameById(gameId);
      openGameEditModal(gameId);
      return;
    }
    if (action === "launch") {
      await selectGameById(gameId);
      await launchSelectedGame();
      return;
    }
    if (action === "delete") {
      await selectGameById(gameId);
      await deleteSelectedGame();
      return;
    }
    await selectGameById(gameId);
  });

  gamesGrid.addEventListener("dblclick", async (event) => {
    const target = event.target;
    if (!(target instanceof HTMLElement)) {
      return;
    }
    const gameId = target.closest("[data-game-id]")?.dataset.gameId || "";
    if (!gameId || !state.gamesById.has(gameId)) {
      return;
    }
    await selectGameById(gameId);
    await launchSelectedGame();
  });

  gamesGrid.addEventListener("pointerdown", (event) => {
    if (event.button !== 0) {
      return;
    }
    if (state.searchQuery.trim()) {
      return;
    }
    const target = event.target;
    if (!(target instanceof HTMLElement)) {
      return;
    }
    if (target.closest(".game-buttons") || target.closest(".game-edit-trigger")) {
      return;
    }
    const card = target.closest(".game-item");
    const gameId = card && card.dataset ? card.dataset.gameId || "" : "";
    if (!card || !gameId || !state.gamesById.has(gameId)) {
      return;
    }
    setSelectedGameImmediate(gameId, { persist: true, updateCardStyles: true });

    cleanupReorderHoldTimer();
    state.reorder.pointerId = event.pointerId;
    state.reorder.startTarget = card;
    state.reorder.holdStartX = event.clientX;
    state.reorder.holdStartY = event.clientY;
    state.reorder.pointerX = event.clientX;
    state.reorder.pointerY = event.clientY;
    state.reorder.holdMoveListener = (moveEvent) => {
      if (state.reorder.active) {
        return;
      }
      if (moveEvent.pointerId !== state.reorder.pointerId) {
        return;
      }
      state.reorder.pointerX = moveEvent.clientX;
      state.reorder.pointerY = moveEvent.clientY;
      const dx = moveEvent.clientX - state.reorder.holdStartX;
      const dy = moveEvent.clientY - state.reorder.holdStartY;
      if (Math.hypot(dx, dy) > 8) {
        cleanupReorderHoldTimer();
      }
    };
    window.addEventListener("pointermove", state.reorder.holdMoveListener, true);
    state.reorder.holdTimer = window.setTimeout(() => {
      state.reorder.holdTimer = 0;
      startCardReorder(gameId, card, {
        clientX: state.reorder.pointerX,
        clientY: state.reorder.pointerY
      });
    }, 300);
  });

  window.addEventListener("pointerup", () => {
    if (!state.reorder.active) {
      cleanupReorderHoldTimer();
      state.reorder.pointerId = null;
      state.reorder.startTarget = null;
    }
  }, true);

  window.addEventListener("pointercancel", () => {
    if (!state.reorder.active) {
      cleanupReorderHoldTimer();
      state.reorder.pointerId = null;
      state.reorder.startTarget = null;
    }
  }, true);

  closeGameEditModalButton.addEventListener("click", closeGameEditModal);
  gameEditModal.addEventListener("click", (event) => {
    if (event.target === gameEditModal) {
      closeGameEditModal();
    }
  });
  document.addEventListener("keydown", (event) => {
    if (event.key === "Escape" && bundlePreviewModal.classList.contains("open")) {
      const resolver = closeBundlePreviewModal();
      if (resolver) {
        resolver(null);
      }
      return;
    }
    if (event.key === "Escape" && importConflictModal.classList.contains("open")) {
      const resolver = closeImportConflictModal();
      if (resolver) {
        resolver("cancel");
      }
      return;
    }
    if (event.key === "Escape" && githubImportModal.classList.contains("open")) {
      const resolver = closeGithubImportModal();
      if (resolver) {
        resolver("");
      }
      return;
    }
    if (event.key === "Escape" && replaceTargetModal.classList.contains("open")) {
      closeReplaceTargetModal();
      return;
    }
    if (event.key === "Escape" && updatePromptModal.classList.contains("open")) {
      const resolver = closeUpdatePromptModal();
      if (resolver) {
        resolver("skip");
      }
      return;
    }
    if (event.key === "Escape" && opsModal.classList.contains("open")) {
      hideOpsModal(false);
      return;
    }
    if (event.key === "Escape" && gameEditModal.classList.contains("open")) {
      closeGameEditModal();
    }
  });
  uploadGameEditImageButton.addEventListener("click", () => {
    gameEditImageInput.value = "";
    gameEditImageInput.click();
  });
  gameEditNameInput.addEventListener("keydown", async (event) => {
    if (event.key !== "Enter") {
      return;
    }
    event.preventDefault();
    await saveGameEditChanges();
  });
  gameEditNameInput.addEventListener("input", () => {
    const value = gameEditNameInput.value.trim();
    gameEditPreviewTitle.textContent = value || "Untitled game";
  });
  gameEditImageInput.addEventListener("change", () => {
    if (!gameEditImageInput.files || !gameEditImageInput.files.length) {
      return;
    }
    loadGameEditImageSource(gameEditImageInput.files[0]);
  });
  saveGameEditChangesButton.addEventListener("click", async () => {
    try {
      await saveGameEditChanges();
    } catch (error) {
      console.error(error);
      log("Could not save changes.", "error");
    }
  });
  removeGameEditImageButton.addEventListener("click", async () => {
    try {
      await removeGameEditImage();
    } catch (error) {
      console.error(error);
      log("Could not remove game image.", "error");
    }
  });

  importConflictReplaceButton.addEventListener("click", () => {
    const resolver = closeImportConflictModal();
    if (resolver) {
      resolver("replace");
    }
  });
  importConflictSeparateButton.addEventListener("click", () => {
    const resolver = closeImportConflictModal();
    if (resolver) {
      resolver("separate");
    }
  });
  importConflictCancelButton.addEventListener("click", () => {
    const resolver = closeImportConflictModal();
    if (resolver) {
      resolver("cancel");
    }
  });
  githubImportSubmitButton.addEventListener("click", () => {
    const resolver = closeGithubImportModal();
    if (resolver) {
      resolver(String(githubImportInput.value || "").trim());
    }
  });
  githubImportCancelButton.addEventListener("click", () => {
    const resolver = closeGithubImportModal();
    if (resolver) {
      resolver("");
    }
  });
  replaceTargetChooseButton.addEventListener("click", () => {
    const selectedId = String(state.replaceTargetSelectedId || "");
    closeReplaceTargetModal();
    if (!selectedId) {
      log("Choose a game to replace first.", "error");
      return;
    }
    pickReplaceZipForGameId(selectedId).catch((error) => {
      console.error(error);
      log("Replace import failed: " + (error.message || String(error)), "error");
    });
  });
  replaceTargetCancelButton.addEventListener("click", () => {
    closeReplaceTargetModal();
    log("Replace import canceled.");
  });
  replaceTargetList.addEventListener("click", (event) => {
    const target = event.target;
    if (!(target instanceof HTMLElement)) {
      return;
    }
    const card = target.closest(".replace-target-card");
    if (!card || !card.dataset || !card.dataset.gameId) {
      return;
    }
    state.replaceTargetSelectedId = String(card.dataset.gameId);
    renderReplaceTargetList();
  });
  githubImportInput.addEventListener("keydown", (event) => {
    if (event.key !== "Enter") {
      return;
    }
    event.preventDefault();
    const resolver = closeGithubImportModal();
    if (resolver) {
      resolver(String(githubImportInput.value || "").trim());
    }
  });
  updatePromptInstallButton.addEventListener("click", () => {
    const resolver = closeUpdatePromptModal();
    if (resolver) {
      resolver("update");
    }
  });
  updatePromptSkipButton.addEventListener("click", () => {
    const resolver = closeUpdatePromptModal();
    if (resolver) {
      resolver("skip");
    }
  });
  updatePromptStopButton.addEventListener("click", () => {
    const resolver = closeUpdatePromptModal();
    if (resolver) {
      resolver("stop");
    }
  });
  importConflictModal.addEventListener("click", (event) => {
    if (event.target === importConflictModal) {
      const resolver = closeImportConflictModal();
      if (resolver) {
        resolver("cancel");
      }
    }
  });
  githubImportModal.addEventListener("click", (event) => {
    if (event.target === githubImportModal) {
      const resolver = closeGithubImportModal();
      if (resolver) {
        resolver("");
      }
    }
  });
  replaceTargetModal.addEventListener("click", (event) => {
    if (event.target === replaceTargetModal) {
      closeReplaceTargetModal();
    }
  });
  updatePromptModal.addEventListener("click", (event) => {
    if (event.target === updatePromptModal) {
      const resolver = closeUpdatePromptModal();
      if (resolver) {
        resolver("skip");
      }
    }
  });
  bundlePreviewSelectAllButton.addEventListener("click", () => {
    if (!state.bundlePreviewDraft || !Array.isArray(state.bundlePreviewDraft.games)) {
      return;
    }
    const draft = state.bundlePreviewDraft;
    const globalMode = String(draft.globalConflictMode || "replace");
    for (const game of state.bundlePreviewDraft.games) {
      if (!game.isInvalid) {
        game.selected = true;
        if (!draft.individualConflictControl && game.hasConflict) {
          game.mode = globalMode;
        } else if (game.mode === "skip") {
          game.mode = game.canReplace ? "replace" : "import";
        }
      }
    }
    renderBundlePreviewModal();
  });
  bundlePreviewSelectNoneButton.addEventListener("click", () => {
    if (!state.bundlePreviewDraft || !Array.isArray(state.bundlePreviewDraft.games)) {
      return;
    }
    for (const game of state.bundlePreviewDraft.games) {
      game.selected = false;
      game.mode = "skip";
    }
    renderBundlePreviewModal();
  });
  bundlePreviewConflictModeButton.addEventListener("click", () => {
    const draft = state.bundlePreviewDraft;
    if (!draft || !Array.isArray(draft.games)) {
      return;
    }
    draft.globalConflictMode = cycleGlobalConflictMode(draft.globalConflictMode);
    if (!draft.individualConflictControl) {
      for (const game of draft.games) {
        if (!game || !game.hasConflict || game.isInvalid) {
          continue;
        }
        if (!game.selected) {
          continue;
        }
        game.mode = draft.globalConflictMode;
      }
    }
    renderBundlePreviewModal();
  });
  bundlePreviewIndividualModeButton.addEventListener("click", () => {
    const draft = state.bundlePreviewDraft;
    if (!draft || !Array.isArray(draft.games)) {
      return;
    }
    draft.individualConflictControl = !draft.individualConflictControl;
    if (!draft.individualConflictControl) {
      for (const game of draft.games) {
        if (!game || !game.hasConflict || game.isInvalid) {
          continue;
        }
        if (!game.selected) {
          continue;
        }
        game.mode = draft.globalConflictMode;
      }
    }
    renderBundlePreviewModal();
  });
  bundlePreviewList.addEventListener("change", (event) => {
    if (!state.bundlePreviewDraft || !Array.isArray(state.bundlePreviewDraft.games)) {
      return;
    }
    const target = event.target;
    if (!(target instanceof HTMLElement)) {
      return;
    }
    const action = target.dataset.action || "";
    const index = Number(target.dataset.index);
    if (!Number.isFinite(index)) {
      return;
    }
    const game = state.bundlePreviewDraft.games.find((entry) => entry.index === index);
    if (!game) {
      return;
    }
    if (action === "toggle-select" && target instanceof HTMLInputElement) {
      game.selected = target.checked;
      if (!target.checked) {
        game.mode = "skip";
      } else if (!state.bundlePreviewDraft.individualConflictControl && game.hasConflict) {
        game.mode = state.bundlePreviewDraft.globalConflictMode || "replace";
      } else if (game.mode === "skip") {
        game.mode = game.canReplace ? "replace" : "import";
      }
      renderBundlePreviewModal();
      return;
    }
    if (action === "change-mode" && target instanceof HTMLSelectElement) {
      game.mode = target.value || "skip";
      if (game.mode === "skip") {
        game.selected = false;
      } else {
        game.selected = true;
      }
      renderBundlePreviewModal();
    }
  });
  bundlePreviewCancelButton.addEventListener("click", () => {
    const resolver = closeBundlePreviewModal();
    if (resolver) {
      resolver(null);
    }
  });
  bundlePreviewImportButton.addEventListener("click", () => {
    const draft = state.bundlePreviewDraft;
    const resolver = closeBundlePreviewModal();
    if (!resolver) {
      return;
    }
    if (!draft || !Array.isArray(draft.games)) {
      resolver(null);
      return;
    }
    resolver({
      games: draft.games.map((game) => ({
        index: game.index,
        selected: Boolean(game.selected) && !game.isInvalid && game.mode !== "skip",
        mode: String(game.mode || "skip")
      }))
    });
  });
  bundlePreviewModal.addEventListener("click", (event) => {
    if (event.target === bundlePreviewModal) {
      const resolver = closeBundlePreviewModal();
      if (resolver) {
        resolver(null);
      }
    }
  });

  zipInput.addEventListener("change", async () => {
    if (!zipInput.files || !zipInput.files.length) {
      return;
    }
    await importZipFile(zipInput.files[0]);
  });
  replaceZipInput.addEventListener("change", async () => {
    if (!replaceZipInput.files || !replaceZipInput.files.length) {
      return;
    }
    const replaceGameId = String(replaceZipInput.dataset.replaceGameId || "");
    await importZipFile(replaceZipInput.files[0], {
      importMode: "replace",
      replaceGameId
    });
  });
  bundleInput.addEventListener("change", async () => {
    if (!bundleInput.files || !bundleInput.files.length) {
      return;
    }
    await importBundleFile(bundleInput.files[0]);
  });

  window.addEventListener("dragenter", (event) => {
    if (!hasDragFiles(event)) {
      return;
    }
    event.preventDefault();
    state.dragDepth += 1;
    setDragDropOverlay(true, "Drop ZIP files to import");
  });

  window.addEventListener("dragover", (event) => {
    if (!hasDragFiles(event)) {
      return;
    }
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = "copy";
    }
    setDragDropOverlay(true, "Drop ZIP files to import");
  });

  window.addEventListener("dragleave", (event) => {
    if (!hasDragFiles(event)) {
      return;
    }
    event.preventDefault();
    state.dragDepth = Math.max(0, state.dragDepth - 1);
    if (state.dragDepth === 0) {
      setDragDropOverlay(false);
    }
  });

  window.addEventListener("drop", async (event) => {
    if (!hasDragFiles(event)) {
      return;
    }
    event.preventDefault();
    state.dragDepth = 0;
    setDragDropOverlay(false);
    await handleDroppedZipFiles(event.dataTransfer && event.dataTransfer.files
      ? event.dataTransfer.files
      : []);
  });

  window.addEventListener("message", (event) => {
    const payload = event && event.data;
    if (!payload || typeof payload !== "object" || payload.__cbgamesPlayerLog !== true) {
      return;
    }
    if (state.playerWindow && event.source && event.source !== state.playerWindow) {
      return;
    }
    persistPlayerError(payload).catch((error) => {
      console.error(error);
      log("Could not save game error log.", "error");
    });
  });

  setEmptyEntryState("Loading...");

  (async () => {
    try {
      state.db = await openDatabase();
      const savedGameId = await getSetting(SETTING_SELECTED_GAME);
      await loadLibrary(savedGameId || "");
      log("Ready. Import a ZIP game to begin.");
       const urlParams = new URLSearchParams(window.location.search);
      const loadParam = urlParams.get('load');
      if (loadParam) {
        const lower = loadParam.toLowerCase();
        const match =
          state.gamesById.get(loadParam) ||
          Array.from(state.gamesById.values()).find(
            g => g.name.toLowerCase() === lower ||
                 g.name.toLowerCase().replace(/\s+/g, '') === lower.replace(/\s+/g, '')
          );
        if (match) {
          await selectGameById(match.id);
          await launchSelectedGame();
        } else {
          log('No saved game found matching "' + loadParam + '".', "error");
        }
      }
    } catch (error) {
      console.error(error);
      setEmptyEntryState("Initialization failed");
      log("Initialization failed: " + (error.message || String(error)), "error");
      setActionButtonsDisabled(true);
    }
  })();
})();
</script>

</body>
</html>
